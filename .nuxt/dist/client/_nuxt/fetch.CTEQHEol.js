import{az as k,aA as E,aB as B,aC as R,aD as A}from"./entry.CSVvCESN.js";import{a as C,s as F,t as T,a4 as j,B as P,w as z,u as M,g as U,c as $,af as p,r as H}from"./swiper-vue.1nsUfrxU.js";const L=n=>n==="defer"||n===!1;function q(...n){var v;const u=typeof n[n.length-1]=="string"?n.pop():void 0;typeof n[0]!="string"&&n.unshift(u);let[a,o,e={}]=n;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=E(),f=o,y=()=>null,w=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??y,e.getCachedData=e.getCachedData??w,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??k.deep,e.dedupe=e.dedupe??"cancel";const m=()=>![null,void 0].includes(e.getCachedData(a));if(!t._asyncData[a]||!e.immediate){(v=t.payload._errors)[a]??(v[a]=null);const i=e.deep?C:F;t._asyncData[a]={data:i(e.getCachedData(a)??e.default()),pending:C(!m()),error:T(t.payload._errors,a),status:C("idle")}}const s={...t._asyncData[a]};s.refresh=s.execute=(i={})=>{if(t._asyncDataPromises[a]){if(L(i.dedupe??e.dedupe))return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((i._initial||t.isHydrating&&i._initial!==!1)&&m())return Promise.resolve(e.getCachedData(a));s.pending.value=!0,s.status.value="pending";const l=new Promise((r,c)=>{try{r(f(t))}catch(_){c(_)}}).then(r=>{if(l.cancelled)return t._asyncDataPromises[a];let c=r;e.transform&&(c=e.transform(r)),e.pick&&(c=K(c,e.pick)),t.payload.data[a]=c,s.data.value=c,s.error.value=null,s.status.value="success"}).catch(r=>{if(l.cancelled)return t._asyncDataPromises[a];s.error.value=B(r),s.data.value=M(e.default()),s.status.value="error"}).finally(()=>{l.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=l,t._asyncDataPromises[a]};const g=()=>s.refresh({_initial:!0}),b=e.server!==!1&&t.payload.serverRendered;{const i=U();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const r=i._nuxtOnBeforeMountCbs;i&&(j(()=>{r.forEach(c=>{c()}),r.splice(0,r.length)}),P(()=>r.splice(0,r.length)))}b&&t.isHydrating&&(s.error.value||m())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?i._nuxtOnBeforeMountCbs.push(g):e.immediate&&g(),e.watch&&z(e.watch,()=>s.refresh());const l=t.hook("app:data:refresh",async r=>{(!r||r.includes(a))&&await s.refresh()});i&&P(l)}const D=Promise.resolve(t._asyncDataPromises[a]).then(()=>s);return Object.assign(D,s),D}function K(n,u){const a={};for(const o of u)a[o]=n[o];return a}function J(n,u,a){const[o={},e]=typeof u=="string"?[{},u]:[u,a],t=$(()=>{let h=n;return typeof h=="function"&&(h=h()),p(h)}),f=o.key||R([e,typeof t.value=="string"?t.value:"",...S(o)]);if(!f||typeof f!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+f);if(!n)throw new Error("[nuxt] [useFetch] request is missing.");const y=f===e?"$f"+f:f;if(!o.baseURL&&typeof t.value=="string"&&t.value[0]==="/"&&t.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:w,lazy:m,default:s,transform:g,pick:b,watch:D,immediate:v,getCachedData:i,deep:l,dedupe:r,...c}=o,_=H({...A,...c,cache:typeof o.cache=="boolean"?void 0:o.cache}),O={server:w,lazy:m,default:s,transform:g,pick:b,immediate:v,getCachedData:i,deep:l,dedupe:r,watch:D===!1?[]:[_,t,...D||[]]};let d;return q(y,()=>{var x;(x=d==null?void 0:d.abort)==null||x.call(d),d=typeof AbortController<"u"?new AbortController:{};const h=p(o.timeout);return h&&setTimeout(()=>d.abort(),h),(o.$fetch||globalThis.$fetch)(t.value,{signal:d.signal,..._})},O)}function S(n){var a;const u=[((a=p(n.method))==null?void 0:a.toUpperCase())||"GET",p(n.baseURL)];for(const o of[n.params||n.query]){const e=p(o);if(!e)continue;const t={};for(const[f,y]of Object.entries(e))t[p(f)]=p(y);u.push(t)}return u}export{J as u};
