{
  "resolvedId": "C:/Users/HP/Desktop/projets/next/000/update/coumbassa_sanden/node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import maplibregl__default from 'maplibre-gl';\nexport * from 'maplibre-gl';\nimport { Base64 } from 'js-base64';\nimport EventEmitter from 'events';\nimport { config as config$1, MapStyle, mapStylePresetList, expandMapStyle, MapStyleVariant, ReferenceMapStyle, geolocation } from '@maptiler/client';\nexport { LanguageGeocoding, MapStyle, MapStyleVariant, ReferenceMapStyle, ServiceError, bufferToPixelDataBrowser, circumferenceAtLatitude, coordinates, data, elevation, expandMapStyle, geocoding, geolocation, getAutoLanguageGeocoding, getBufferToPixelDataParser, getTileCache, mapStylePresetList, math, misc, staticMaps, styleToStyle } from '@maptiler/client';\nimport { v4 } from 'uuid';\n\nconst Language = {\n  /**\n   * The visitor language mode concatenates the prefered language from the user settings and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR: \"visitor\",\n  /**\n   * The visitor language mode concatenates English and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR_ENGLISH: \"visitor_en\",\n  /**\n   * Language as the style is designed. Not that this is the default state and one\n   * the language has been changed to another than `STYLE`, then it cannot be set back to `STYLE`.\n   */\n  STYLE: \"style\",\n  /**\n   * AUTO mode uses the language of the browser\n   */\n  AUTO: \"auto\",\n  /**\n   * STYLE is a custom flag to keep the language of the map as defined into the style.\n   * If STYLE is set in the constructor, then further modification of the language\n   * with `.setLanguage()` is not possible.\n   */\n  STYLE_LOCK: \"style_lock\",\n  /**\n   * Default fallback languages that uses latin charaters\n   */\n  LATIN: \"name:latin\",\n  /**\n   * Default fallback languages that uses non-latin charaters\n   */\n  NON_LATIN: \"name:nonlatin\",\n  /**\n   * Labels are in their local language, when available\n   */\n  LOCAL: \"name\",\n  /**\n   * International name\n   */\n  INTERNATIONAL: \"name_int\",\n  ALBANIAN: \"name:sq\",\n  AMHARIC: \"name:am\",\n  ARABIC: \"name:ar\",\n  ARMENIAN: \"name:hy\",\n  AZERBAIJANI: \"name:az\",\n  BASQUE: \"name:eu\",\n  BELORUSSIAN: \"name:be\",\n  BENGALI: \"name:bn\",\n  BOSNIAN: \"name:bs\",\n  BRETON: \"name:br\",\n  BULGARIAN: \"name:bg\",\n  CATALAN: \"name:ca\",\n  CHINESE: \"name:zh\",\n  TRADITIONAL_CHINESE: \"name:zh-Hant\",\n  SIMPLIFIED_CHINESE: \"name:zh-Hans\",\n  CORSICAN: \"name:co\",\n  CROATIAN: \"name:hr\",\n  CZECH: \"name:cs\",\n  DANISH: \"name:da\",\n  DUTCH: \"name:nl\",\n  ENGLISH: \"name:en\",\n  ESPERANTO: \"name:eo\",\n  ESTONIAN: \"name:et\",\n  FINNISH: \"name:fi\",\n  FRENCH: \"name:fr\",\n  FRISIAN: \"name:fy\",\n  GEORGIAN: \"name:ka\",\n  GERMAN: \"name:de\",\n  GREEK: \"name:el\",\n  HEBREW: \"name:he\",\n  HINDI: \"name:hi\",\n  HUNGARIAN: \"name:hu\",\n  ICELANDIC: \"name:is\",\n  INDONESIAN: \"name:id\",\n  IRISH: \"name:ga\",\n  ITALIAN: \"name:it\",\n  JAPANESE: \"name:ja\",\n  JAPANESE_HIRAGANA: \"name:ja-Hira\",\n  JAPANESE_KANA: \"name:ja_kana\",\n  JAPANESE_LATIN: \"name:ja_rm\",\n  JAPANESE_2018: \"name:ja-Latn\",\n  KANNADA: \"name:kn\",\n  KAZAKH: \"name:kk\",\n  KOREAN: \"name:ko\",\n  KOREAN_LATIN: \"name:ko-Latn\",\n  KURDISH: \"name:ku\",\n  ROMAN_LATIN: \"name:la\",\n  LATVIAN: \"name:lv\",\n  LITHUANIAN: \"name:lt\",\n  LUXEMBOURGISH: \"name:lb\",\n  MACEDONIAN: \"name:mk\",\n  MALAYALAM: \"name:ml\",\n  MALTESE: \"name:mt\",\n  NORWEGIAN: \"name:no\",\n  OCCITAN: \"name:oc\",\n  PERSIAN: \"name:fa\",\n  POLISH: \"name:pl\",\n  PORTUGUESE: \"name:pt\",\n  PUNJABI: \"name:pa\",\n  WESTERN_PUNJABI: \"name:pnb\",\n  ROMANIAN: \"name:ro\",\n  ROMANSH: \"name:rm\",\n  RUSSIAN: \"name:ru\",\n  SCOTTISH_GAELIC: \"name:gd\",\n  SERBIAN_CYRILLIC: \"name:sr\",\n  SERBIAN_LATIN: \"name:sr-Latn\",\n  SLOVAK: \"name:sk\",\n  SLOVENE: \"name:sl\",\n  SPANISH: \"name:es\",\n  SWEDISH: \"name:sv\",\n  TAMIL: \"name:ta\",\n  TELUGU: \"name:te\",\n  THAI: \"name:th\",\n  TURKISH: \"name:tr\",\n  UKRAINIAN: \"name:uk\",\n  URDU: \"name:ur\",\n  VIETNAMIAN_LATIN: \"name:vi\",\n  WELSH: \"name:cy\"\n};\nconst languagesIsoSet = new Set(Object.values(Language));\nfunction isLanguageSupported(lang) {\n  return languagesIsoSet.has(lang);\n}\nconst languageCodeSet = new Set(Object.values(Language));\nfunction getBrowserLanguage() {\n  if (typeof navigator === \"undefined\") {\n    return `name:${Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0]}`;\n  }\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => `name:${l.split(\"-\")[0]}`))\n  ).filter((l) => languageCodeSet.has(l));\n  return canditatelangs.length ? canditatelangs[0] : Language.LOCAL;\n}\n\nconst defaults = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: Language.STYLE,\n  secondaryLanguage: Language.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\"\n};\nObject.freeze(defaults);\n\nvar __defProp$b = Object.defineProperty;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$8 = (obj, key, value) => {\n  __defNormalProp$b(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst MAPTILER_SESSION_ID = v4();\nclass SdkConfig extends EventEmitter {\n  constructor() {\n    super();\n    /**\n     * The primary language. By default, the language of the web browser is used.\n     */\n    __publicField$8(this, \"primaryLanguage\", defaults.primaryLanguage);\n    /**\n     * The secondary language, to overwrite the default language defined in the map style.\n     * This settings is highly dependant on the style compatibility and may not work in most cases.\n     */\n    __publicField$8(this, \"secondaryLanguage\");\n    /**\n     * Setting on whether of not the SDK runs with a session logic.\n     * A \"session\" is started at the initialization of the SDK and finished when the browser\n     * page is being refreshed.\n     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n     * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n     */\n    __publicField$8(this, \"session\", true);\n    /**\n     * Unit to be used\n     */\n    __publicField$8(this, \"_unit\", \"metric\");\n    /**\n     * MapTiler Cloud API key\n     */\n    __publicField$8(this, \"_apiKey\", \"\");\n  }\n  /**\n   * Set the unit system\n   */\n  set unit(u) {\n    this._unit = u;\n    this.emit(\"unit\", u);\n  }\n  /**\n   * Get the unit system\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n    config$1.apiKey = k;\n    this.emit(\"apiKey\", k);\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    config$1.fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return config$1.fetch;\n  }\n}\nconst config = new SdkConfig();\n\nclass LogoControl extends maplibregl__default.LogoControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$7 = (obj, key, value) => {\n  __defNormalProp$a(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerLogoControl extends LogoControl {\n  constructor(options = {}) {\n    var _a, _b;\n    super(options);\n    __publicField$7(this, \"logoURL\", \"\");\n    __publicField$7(this, \"linkURL\", \"\");\n    this.logoURL = (_a = options.logoURL) != null ? _a : defaults.maptilerLogoURL;\n    this.linkURL = (_b = options.linkURL) != null ? _b : defaults.maptilerURL;\n  }\n  onAdd(map) {\n    var _a;\n    this._map = map;\n    this._compact = (_a = this.options.compact) != null ? _a : false;\n    this._container = window.document.createElement(\"div\");\n    this._container.className = \"maplibregl-ctrl\";\n    const anchor = window.document.createElement(\"a\");\n    anchor.style.backgroundRepeat = \"no-repeat\";\n    anchor.style.cursor = \"pointer\";\n    anchor.style.display = \"block\";\n    anchor.style.height = \"23px\";\n    anchor.style.margin = \"0 0 -4px -4px\";\n    anchor.style.overflow = \"hidden\";\n    anchor.style.width = \"88px\";\n    anchor.style.backgroundImage = `url(${this.logoURL})`;\n    anchor.style.backgroundSize = \"100px 30px\";\n    anchor.style.width = \"100px\";\n    anchor.style.height = \"30px\";\n    anchor.target = \"_blank\";\n    anchor.rel = \"noopener\";\n    anchor.href = this.linkURL;\n    anchor.setAttribute(\"aria-label\", \"MapTiler logo\");\n    anchor.setAttribute(\"rel\", \"noopener\");\n    this._container.appendChild(anchor);\n    this._container.style.display = \"block\";\n    this._map.on(\"resize\", this._updateCompact);\n    this._updateCompact();\n    return this._container;\n  }\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction enableRTL() {\n  if (maplibregl__default.getRTLTextPluginStatus() === \"unavailable\") {\n    maplibregl__default.setRTLTextPlugin(\n      defaults.rtlPluginURL,\n      (err) => {\n        if (err)\n          console.error(err);\n      },\n      true\n      // Lazy load the plugin\n    );\n  }\n}\nfunction bindAll(fns, context) {\n  fns.forEach((fn) => {\n    if (typeof context[fn] !== \"function\")\n      return;\n    context[fn] = context[fn].bind(context);\n  });\n}\nfunction DOMcreate(tagName, className, container) {\n  const el = window.document.createElement(tagName);\n  if (className !== void 0)\n    el.className = className;\n  if (container)\n    container.appendChild(el);\n  return el;\n}\nfunction DOMremove(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction maptilerCloudTransformRequest(url, _resourceType) {\n  let reqUrl = null;\n  try {\n    reqUrl = new URL(url);\n  } catch (e) {\n    return {\n      url\n    };\n  }\n  if (reqUrl.host === defaults.maptilerApiHost) {\n    if (!reqUrl.searchParams.has(\"key\")) {\n      reqUrl.searchParams.append(\"key\", config.apiKey);\n    }\n    if (config.session) {\n      reqUrl.searchParams.append(\"mtsid\", MAPTILER_SESSION_ID);\n    }\n  }\n  return {\n    url: reqUrl.href\n  };\n}\nfunction combineTransformRequest(userDefinedRTF) {\n  return function(url, resourceType) {\n    var _a;\n    if (userDefinedRTF !== void 0) {\n      const rp = userDefinedRTF(url, resourceType);\n      const rp2 = maptilerCloudTransformRequest((_a = rp == null ? void 0 : rp.url) != null ? _a : \"\");\n      return __spreadValues$5(__spreadValues$5({}, rp), rp2);\n    } else {\n      return maptilerCloudTransformRequest(url);\n    }\n  };\n}\nfunction generateRandomString() {\n  return Math.random().toString(36).substring(2);\n}\nfunction isUUID(s) {\n  const regexExp = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi;\n  return regexExp.test(s);\n}\nfunction jsonParseNoThrow(doc) {\n  try {\n    return JSON.parse(doc);\n  } catch (e) {\n  }\n  return null;\n}\n\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    if (!style.startsWith(\"http\") && style.toLowerCase().includes(\".json\")) {\n      return style;\n    } else {\n      return expandMapStyle(style);\n    }\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getExpandedStyleURL();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getExpandedStyleURL();\n  }\n  return style;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$6 = (obj, key, value) => {\n  __defNormalProp$8(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerTerrainControl {\n  constructor() {\n    __publicField$6(this, \"_map\");\n    __publicField$6(this, \"_container\");\n    __publicField$6(this, \"_terrainButton\");\n    bindAll([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n  onAdd(map) {\n    this._map = map;\n    this._container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    this._terrainButton = DOMcreate(\n      \"button\",\n      \"maplibregl-ctrl-terrain\",\n      this._container\n    );\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\n      \"aria-hidden\",\n      \"true\"\n    );\n    this._terrainButton.type = \"button\";\n    this._terrainButton.addEventListener(\"click\", this._toggleTerrain);\n    this._updateTerrainIcon();\n    this._map.on(\"terrain\", this._updateTerrainIcon);\n    return this._container;\n  }\n  onRemove() {\n    DOMremove(this._container);\n    this._map.off(\"terrain\", this._updateTerrainIcon);\n    this._map = void 0;\n  }\n  _toggleTerrain() {\n    if (this._map.hasTerrain()) {\n      this._map.disableTerrain();\n    } else {\n      this._map.enableTerrain();\n    }\n    this._updateTerrainIcon();\n  }\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\");\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\");\n    if (this._map.hasTerrain()) {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.disableTerrain\"\n      );\n    } else {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.enableTerrain\"\n      );\n    }\n  }\n}\n\nclass NavigationControl extends maplibregl__default.NavigationControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$5 = (obj, key, value) => {\n  __defNormalProp$7(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerNavigationControl extends NavigationControl {\n  constructor() {\n    super({\n      showCompass: true,\n      showZoom: true,\n      visualizePitch: true\n    });\n    /**\n     * Overloading: Limit how flat the compass icon can get\n     */\n    __publicField$5(this, \"_rotateCompassArrow\", () => {\n      const rotate = this.options.visualizePitch ? `scale(${Math.min(\n        1.5,\n        1 / Math.pow(\n          Math.cos(this._map.transform.pitch * (Math.PI / 180)),\n          0.5\n        )\n      )}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n      this._compassIcon.style.transform = rotate;\n    });\n    this._compass.removeEventListener(\n      \"click\",\n      this._compass.clickFunction\n    );\n    this._compass.addEventListener(\"click\", (e) => {\n      {\n        const currentPitch = this._map.getPitch();\n        if (currentPitch === 0) {\n          this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) });\n        } else {\n          if (this.options.visualizePitch) {\n            this._map.resetNorthPitch({}, { originalEvent: e });\n          } else {\n            this._map.resetNorth({}, { originalEvent: e });\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(className, fn) {\n    const button = super._createButton(className, fn);\n    button.clickFunction = fn;\n    return button;\n  }\n}\n\nclass GeolocateControl extends maplibregl__default.GeolocateControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __publicField$4 = (obj, key, value) => {\n  __defNormalProp$6(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Marker$1 = maplibregl__default.Marker;\nconst LngLat$1 = maplibregl__default.LngLat;\nconst LngLatBounds$1 = maplibregl__default.LngLatBounds;\nclass MaptilerGeolocateControl extends GeolocateControl {\n  constructor() {\n    super(...arguments);\n    __publicField$4(this, \"lastUpdatedCenter\", new LngLat$1(0, 0));\n    /**\n     * Update the camera location to center on the current position\n     *\n     * @param {Position} position the Geolocation API Position\n     * @private\n     */\n    __publicField$4(this, \"_updateCamera\", (position) => {\n      var _a, _b, _c;\n      const center = new LngLat$1(\n        position.coords.longitude,\n        position.coords.latitude\n      );\n      const radius = position.coords.accuracy;\n      const bearing = this._map.getBearing();\n      const options = __spreadProps$3(__spreadValues$4({\n        bearing\n      }, this.options.fitBoundsOptions), {\n        linear: true\n      });\n      const currentMapZoom = this._map.getZoom();\n      if (currentMapZoom > ((_c = (_b = (_a = this.options) == null ? void 0 : _a.fitBoundsOptions) == null ? void 0 : _b.maxZoom) != null ? _c : 30)) {\n        options.zoom = currentMapZoom;\n      }\n      this._map.fitBounds(LngLatBounds$1.fromLngLat(center, radius), options, {\n        geolocateSource: true\n        // tag this camera change so it won't cause the control to change to background state\n      });\n      let hasFittingBeenDisrupted = false;\n      const flagFittingDisruption = () => {\n        hasFittingBeenDisrupted = true;\n      };\n      this._map.once(\"click\", flagFittingDisruption);\n      this._map.once(\"dblclick\", flagFittingDisruption);\n      this._map.once(\"dragstart\", flagFittingDisruption);\n      this._map.once(\"mousedown\", flagFittingDisruption);\n      this._map.once(\"touchstart\", flagFittingDisruption);\n      this._map.once(\"wheel\", flagFittingDisruption);\n      this._map.once(\"moveend\", () => {\n        this._map.off(\"click\", flagFittingDisruption);\n        this._map.off(\"dblclick\", flagFittingDisruption);\n        this._map.off(\"dragstart\", flagFittingDisruption);\n        this._map.off(\"mousedown\", flagFittingDisruption);\n        this._map.off(\"touchstart\", flagFittingDisruption);\n        this._map.off(\"wheel\", flagFittingDisruption);\n        if (hasFittingBeenDisrupted) {\n          return;\n        }\n        this.lastUpdatedCenter = this._map.getCenter();\n      });\n    });\n    __publicField$4(this, \"_setupUI\", (supported) => {\n      this.lastUpdatedCenter = this._map.getCenter();\n      this._container.addEventListener(\n        \"contextmenu\",\n        (e) => e.preventDefault()\n      );\n      this._geolocateButton = DOMcreate(\n        \"button\",\n        \"maplibregl-ctrl-geolocate\",\n        this._container\n      );\n      DOMcreate(\n        \"span\",\n        \"maplibregl-ctrl-icon\",\n        this._geolocateButton\n      ).setAttribute(\"aria-hidden\", \"true\");\n      this._geolocateButton.type = \"button\";\n      if (supported === false) {\n        const title = this._map._getUIString(\n          \"GeolocateControl.LocationNotAvailable\"\n        );\n        this._geolocateButton.disabled = true;\n        this._geolocateButton.title = title;\n        this._geolocateButton.setAttribute(\"aria-label\", title);\n      } else {\n        const title = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n        this._geolocateButton.title = title;\n        this._geolocateButton.setAttribute(\"aria-label\", title);\n      }\n      if (this.options.trackUserLocation) {\n        this._geolocateButton.setAttribute(\"aria-pressed\", \"false\");\n        this._watchState = \"OFF\";\n      }\n      if (this.options.showUserLocation) {\n        this._dotElement = DOMcreate(\"div\", \"maplibregl-user-location-dot\");\n        this._userLocationDotMarker = new Marker$1({ element: this._dotElement });\n        this._circleElement = DOMcreate(\n          \"div\",\n          \"maplibregl-user-location-accuracy-circle\"\n        );\n        this._accuracyCircleMarker = new Marker$1({\n          element: this._circleElement,\n          pitchAlignment: \"map\"\n        });\n        if (this.options.trackUserLocation)\n          this._watchState = \"OFF\";\n        this._map.on(\"move\", this._onZoom);\n      }\n      this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this));\n      this._setup = true;\n      if (this.options.trackUserLocation) {\n        this._map.on(\"moveend\", (event) => {\n          const fromResize = event.originalEvent && event.originalEvent.type === \"resize\";\n          const movingDistance = this.lastUpdatedCenter.distanceTo(\n            this._map.getCenter()\n          );\n          if (!event.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !fromResize && movingDistance > 1) {\n            this._watchState = \"BACKGROUND\";\n            this._geolocateButton.classList.add(\n              \"maplibregl-ctrl-geolocate-background\"\n            );\n            this._geolocateButton.classList.remove(\n              \"maplibregl-ctrl-geolocate-active\"\n            );\n            this.fire(new Event(\"trackuserlocationend\"));\n          }\n        });\n      }\n    });\n    __publicField$4(this, \"_onZoom\", () => {\n      if (this.options.showUserLocation && this.options.showAccuracyCircle) {\n        this._updateCircleRadius();\n      }\n    });\n  }\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\") {\n      return;\n    }\n    const lastKnownLocation = [\n      this._lastKnownPosition.coords.longitude,\n      this._lastKnownPosition.coords.latitude\n    ];\n    const projectedLocation = this._map.project(lastKnownLocation);\n    const a = this._map.unproject([projectedLocation.x, projectedLocation.y]);\n    const b = this._map.unproject([\n      projectedLocation.x + 20,\n      projectedLocation.y\n    ]);\n    const metersPerPixel = a.distanceTo(b) / 20;\n    const circleDiameter = Math.ceil(2 * this._accuracy / metersPerPixel);\n    this._circleElement.style.width = `${circleDiameter}px`;\n    this._circleElement.style.height = `${circleDiameter}px`;\n  }\n}\n\nclass AttributionControl extends maplibregl__default.AttributionControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nclass ScaleControl extends maplibregl__default.ScaleControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nclass FullscreenControl extends maplibregl__default.FullscreenControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __publicField$3 = (obj, key, value) => {\n  __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _options, _parentMap, _container, _canvasContainer, _parentRect, _differentStyle, _desync, _addParentRect, addParentRect_fn, _setParentBounds, setParentBounds_fn, _syncMaps, syncMaps_fn;\nclass Minimap {\n  constructor(options, mapOptions) {\n    __privateAdd(this, _addParentRect);\n    __privateAdd(this, _setParentBounds);\n    __privateAdd(this, _syncMaps);\n    __privateAdd(this, _options, void 0);\n    __publicField$3(this, \"map\");\n    __privateAdd(this, _parentMap, void 0);\n    __privateAdd(this, _container, void 0);\n    __privateAdd(this, _canvasContainer, void 0);\n    __privateAdd(this, _parentRect, void 0);\n    __privateAdd(this, _differentStyle, false);\n    __privateAdd(this, _desync, void 0);\n    var _a;\n    if (options.style !== void 0)\n      __privateSet(this, _differentStyle, true);\n    __privateSet(this, _options, __spreadProps$2(__spreadValues$3(__spreadProps$2(__spreadValues$3({\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\"\n    }, mapOptions), {\n      // override any lingering control options\n      forceNoAttributionControl: true,\n      attributionControl: false,\n      navigationControl: false,\n      geolocateControl: false,\n      maptilerLogo: false,\n      minimap: false,\n      hash: false,\n      pitchAdjust: false\n    }), options), {\n      containerStyle: __spreadValues$3({\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\"\n      }, (_a = options.containerStyle) != null ? _a : {})\n    }));\n    if (options.lockZoom !== void 0) {\n      __privateGet(this, _options).minZoom = options.lockZoom;\n      __privateGet(this, _options).maxZoom = options.lockZoom;\n    }\n  }\n  setStyle(style, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setStyle(style, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n  }\n  addLayer(layer, beforeId) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.addLayer(layer, beforeId);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this.map;\n  }\n  moveLayer(id, beforeId) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.moveLayer(id, beforeId);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this.map;\n  }\n  removeLayer(id) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.removeLayer(id);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setLayerZoomRange(layerId, minzoom, maxzoom) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setLayerZoomRange(layerId, minzoom, maxzoom);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setFilter(layerId, filter, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setFilter(layerId, filter, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setPaintProperty(layerId, name, value, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setPaintProperty(layerId, name, value, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setLayoutProperty(layerId, name, value, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setLayoutProperty(layerId, name, value, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setGlyphs(glyphsUrl, options) {\n    if (!__privateGet(this, _differentStyle))\n      this.map.setGlyphs(glyphsUrl, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  onAdd(parentMap) {\n    __privateSet(this, _parentMap, parentMap);\n    __privateSet(this, _container, DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"));\n    for (const [key, value] of Object.entries(__privateGet(this, _options).containerStyle)) {\n      __privateGet(this, _container).style.setProperty(key, value);\n    }\n    __privateGet(this, _options).container = __privateGet(this, _container);\n    __privateGet(this, _options).zoom = parentMap.getZoom() + __privateGet(this, _options).zoomAdjust;\n    this.map = new Map(__privateGet(this, _options));\n    this.map.once(\"style.load\", () => {\n      this.map.resize();\n    });\n    this.map.once(\"load\", () => {\n      __privateMethod(this, _addParentRect, addParentRect_fn).call(this, __privateGet(this, _options).parentRect);\n      __privateSet(this, _desync, __privateMethod(this, _syncMaps, syncMaps_fn).call(this));\n    });\n    return __privateGet(this, _container);\n  }\n  onRemove() {\n    var _a;\n    (_a = __privateGet(this, _desync)) == null ? void 0 : _a.call(this);\n    DOMremove(__privateGet(this, _container));\n  }\n}\n_options = new WeakMap();\n_parentMap = new WeakMap();\n_container = new WeakMap();\n_canvasContainer = new WeakMap();\n_parentRect = new WeakMap();\n_differentStyle = new WeakMap();\n_desync = new WeakMap();\n_addParentRect = new WeakSet();\naddParentRect_fn = function(rect) {\n  if (rect === void 0 || rect.linePaint === void 0 && rect.fillPaint === void 0) {\n    return;\n  }\n  __privateSet(this, _parentRect, {\n    type: \"Feature\",\n    properties: {\n      name: \"parentRect\"\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [[[], [], [], [], []]]\n    }\n  });\n  this.map.addSource(\"parentRect\", {\n    type: \"geojson\",\n    data: __privateGet(this, _parentRect)\n  });\n  if (rect.lineLayout !== void 0 || rect.linePaint !== void 0) {\n    this.map.addLayer({\n      id: \"parentRectOutline\",\n      type: \"line\",\n      source: \"parentRect\",\n      layout: __spreadValues$3({}, rect.lineLayout),\n      paint: __spreadValues$3({\n        \"line-color\": \"#FFF\",\n        \"line-width\": 1,\n        \"line-opacity\": 0.85\n      }, rect.linePaint)\n    });\n  }\n  if (rect.fillPaint !== void 0) {\n    this.map.addLayer({\n      id: \"parentRectFill\",\n      type: \"fill\",\n      source: \"parentRect\",\n      layout: {},\n      paint: __spreadValues$3({\n        \"fill-color\": \"#08F\",\n        \"fill-opacity\": 0.135\n      }, rect.fillPaint)\n    });\n  }\n  __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n};\n_setParentBounds = new WeakSet();\nsetParentBounds_fn = function() {\n  if (__privateGet(this, _parentRect) === void 0)\n    return;\n  const { devicePixelRatio } = window;\n  const canvas = __privateGet(this, _parentMap).getCanvas();\n  const width = canvas.width / devicePixelRatio;\n  const height = canvas.height / devicePixelRatio;\n  const unproject = __privateGet(this, _parentMap).unproject.bind(__privateGet(this, _parentMap));\n  const northWest = unproject([0, 0]);\n  const northEast = unproject([width, 0]);\n  const southWest = unproject([0, height]);\n  const southEast = unproject([width, height]);\n  __privateGet(this, _parentRect).geometry.coordinates = [\n    [\n      southWest.toArray(),\n      southEast.toArray(),\n      northEast.toArray(),\n      northWest.toArray(),\n      southWest.toArray()\n    ]\n  ];\n  const source = this.map.getSource(\"parentRect\");\n  source.setData(__privateGet(this, _parentRect));\n};\n_syncMaps = new WeakSet();\nsyncMaps_fn = function() {\n  const { pitchAdjust } = __privateGet(this, _options);\n  const parentCallback = () => {\n    sync(\"parent\");\n  };\n  const minimapCallback = () => {\n    sync(\"minimap\");\n  };\n  const on = () => {\n    __privateGet(this, _parentMap).on(\"move\", parentCallback);\n    this.map.on(\"move\", minimapCallback);\n  };\n  const off = () => {\n    __privateGet(this, _parentMap).off(\"move\", parentCallback);\n    this.map.off(\"move\", minimapCallback);\n  };\n  const sync = (which) => {\n    var _a;\n    off();\n    const from = which === \"parent\" ? __privateGet(this, _parentMap) : this.map;\n    const to = which === \"parent\" ? this.map : __privateGet(this, _parentMap);\n    const center = from.getCenter();\n    const zoom = from.getZoom() + ((_a = __privateGet(this, _options).zoomAdjust) != null ? _a : -4) * (which === \"parent\" ? 1 : -1);\n    const bearing = from.getBearing();\n    const pitch = from.getPitch();\n    to.jumpTo({\n      center,\n      zoom,\n      bearing,\n      pitch: pitchAdjust ? pitch : 0\n    });\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    on();\n  };\n  on();\n  return () => {\n    off();\n  };\n};\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async$1 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst GeolocationType = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\"\n};\nclass Map extends maplibregl__default.Map {\n  constructor(options) {\n    var _a, _b, _c;\n    if (options.apiKey) {\n      config.apiKey = options.apiKey;\n    }\n    const style = styleToStyle(options.style);\n    const hashPreConstructor = location.hash;\n    if (!config.apiKey) {\n      console.warn(\n        \"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\"\n      );\n    }\n    super(__spreadProps$1(__spreadValues$2({}, options), {\n      style,\n      maplibreLogo: false,\n      transformRequest: combineTransformRequest(options.transformRequest)\n    }));\n    __publicField$2(this, \"isTerrainEnabled\", false);\n    __publicField$2(this, \"terrainExaggeration\", 1);\n    __publicField$2(this, \"primaryLanguage\");\n    __publicField$2(this, \"terrainGrowing\", false);\n    __publicField$2(this, \"terrainFlattening\", false);\n    __publicField$2(this, \"minimap\");\n    __publicField$2(this, \"forceLanguageUpdate\");\n    __publicField$2(this, \"languageAlwaysBeenStyle\");\n    __publicField$2(this, \"isReady\", false);\n    this.primaryLanguage = (_a = options.language) != null ? _a : config.primaryLanguage;\n    this.forceLanguageUpdate = this.primaryLanguage === Language.STYLE || this.primaryLanguage === Language.STYLE_LOCK ? false : true;\n    this.languageAlwaysBeenStyle = this.primaryLanguage === Language.STYLE;\n    this.terrainExaggeration = (_b = options.terrainExaggeration) != null ? _b : this.terrainExaggeration;\n    this.once(\"styledata\", () => __async$1(this, null, function* () {\n      if (!options.geolocate) {\n        return;\n      }\n      if (options.center) {\n        return;\n      }\n      if (options.hash && !!hashPreConstructor) {\n        return;\n      }\n      try {\n        if (options.geolocate === GeolocationType.COUNTRY) {\n          yield this.fitToIpBounds();\n          return;\n        }\n      } catch (e) {\n        console.warn(e.message);\n      }\n      let ipLocatedCameraHash;\n      try {\n        yield this.centerOnIpPoint(options.zoom);\n        ipLocatedCameraHash = this.getCameraHash();\n      } catch (e) {\n        console.warn(e.message);\n      }\n      const locationResult = yield navigator.permissions.query({\n        name: \"geolocation\"\n      });\n      if (locationResult.state === \"granted\") {\n        navigator.geolocation.getCurrentPosition(\n          // success callback\n          (data) => {\n            if (ipLocatedCameraHash !== this.getCameraHash()) {\n              return;\n            }\n            if (this.terrain) {\n              this.easeTo({\n                center: [data.coords.longitude, data.coords.latitude],\n                zoom: options.zoom || 12,\n                duration: 2e3\n              });\n            } else {\n              this.once(\"terrain\", () => {\n                this.easeTo({\n                  center: [data.coords.longitude, data.coords.latitude],\n                  zoom: options.zoom || 12,\n                  duration: 2e3\n                });\n              });\n            }\n          },\n          // error callback\n          null,\n          // options\n          {\n            maximumAge: 24 * 3600 * 1e3,\n            // a day in millisec\n            timeout: 5e3,\n            // milliseconds\n            enableHighAccuracy: false\n          }\n        );\n      }\n    }));\n    this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    });\n    this.on(\"styledata\", () => {\n      if (this.getTerrain() === null && this.isTerrainEnabled) {\n        this.enableTerrain(this.terrainExaggeration);\n      }\n    });\n    this.once(\"load\", () => __async$1(this, null, function* () {\n      enableRTL();\n    }));\n    this.once(\"load\", () => __async$1(this, null, function* () {\n      let tileJsonContent = { logo: null };\n      try {\n        const possibleSources = Object.keys(this.style.sourceCaches).map((sourceName) => this.getSource(sourceName)).filter(\n          (s) => s && \"url\" in s && typeof s.url === \"string\" && (s == null ? void 0 : s.url.includes(\"tiles.json\"))\n        );\n        const styleUrl = new URL(\n          possibleSources[0].url\n        );\n        if (!styleUrl.searchParams.has(\"key\")) {\n          styleUrl.searchParams.append(\"key\", config.apiKey);\n        }\n        const tileJsonRes = yield fetch(styleUrl.href);\n        tileJsonContent = yield tileJsonRes.json();\n      } catch (e) {\n      }\n      if (options.forceNoAttributionControl !== true) {\n        if (\"logo\" in tileJsonContent && tileJsonContent.logo) {\n          const logoURL = tileJsonContent.logo;\n          this.addControl(\n            new MaptilerLogoControl({ logoURL }),\n            options.logoPosition\n          );\n          if (options.attributionControl === false) {\n            this.addControl(\n              new AttributionControl({\n                customAttribution: options.customAttribution\n              })\n            );\n          }\n        } else if (options.maptilerLogo) {\n          this.addControl(new MaptilerLogoControl(), options.logoPosition);\n        }\n      }\n      if (options.scaleControl) {\n        const position = options.scaleControl === true || options.scaleControl === void 0 ? \"bottom-right\" : options.scaleControl;\n        const scaleControl = new ScaleControl({ unit: config.unit });\n        this.addControl(scaleControl, position);\n        config.on(\"unit\", (unit) => {\n          scaleControl.setUnit(unit);\n        });\n      }\n      if (options.navigationControl !== false) {\n        const position = options.navigationControl === true || options.navigationControl === void 0 ? \"top-right\" : options.navigationControl;\n        this.addControl(new MaptilerNavigationControl(), position);\n      }\n      if (options.geolocateControl !== false) {\n        const position = options.geolocateControl === true || options.geolocateControl === void 0 ? \"top-right\" : options.geolocateControl;\n        this.addControl(\n          // new maplibregl.GeolocateControl({\n          new MaptilerGeolocateControl({\n            positionOptions: {\n              enableHighAccuracy: true,\n              maximumAge: 0,\n              timeout: 6e3\n            },\n            fitBoundsOptions: {\n              maxZoom: 15\n            },\n            trackUserLocation: true,\n            showAccuracyCircle: true,\n            showUserLocation: true\n          }),\n          position\n        );\n      }\n      if (options.terrainControl) {\n        const position = options.terrainControl === true || options.terrainControl === void 0 ? \"top-right\" : options.terrainControl;\n        this.addControl(new MaptilerTerrainControl(), position);\n      }\n      if (options.fullscreenControl) {\n        const position = options.fullscreenControl === true || options.fullscreenControl === void 0 ? \"top-right\" : options.fullscreenControl;\n        this.addControl(new FullscreenControl({}), position);\n      }\n      this.isReady = true;\n      this.fire(\"ready\", { target: this });\n    }));\n    let loadEventTriggered = false;\n    let terrainEventTriggered = false;\n    let terrainEventData;\n    this.once(\"ready\", () => {\n      loadEventTriggered = true;\n      if (terrainEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    });\n    this.once(\"style.load\", () => {\n      var _a2;\n      const { minimap } = options;\n      if (typeof minimap === \"object\") {\n        const {\n          zoom,\n          center,\n          style: style2,\n          language,\n          apiKey,\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle\n        } = options;\n        this.minimap = new Minimap(minimap, {\n          zoom,\n          center,\n          style: style2,\n          language,\n          apiKey,\n          container: \"null\",\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle\n        });\n        this.addControl(this.minimap, (_a2 = minimap.position) != null ? _a2 : \"bottom-left\");\n      } else if (minimap === true) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, \"bottom-left\");\n      } else if (minimap !== void 0 && minimap !== false) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, minimap);\n      }\n    });\n    const terrainCallback = (evt) => {\n      if (!evt.terrain)\n        return;\n      terrainEventTriggered = true;\n      terrainEventData = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: evt.terrain\n      };\n      this.off(\"terrain\", terrainCallback);\n      if (loadEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    };\n    this.on(\"terrain\", terrainCallback);\n    if (options.terrain) {\n      this.enableTerrain(\n        (_c = options.terrainExaggeration) != null ? _c : this.terrainExaggeration\n      );\n    }\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  onLoadAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve) => {\n        if (this.loaded()) {\n          return resolve(this);\n        }\n        this.once(\"load\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  onReadyAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve) => {\n        if (this.isReady) {\n          return resolve(this);\n        }\n        this.once(\"ready\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  onLoadWithTerrainAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve) => {\n        if (this.isReady && this.terrain) {\n          return resolve(this);\n        }\n        this.once(\"loadWithTerrain\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  setStyle(style, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setStyle(style);\n    this.forceLanguageUpdate = true;\n    this.once(\"idle\", () => {\n      this.forceLanguageUpdate = false;\n    });\n    return super.setStyle(styleToStyle(style), options);\n  }\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(layer, beforeId) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.addLayer(layer, beforeId);\n    return super.addLayer(layer, beforeId);\n  }\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(id, beforeId) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.moveLayer(id, beforeId);\n    return super.moveLayer(id, beforeId);\n  }\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(id) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.removeLayer(id);\n    return super.removeLayer(id);\n  }\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(layerId, minzoom, maxzoom) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setLayerZoomRange(layerId, minzoom, maxzoom);\n    return super.setLayerZoomRange(layerId, minzoom, maxzoom);\n  }\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(layerId, filter, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setFilter(layerId, filter, options);\n    return super.setFilter(layerId, filter, options);\n  }\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(layerId, name, value, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setPaintProperty(layerId, name, value, options);\n    return super.setPaintProperty(layerId, name, value, options);\n  }\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(layerId, name, value, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setLayoutProperty(layerId, name, value, options);\n    return super.setLayoutProperty(layerId, name, value, options);\n  }\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(glyphsUrl, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setGlyphs(glyphsUrl, options);\n    return super.setGlyphs(glyphsUrl, options);\n  }\n  getStyleLanguage() {\n    if (!this.style.stylesheet.metadata)\n      return null;\n    if (typeof this.style.stylesheet.metadata !== \"object\")\n      return null;\n    if (\"maptiler:language\" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata[\"maptiler:language\"] === \"string\") {\n      return this.style.stylesheet.metadata[\"maptiler:language\"];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(language) {\n    var _a, _b;\n    (_b = (_a = this.minimap) == null ? void 0 : _a.map) == null ? void 0 : _b.setLanguage(language);\n    this.onStyleReady(() => {\n      this.setPrimaryLanguage(language);\n    });\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setPrimaryLanguage(language) {\n    const styleLanguage = this.getStyleLanguage();\n    if (!(language === Language.STYLE && (styleLanguage === Language.AUTO || styleLanguage === Language.VISITOR))) {\n      if (language !== Language.STYLE) {\n        this.languageAlwaysBeenStyle = false;\n      }\n      if (this.languageAlwaysBeenStyle) {\n        return;\n      }\n      if (this.primaryLanguage === language && !this.forceLanguageUpdate) {\n        return;\n      }\n    }\n    if (!isLanguageSupported(language)) {\n      console.warn(`The language \"${language}\" is not supported.`);\n      return;\n    }\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\n        \"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\"\n      );\n      return;\n    }\n    this.primaryLanguage = language;\n    let languageNonStyle = language;\n    if (language === Language.STYLE) {\n      if (!styleLanguage) {\n        console.warn(\"The style has no default languages.\");\n        return;\n      }\n      if (!isLanguageSupported(styleLanguage)) {\n        console.warn(\"The language defined in the style is not valid.\");\n        return;\n      }\n      languageNonStyle = styleLanguage;\n    }\n    let langStr = Language.LOCAL;\n    let replacer = `{${langStr}}`;\n    if (languageNonStyle == Language.VISITOR) {\n      langStr = getBrowserLanguage();\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]],\n          [\"get\", Language.LOCAL],\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL],\n            { \"font-scale\": 1.1 }\n          ]\n        ],\n        [\"get\", Language.LOCAL]\n      ];\n    } else if (languageNonStyle == Language.VISITOR_ENGLISH) {\n      langStr = Language.ENGLISH;\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]],\n          [\"get\", Language.LOCAL],\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL],\n            { \"font-scale\": 1.1 }\n          ]\n        ],\n        [\"get\", Language.LOCAL]\n      ];\n    } else if (languageNonStyle === Language.AUTO) {\n      langStr = getBrowserLanguage();\n      replacer = [\n        \"case\",\n        [\"has\", langStr],\n        [\"get\", langStr],\n        [\"get\", Language.LOCAL]\n      ];\n    } else if (languageNonStyle === Language.LOCAL) {\n      langStr = Language.LOCAL;\n      replacer = `{${langStr}}`;\n    } else {\n      langStr = languageNonStyle;\n      replacer = [\n        \"case\",\n        [\"has\", langStr],\n        [\"get\", langStr],\n        [\"get\", Language.LOCAL]\n      ];\n    }\n    const { layers } = this.getStyle();\n    for (const { id, layout } of layers) {\n      if (!layout) {\n        continue;\n      }\n      if (!(\"text-field\" in layout)) {\n        continue;\n      }\n      const textFieldLayoutProp = this.getLayoutProperty(id, \"text-field\");\n      if (typeof textFieldLayoutProp === \"string\" && (textFieldLayoutProp.toLowerCase().includes(\"ref\") || textFieldLayoutProp.toLowerCase().includes(\"housenumber\"))) {\n        continue;\n      }\n      this.setLayoutProperty(id, \"text-field\", replacer);\n    }\n  }\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage() {\n    return this.primaryLanguage;\n  }\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration() {\n    return this.terrainExaggeration;\n  }\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain() {\n    return this.isTerrainEnabled;\n  }\n  growTerrain(exaggeration, durationMs = 1e3) {\n    if (!this.terrain) {\n      return;\n    }\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const deltaExaggeration = exaggeration - currentExaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainFlattening) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / durationMs;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = 1 - Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration + exaggerationFactor * deltaExaggeration;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.terrain.exaggeration = exaggeration;\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = true;\n    this.terrainFlattening = false;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(exaggeration = this.terrainExaggeration) {\n    if (exaggeration < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n    const dataEventTerrainGrow = (evt) => __async$1(this, null, function* () {\n      if (!this.terrain) {\n        return;\n      }\n      if (evt.type !== \"data\" || evt.dataType !== \"source\" || !(\"source\" in evt)) {\n        return;\n      }\n      if (evt.sourceId !== \"maptiler-terrain\") {\n        return;\n      }\n      const source = evt.source;\n      if (source.type !== \"raster-dem\") {\n        return;\n      }\n      if (!evt.isSourceLoaded) {\n        return;\n      }\n      this.off(\"data\", dataEventTerrainGrow);\n      this.growTerrain(exaggeration);\n    });\n    const addTerrain = () => {\n      this.isTerrainEnabled = true;\n      this.terrainExaggeration = exaggeration;\n      this.on(\"data\", dataEventTerrainGrow);\n      this.addSource(defaults.terrainSourceId, {\n        type: \"raster-dem\",\n        url: defaults.terrainSourceURL\n      });\n      this.setTerrain({\n        source: defaults.terrainSourceId,\n        exaggeration: 0\n      });\n    };\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = true;\n      this.growTerrain(exaggeration);\n      return;\n    }\n    if (this.loaded() || this.isTerrainEnabled) {\n      addTerrain();\n    } else {\n      this.once(\"load\", () => {\n        if (this.getTerrain() && this.getSource(defaults.terrainSourceId)) {\n          return;\n        }\n        addTerrain();\n      });\n    }\n  }\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    if (!this.terrain) {\n      return;\n    }\n    this.isTerrainEnabled = false;\n    const animationLoopDuration = 1 * 1e3;\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainGrowing) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / animationLoopDuration;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration * exaggerationFactor;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrain.exaggeration = 0;\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.setTerrain();\n        if (this.getSource(defaults.terrainSourceId)) {\n          this.removeSource(defaults.terrainSourceId);\n        }\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = false;\n    this.terrainFlattening = true;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(exaggeration, animate = true) {\n    if (!animate && this.terrain) {\n      this.terrainExaggeration = exaggeration;\n      this.terrain.exaggeration = exaggeration;\n      this.triggerRepaint();\n    } else {\n      this.enableTerrain(exaggeration);\n    }\n  }\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  onStyleReady(cb) {\n    if (this.isStyleLoaded()) {\n      cb();\n    } else {\n      this.once(\"styledata\", () => {\n        cb();\n      });\n    }\n  }\n  fitToIpBounds() {\n    return __async$1(this, null, function* () {\n      const ipGeolocateResult = yield geolocation.info();\n      this.fitBounds(\n        ipGeolocateResult.country_bounds,\n        {\n          duration: 0,\n          padding: 100\n        }\n      );\n    });\n  }\n  centerOnIpPoint(zoom) {\n    return __async$1(this, null, function* () {\n      var _a, _b;\n      const ipGeolocateResult = yield geolocation.info();\n      this.jumpTo({\n        center: [\n          (_a = ipGeolocateResult == null ? void 0 : ipGeolocateResult.longitude) != null ? _a : 0,\n          (_b = ipGeolocateResult == null ? void 0 : ipGeolocateResult.latitude) != null ? _b : 0\n        ],\n        zoom: zoom || 11\n      });\n    });\n  }\n  getCameraHash() {\n    const hashBin = new Float32Array(5);\n    const center = this.getCenter();\n    hashBin[0] = center.lng;\n    hashBin[1] = center.lat;\n    hashBin[2] = this.getZoom();\n    hashBin[3] = this.getPitch();\n    hashBin[4] = this.getBearing();\n    return Base64.fromUint8Array(new Uint8Array(hashBin.buffer));\n  }\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig() {\n    return config;\n  }\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId() {\n    return MAPTILER_SESSION_ID;\n  }\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(transformRequest) {\n    super.setTransformRequest(combineTransformRequest(transformRequest));\n    return this;\n  }\n  /**\n   * Loads an image. This is an async equivalent of `Map.loadImage`\n   */\n  loadImageAsync(url) {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        this.loadImage(\n          url,\n          (error, image) => {\n            if (error) {\n              reject(error);\n              return;\n            }\n            resolve(image);\n          }\n        );\n      });\n    });\n  }\n}\n\nclass Marker extends maplibregl__default.Marker {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\n\nclass Popup extends maplibregl__default.Popup {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\n\nclass Style extends maplibregl__default.Style {\n  constructor(map, options = {}) {\n    super(map, options);\n  }\n}\n\nclass CanvasSource extends maplibregl__default.CanvasSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass GeoJSONSource extends maplibregl__default.GeoJSONSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass ImageSource extends maplibregl__default.ImageSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass RasterTileSource extends maplibregl__default.RasterTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass RasterDEMTileSource extends maplibregl__default.RasterDEMTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass VectorTileSource extends maplibregl__default.VectorTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass VideoSource extends maplibregl__default.VideoSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\n\nclass TerrainControl extends maplibregl__default.TerrainControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Point {\n  constructor(x, y) {\n    __publicField$1(this, \"x\");\n    __publicField$1(this, \"y\");\n    this.x = x;\n    this.y = y;\n  }\n  _matMult(m) {\n    const x = m[0] * this.x + m[1] * this.y;\n    const y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _add(p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  _sub(p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  }\n  _mult(k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n  _div(k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  }\n  _multByPoint(p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  }\n  _divByPoint(p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  }\n  _unit() {\n    this._div(this.mag());\n    return this;\n  }\n  _perp() {\n    const y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  }\n  _rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * this.x - sin * this.y;\n    const y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _rotateAround(angle, p) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y);\n    const y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add(p) {\n    return this.clone()._add(p);\n  }\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub(p) {\n    return this.clone()._sub(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint(p) {\n    return this.clone()._multByPoint(p);\n  }\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint(p) {\n    return this.clone()._divByPoint(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Number} k factor\n   * @return {Point} output point\n   */\n  mult(k) {\n    return this.clone()._mult(k);\n  }\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div(k) {\n    return this.clone()._div(k);\n  }\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate(a) {\n    return this.clone()._rotate(a);\n  }\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround(a, p) {\n    return this.clone()._rotateAround(a, p);\n  }\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult(m) {\n    return this.clone()._matMult(m);\n  }\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit() {\n    return this.clone()._unit();\n  }\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp() {\n    return this.clone()._perp();\n  }\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round() {\n    return this.clone()._round();\n  }\n  /**\n   * Return the magnitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist(p) {\n    return Math.sqrt(this.distSqr(p));\n  }\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr(p) {\n    const dx = p.x - this.x;\n    const dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  }\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle() {\n    return Math.atan2(this.y, this.x);\n  }\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo(b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  }\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith(b) {\n    return this.angleWithSep(b.x, b.y);\n  }\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin() for .\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep(x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  }\n  /**\n   * Construct a point from an array if necessary, otherwise if the input\n   * is already a Point, or an unknown type, return it unchanged\n   * @param {Array<number> | Point} a any kind of input value\n   * @return {Point} constructed point, or passed-through value.\n   * @example\n   * // this\n   * var point = Point.convert([0, 1]);\n   * // is equivalent to\n   * var point = new Point(0, 1);\n   */\n  static convert(a) {\n    if (a instanceof Point) {\n      return a;\n    }\n    if (Array.isArray(a)) {\n      return new Point(a[0], a[1]);\n    }\n    return a;\n  }\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction str2xml(str) {\n  if (typeof DOMParser !== \"undefined\") {\n    const doc = new DOMParser().parseFromString(str, \"application/xml\");\n    if (doc.querySelector(\"parsererror\")) {\n      throw new Error(\"The provided string is not valid XML\");\n    }\n    return doc;\n  } else {\n    throw new Error(\"No XML parser found\");\n  }\n}\nfunction hasChildNodeWithName(doc, nodeName) {\n  if (!doc.hasChildNodes()) {\n    return false;\n  }\n  for (const childNode of Array.from(doc.childNodes)) {\n    const currentNodeName = childNode.nodeName;\n    if (typeof currentNodeName === \"string\" && currentNodeName.trim().toLowerCase() === nodeName.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction xml2str(node) {\n  if (typeof XMLSerializer !== \"undefined\") {\n    return new XMLSerializer().serializeToString(node);\n  }\n  throw new Error(\"No XML serializer found\");\n}\nfunction gpx(doc) {\n  if (typeof doc === \"string\")\n    doc = str2xml(doc);\n  if (!hasChildNodeWithName(doc, \"gpx\")) {\n    throw new Error(\"The XML document is not valid GPX\");\n  }\n  const tracks = get(doc, \"trk\");\n  const routes = get(doc, \"rte\");\n  const waypoints = get(doc, \"wpt\");\n  const gj = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  for (const track of Array.from(tracks)) {\n    const feature = getTrack(track);\n    if (feature)\n      gj.features.push(feature);\n  }\n  for (const route of Array.from(routes)) {\n    const feature = getRoute(route);\n    if (feature)\n      gj.features.push(feature);\n  }\n  for (const waypoint of Array.from(waypoints)) {\n    gj.features.push(getPoint(waypoint));\n  }\n  return gj;\n}\nfunction kml(doc, xml2string) {\n  var _a;\n  if (typeof doc === \"string\")\n    doc = str2xml(doc);\n  if (!hasChildNodeWithName(doc, \"kml\")) {\n    throw new Error(\"The XML document is not valid KML\");\n  }\n  const gj = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  const styleIndex = {};\n  const styleByHash = {};\n  const styleMapIndex = {};\n  const placemarks = get(doc, \"Placemark\");\n  const styles = get(doc, \"Style\");\n  const styleMaps = get(doc, \"StyleMap\");\n  for (const style of Array.from(styles)) {\n    const hash = okhash(\n      xml2string !== void 0 ? xml2string(style) : xml2str(style)\n    ).toString(16);\n    styleIndex[\"#\" + attr(style, \"id\")] = hash;\n    styleByHash[hash] = style;\n  }\n  for (const styleMap of Array.from(styleMaps)) {\n    styleIndex[\"#\" + attr(styleMap, \"id\")] = okhash(\n      xml2string !== void 0 ? xml2string(styleMap) : xml2str(styleMap)\n    ).toString(16);\n    const pairs = get(styleMap, \"Pair\");\n    const pairsMap = {};\n    for (const pair of Array.from(pairs)) {\n      pairsMap[(_a = nodeVal(get1(pair, \"key\"))) != null ? _a : \"\"] = nodeVal(\n        get1(pair, \"styleUrl\")\n      );\n    }\n    styleMapIndex[\"#\" + attr(styleMap, \"id\")] = pairsMap;\n  }\n  for (const placemark of Array.from(placemarks)) {\n    gj.features = gj.features.concat(\n      getPlacemark(placemark, styleIndex, styleByHash, styleMapIndex)\n    );\n  }\n  return gj;\n}\nfunction kmlColor(v) {\n  if (v === null)\n    return [\"#000000\", 1];\n  let color = \"\";\n  let opacity = 1;\n  if (v.substring(0, 1) === \"#\")\n    v = v.substring(1);\n  if (v.length === 6 || v.length === 3)\n    color = v;\n  if (v.length === 8) {\n    opacity = parseInt(v.substring(0, 2), 16) / 255;\n    color = \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return [color != null ? color : \"#000000\", opacity != null ? opacity : 1];\n}\nfunction gxCoord(v) {\n  return numarray(v.split(\" \"));\n}\nfunction gxCoords(root) {\n  var _a;\n  let elems = get(root, \"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0)\n    elems = get(root, \"gx:coord\");\n  for (const elem of Array.from(elems)) {\n    coords.push(gxCoord((_a = nodeVal(elem)) != null ? _a : \"\"));\n  }\n  const timeElems = get(root, \"when\");\n  for (const timeElem of Array.from(timeElems))\n    times.push(nodeVal(timeElem));\n  return {\n    coords,\n    times\n  };\n}\nfunction getGeometry(root) {\n  var _a, _b, _c;\n  const geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  let geomNode, geomNodes, i, j, k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\") !== null) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = get(root, geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1((_a = nodeVal(get1(geomNode, \"coordinates\"))) != null ? _a : \"\")\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord((_b = nodeVal(get1(geomNode, \"coordinates\"))) != null ? _b : \"\")\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = get(geomNode, \"LinearRing\");\n          const coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord((_c = nodeVal(get1(rings[k], \"coordinates\"))) != null ? _c : \"\"));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords\n          });\n          if (track.times.length)\n            coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return { geoms, coordTimes };\n}\nfunction getPlacemark(root, styleIndex, styleByHash, styleMapIndex) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  const geomsAndTimes = getGeometry(root);\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  const visibility = get1(root, \"visibility\");\n  let i;\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  if (!geomsAndTimes.geoms.length)\n    return [];\n  if (name)\n    properties.name = name;\n  if (address)\n    properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\")\n      styleUrl = \"#\" + styleUrl;\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[(_a = styleMapIndex[styleUrl].normal) != null ? _a : \"\"];\n    }\n    const style = styleByHash[(_b = properties.styleHash) != null ? _b : \"\"];\n    if (style) {\n      if (!lineStyle)\n        lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle)\n        polyStyle = get1(style, \"PolyStyle\");\n      const iconStyle = get1(style, \"IconStyle\");\n      if (iconStyle) {\n        const icon = get1(iconStyle, \"Icon\");\n        if (icon) {\n          const href = nodeVal(get1(icon, \"href\"));\n          if (href)\n            properties.icon = href;\n        }\n      }\n    }\n  }\n  if (description)\n    properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    if (begin && end)\n      properties.timespan = { begin, end };\n  }\n  if (timeStamp !== null) {\n    properties.timestamp = (_c = nodeVal(get1(timeStamp, \"when\"))) != null ? _c : (/* @__PURE__ */ new Date()).toISOString();\n  }\n  if (lineStyle !== null) {\n    const linestyles = kmlColor(nodeVal(get1(lineStyle, \"color\")));\n    const color = linestyles[0];\n    const opacity = linestyles[1];\n    const width = parseFloat((_d = nodeVal(get1(lineStyle, \"width\"))) != null ? _d : \"\");\n    if (color)\n      properties.stroke = color;\n    if (!isNaN(opacity))\n      properties[\"stroke-opacity\"] = opacity;\n    if (!isNaN(width))\n      properties[\"stroke-width\"] = width;\n  }\n  if (polyStyle) {\n    const polystyles = kmlColor(nodeVal(get1(polyStyle, \"color\")));\n    const pcolor = polystyles[0];\n    const popacity = polystyles[1];\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (pcolor)\n      properties.fill = pcolor;\n    if (!isNaN(popacity))\n      properties[\"fill-opacity\"] = popacity;\n    if (fill)\n      properties[\"fill-opacity\"] = fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] = outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = get(extendedData, \"Data\"), simpleDatas = get(extendedData, \"SimpleData\");\n    for (i = 0; i < datas.length; i++) {\n      properties[(_e = datas[i].getAttribute(\"name\")) != null ? _e : \"\"] = (_f = nodeVal(get1(datas[i], \"value\"))) != null ? _f : \"\";\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[(_g = simpleDatas[i].getAttribute(\"name\")) != null ? _g : \"\"] = (_h = nodeVal(simpleDatas[i])) != null ? _h : \"\";\n    }\n  }\n  if (visibility !== null) {\n    properties.visibility = (_i = nodeVal(visibility)) != null ? _i : \"\";\n  }\n  if (geomsAndTimes.coordTimes.length !== 0) {\n    properties.coordTimes = geomsAndTimes.coordTimes.length === 1 ? geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry: geomsAndTimes.geoms.length === 1 ? geomsAndTimes.geoms[0] : {\n      type: \"GeometryCollection\",\n      geometries: geomsAndTimes.geoms\n    },\n    properties\n  };\n  if (attr(root, \"id\"))\n    feature.id = (_j = attr(root, \"id\")) != null ? _j : void 0;\n  return [feature];\n}\nfunction getPoints(node, pointname) {\n  const pts = get(node, pointname);\n  const line = [];\n  const times = [];\n  let heartRates = [];\n  const ptsLength = pts.length;\n  if (ptsLength < 2)\n    return;\n  for (let i = 0; i < ptsLength; i++) {\n    const cPair = coordPair(pts[i]);\n    line.push(cPair.coordinates);\n    if (cPair.time)\n      times.push(cPair.time);\n    if (cPair.heartRate || heartRates.length) {\n      if (heartRates.length === 0)\n        heartRates = new Array(i).fill(null);\n      heartRates.push(cPair.heartRate);\n    }\n  }\n  return {\n    line,\n    times,\n    heartRates\n  };\n}\nfunction getTrack(node) {\n  const segments = get(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  let line;\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"trkpt\");\n    if (line !== void 0) {\n      if (line.line)\n        track.push(line.line);\n      if (line.times && line.times.length)\n        times.push(line.times);\n      if (heartRates.length || line.heartRates && line.heartRates.length) {\n        if (!heartRates.length) {\n          for (let s = 0; s < i; s++) {\n            heartRates.push(new Array(track[s].length).fill(null));\n          }\n        }\n        if (line.heartRates && line.heartRates.length) {\n          heartRates.push(line.heartRates);\n        } else {\n          heartRates.push(new Array(line.line.length).fill(null));\n        }\n      }\n    }\n  }\n  if (track.length === 0)\n    return;\n  const properties = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getLineStyle(get1(node, \"extensions\")));\n  if (times.length !== 0)\n    properties.coordTimes = track.length === 1 ? times[0] : times;\n  if (heartRates.length !== 0) {\n    properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n  }\n  if (track.length === 1) {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"LineString\",\n        coordinates: track[0]\n      }\n    };\n  } else {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"MultiLineString\",\n        coordinates: track\n      }\n    };\n  }\n}\nfunction getRoute(node) {\n  const line = getPoints(node, \"rtept\");\n  if (line === void 0)\n    return;\n  const prop = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getLineStyle(get1(node, \"extensions\")));\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line\n    }\n  };\n}\nfunction getPoint(node) {\n  const prop = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getMulti(node, [\"sym\"]));\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates\n    }\n  };\n}\nfunction getLineStyle(extensions) {\n  var _a, _b;\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\"));\n      const opacity = parseFloat((_a = nodeVal(get1(lineStyle, \"opacity\"))) != null ? _a : \"0\");\n      const width = parseFloat((_b = nodeVal(get1(lineStyle, \"width\"))) != null ? _b : \"0\");\n      if (color)\n        style.stroke = color;\n      if (!isNaN(opacity))\n        style[\"stroke-opacity\"] = opacity;\n      if (!isNaN(width))\n        style[\"stroke-width\"] = width * 96 / 25.4;\n    }\n  }\n  return style;\n}\nfunction getProperties(node) {\n  const prop = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\"\n  ]);\n  const links = get(node, \"link\");\n  if (links.length !== 0) {\n    prop.links = [];\n    for (const l of Array.from(links)) {\n      const link = __spreadValues$1({\n        href: attr(l, \"href\")\n      }, getMulti(l, [\"text\", \"type\"]));\n      prop.links.push(link);\n    }\n  }\n  return prop;\n}\nfunction okhash(x) {\n  let h = 0;\n  if (!x || !x.length)\n    return h;\n  for (let i = 0; i < x.length; i++) {\n    h = (h << 5) - h + x.charCodeAt(i) | 0;\n  }\n  return h;\n}\nfunction get(x, y) {\n  return x.getElementsByTagName(y);\n}\nfunction attr(x, y) {\n  return x.getAttribute(y);\n}\nfunction attrf(x, y) {\n  var _a;\n  return parseFloat((_a = attr(x, y)) != null ? _a : \"0\");\n}\nfunction get1(x, y) {\n  const n = get(x, y);\n  return n.length ? n[0] : null;\n}\nfunction norm(el) {\n  if (el.normalize)\n    el.normalize();\n  return el;\n}\nfunction numarray(x) {\n  return x.map(parseFloat).map((n) => isNaN(n) ? null : n);\n}\nfunction nodeVal(x) {\n  if (x)\n    norm(x);\n  return x && x.textContent;\n}\nfunction getMulti(x, ys) {\n  var _a;\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n)\n      o[ys[k]] = (_a = nodeVal(n)) != null ? _a : \"\";\n  }\n  return o;\n}\nfunction coord1(v) {\n  return numarray(v.replace(/\\s*/g, \"\").split(\",\"));\n}\nfunction coord(v) {\n  const coords = v.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/);\n  const out = [];\n  for (const coord2 of coords)\n    out.push(coord1(coord2));\n  return out;\n}\nfunction coordPair(x) {\n  var _a, _b;\n  const ll = [attrf(x, \"lon\"), attrf(x, \"lat\")];\n  const ele = get1(x, \"ele\");\n  const heartRate = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e;\n  if (ele) {\n    e = parseFloat((_a = nodeVal(ele)) != null ? _a : \"0\");\n    if (!isNaN(e))\n      ll.push(e);\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate !== null ? parseFloat((_b = nodeVal(heartRate)) != null ? _b : \"0\") : null\n  };\n}\nfunction gpxOrKml(doc) {\n  try {\n    if (typeof doc === \"string\")\n      doc = str2xml(doc);\n  } catch (e) {\n    return null;\n  }\n  try {\n    const result = gpx(doc);\n    return result;\n  } catch (e) {\n  }\n  try {\n    const result = kml(doc);\n    return result;\n  } catch (e) {\n  }\n  return null;\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction componentToHex(c) {\n  const hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\nfunction rgbToHex(rgb) {\n  return \"#\" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]) + (rgb.length === 4 ? componentToHex(rgb[3]) : \"\");\n}\nclass ColorRamp extends Array {\n  constructor(options = {}) {\n    super();\n    __publicField(this, \"min\", 0);\n    __publicField(this, \"max\", 1);\n    if (\"min\" in options) {\n      this.min = options.min;\n    }\n    if (\"max\" in options) {\n      this.max = options.max;\n    }\n    if (\"stops\" in options) {\n      this.setStops(options.stops, { clone: false });\n    }\n  }\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(cr) {\n    return new ColorRamp({\n      stops: cr.map((cs) => ({\n        value: cs[0],\n        color: cs[1]\n      }))\n    });\n  }\n  setStops(stops, options = { clone: true }) {\n    const colorRamp = options.clone ? this.clone() : this;\n    colorRamp.length = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < stops.length; i += 1) {\n      min = Math.min(min, stops[i].value);\n      max = Math.max(max, stops[i].value);\n      colorRamp.push({\n        value: stops[i].value,\n        color: stops[i].color.slice()\n        // we want to make sure we do a deep copy and not a reference\n      });\n    }\n    colorRamp.sort(\n      (a, b) => a.value < b.value ? -1 : 1\n    );\n    this.min = min;\n    this.max = max;\n    return colorRamp;\n  }\n  scale(min, max, options = { clone: true }) {\n    const clone = options.clone;\n    const currentMin = this[0].value;\n    const currentMax = this.at(-1).value;\n    const currentSpan = currentMax - currentMin;\n    const newSpan = max - min;\n    const stops = [];\n    for (let i = 0; i < this.length; i += 1) {\n      const currentValue = this[i].value;\n      const normalizedValue = (currentValue - currentMin) / currentSpan;\n      const newValue = normalizedValue * newSpan + min;\n      if (clone) {\n        stops.push({\n          value: newValue,\n          color: this[i].color.slice()\n        });\n      } else {\n        this[i].value = newValue;\n      }\n    }\n    return clone ? new ColorRamp({ stops }) : this;\n  }\n  // for some reason, I had to reimplement this\n  at(pos) {\n    if (pos < 0) {\n      return this[this.length + pos];\n    } else {\n      return this[pos];\n    }\n  }\n  clone() {\n    return new ColorRamp({ stops: this.getRawColorStops() });\n  }\n  getRawColorStops() {\n    const stops = [];\n    for (let i = 0; i < this.length; i += 1) {\n      stops.push({ value: this[i].value, color: this[i].color });\n    }\n    return stops;\n  }\n  reverse(options = { clone: true }) {\n    const colorRamp = options.clone ? this.clone() : this;\n    for (let i = 0; i < ~~(colorRamp.length / 2); i += 1) {\n      const c = colorRamp[i].color;\n      colorRamp[i].color = colorRamp.at(-(i + 1)).color;\n      colorRamp.at(-(i + 1)).color = c;\n    }\n    return colorRamp;\n  }\n  getBounds() {\n    return { min: this.min, max: this.max };\n  }\n  getColor(value, options = { smooth: true }) {\n    if (value <= this[0].value) {\n      return this[0].color;\n    }\n    if (value >= this.at(-1).value) {\n      return this.at(-1).color;\n    }\n    for (let i = 0; i < this.length - 1; i += 1) {\n      if (value > this[i + 1].value) {\n        continue;\n      }\n      const colorBefore = this[i].color;\n      if (!options.smooth) {\n        return colorBefore.slice();\n      }\n      const valueBefore = this[i].value;\n      const valueAfter = this[i + 1].value;\n      const colorAfter = this[i + 1].color;\n      const beforeRatio = (valueAfter - value) / (valueAfter - valueBefore);\n      return colorBefore.map(\n        (chan, i2) => Math.round(chan * beforeRatio + colorAfter[i2] * (1 - beforeRatio))\n      );\n    }\n    return [0, 0, 0];\n  }\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(value, options = {\n    smooth: true,\n    withAlpha: false\n  }) {\n    return rgbToHex(this.getColor(value, options));\n  }\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(value, options = { smooth: true }) {\n    const bounds = this.getBounds();\n    return this.getColor(\n      bounds.min + value * (bounds.max - bounds.min),\n      options\n    );\n  }\n  getCanvasStrip(options = {\n    horizontal: true,\n    size: 512,\n    smooth: true\n  }) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = options.horizontal ? options.size : 1;\n    canvas.height = options.horizontal ? 1 : options.size;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx)\n      throw new Error(\"Canvs context is missing\");\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const imageDataArray = imageData.data;\n    const size = options.size;\n    const startValue = this[0].value;\n    const endValue = this.at(-1).value;\n    const valueSpan = endValue - startValue;\n    const valueStep = valueSpan / size;\n    for (let i = 0; i < size; i += 1) {\n      const color = this.getColor(startValue + i * valueStep, {\n        smooth: options.smooth\n      });\n      imageDataArray[i * 4] = color[0];\n      imageDataArray[i * 4 + 1] = color[1];\n      imageDataArray[i * 4 + 2] = color[2];\n      imageDataArray[i * 4 + 3] = color.length > 3 ? color[3] : 255;\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(method, samples = 15) {\n    const inputBounds = this.getBounds();\n    const inputNormalized = this.scale(0, 1);\n    const step = 1 / (samples - 1);\n    let stops;\n    if (method === \"ease-in-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 2);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 2);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(2, -10 * x);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(2, 10 * x - 10);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else {\n      throw new Error(\"Invalid ressampling method.\");\n    }\n    const outputNormalized = new ColorRamp({ stops });\n    const output = outputNormalized.scale(inputBounds.min, inputBounds.max);\n    return output;\n  }\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart() {\n    const stops = this.getRawColorStops();\n    stops.unshift({\n      value: stops[0].value,\n      color: stops[0].color.slice()\n    });\n    stops[1].value += 1e-3;\n    stops.forEach((s) => {\n      if (s.color.length === 3) {\n        s.color.push(255);\n      }\n    });\n    stops[0].color[3] = 0;\n    return new ColorRamp({ stops });\n  }\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart() {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\nconst ColorRampCollection = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0, 0] },\n      { value: 1, color: [0, 0, 0, 0] }\n    ]\n  }),\n  GRAY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 131] },\n      { value: 0.125, color: [0, 60, 170] },\n      { value: 0.375, color: [5, 255, 255] },\n      { value: 0.625, color: [255, 255, 0] },\n      { value: 0.875, color: [250, 0, 0] },\n      { value: 1, color: [128, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 0.169, color: [253, 255, 2] },\n      { value: 0.173, color: [247, 255, 2] },\n      { value: 0.337, color: [0, 252, 4] },\n      { value: 0.341, color: [0, 252, 10] },\n      { value: 0.506, color: [1, 249, 255] },\n      { value: 0.671, color: [2, 0, 253] },\n      { value: 0.675, color: [8, 0, 253] },\n      { value: 0.839, color: [255, 0, 251] },\n      { value: 0.843, color: [255, 0, 245] },\n      { value: 1, color: [255, 0, 6] }\n    ]\n  }),\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.3, color: [230, 0, 0] },\n      { value: 0.6, color: [255, 210, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 255] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 128, 102] },\n      { value: 1, color: [255, 255, 102] }\n    ]\n  }),\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [0, 255, 128] }\n    ]\n  }),\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.376, color: [84, 84, 116] },\n      { value: 0.753, color: [169, 200, 200] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.804, color: [255, 160, 102] },\n      { value: 1, color: [255, 199, 127] }\n    ]\n  }),\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [8, 29, 88] },\n      { value: 0.125, color: [37, 52, 148] },\n      { value: 0.25, color: [34, 94, 168] },\n      { value: 0.375, color: [29, 145, 192] },\n      { value: 0.5, color: [65, 182, 196] },\n      { value: 0.625, color: [127, 205, 187] },\n      { value: 0.75, color: [199, 233, 180] },\n      { value: 0.875, color: [237, 248, 217] },\n      { value: 1, color: [255, 255, 217] }\n    ]\n  }),\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 68, 27] },\n      { value: 0.125, color: [0, 109, 44] },\n      { value: 0.25, color: [35, 139, 69] },\n      { value: 0.375, color: [65, 171, 93] },\n      { value: 0.5, color: [116, 196, 118] },\n      { value: 0.625, color: [161, 217, 155] },\n      { value: 0.75, color: [199, 233, 192] },\n      { value: 0.875, color: [229, 245, 224] },\n      { value: 1, color: [247, 252, 245] }\n    ]\n  }),\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new ColorRamp({\n    stops: [\n      { value: 0, color: [128, 0, 38] },\n      { value: 0.125, color: [189, 0, 38] },\n      { value: 0.25, color: [227, 26, 28] },\n      { value: 0.375, color: [252, 78, 42] },\n      { value: 0.5, color: [253, 141, 60] },\n      { value: 0.625, color: [254, 178, 76] },\n      { value: 0.75, color: [254, 217, 118] },\n      { value: 0.875, color: [255, 237, 160] },\n      { value: 1, color: [255, 255, 204] }\n    ]\n  }),\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [5, 10, 172] },\n      { value: 0.35, color: [106, 137, 247] },\n      { value: 0.5, color: [190, 190, 190] },\n      { value: 0.6, color: [220, 170, 132] },\n      { value: 0.7, color: [230, 145, 90] },\n      { value: 1, color: [178, 10, 28] }\n    ]\n  }),\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 0.1, color: [51, 153, 255] },\n      { value: 0.2, color: [102, 204, 255] },\n      { value: 0.3, color: [153, 204, 255] },\n      { value: 0.4, color: [204, 204, 255] },\n      { value: 0.5, color: [255, 255, 255] },\n      { value: 0.6, color: [255, 204, 255] },\n      { value: 0.7, color: [255, 153, 255] },\n      { value: 0.8, color: [255, 102, 204] },\n      { value: 0.9, color: [255, 102, 102] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new ColorRamp({\n    stops: [\n      { value: 0, color: [150, 0, 90] },\n      { value: 0.125, color: [0, 0, 200] },\n      { value: 0.25, color: [0, 25, 255] },\n      { value: 0.375, color: [0, 152, 255] },\n      { value: 0.5, color: [44, 255, 150] },\n      { value: 0.625, color: [151, 255, 0] },\n      { value: 0.75, color: [255, 234, 0] },\n      { value: 0.875, color: [255, 111, 0] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new ColorRamp({\n    stops: [\n      { value: 0, color: [12, 51, 131] },\n      { value: 0.25, color: [10, 136, 186] },\n      { value: 0.5, color: [242, 211, 56] },\n      { value: 0.75, color: [242, 143, 56] },\n      { value: 1, color: [217, 30, 30] }\n    ]\n  }),\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.2, color: [230, 0, 0] },\n      { value: 0.4, color: [230, 210, 0] },\n      { value: 0.7, color: [255, 255, 255] },\n      { value: 1, color: [160, 200, 255] }\n    ]\n  }),\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 130] },\n      { value: 0.1, color: [0, 180, 180] },\n      { value: 0.2, color: [40, 210, 40] },\n      { value: 0.4, color: [230, 230, 50] },\n      { value: 0.6, color: [120, 70, 20] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.15, color: [30, 0, 100] },\n      { value: 0.4, color: [120, 0, 100] },\n      { value: 0.6, color: [160, 90, 0] },\n      { value: 0.8, color: [230, 200, 0] },\n      { value: 1, color: [255, 250, 220] }\n    ]\n  }),\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [68, 1, 84] },\n      { value: 0.13, color: [71, 44, 122] },\n      { value: 0.25, color: [59, 81, 139] },\n      { value: 0.38, color: [44, 113, 142] },\n      { value: 0.5, color: [33, 144, 141] },\n      { value: 0.63, color: [39, 173, 129] },\n      { value: 0.75, color: [92, 200, 99] },\n      { value: 0.88, color: [170, 220, 50] },\n      { value: 1, color: [253, 231, 37] }\n    ]\n  }),\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [31, 12, 72] },\n      { value: 0.25, color: [85, 15, 109] },\n      { value: 0.38, color: [136, 34, 106] },\n      { value: 0.5, color: [186, 54, 85] },\n      { value: 0.63, color: [227, 89, 51] },\n      { value: 0.75, color: [249, 140, 10] },\n      { value: 0.88, color: [249, 201, 50] },\n      { value: 1, color: [252, 255, 164] }\n    ]\n  }),\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [28, 16, 68] },\n      { value: 0.25, color: [79, 18, 123] },\n      { value: 0.38, color: [129, 37, 129] },\n      { value: 0.5, color: [181, 54, 122] },\n      { value: 0.63, color: [229, 80, 100] },\n      { value: 0.75, color: [251, 135, 97] },\n      { value: 0.88, color: [254, 194, 135] },\n      { value: 1, color: [252, 253, 191] }\n    ]\n  }),\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [13, 8, 135] },\n      { value: 0.13, color: [75, 3, 161] },\n      { value: 0.25, color: [125, 3, 168] },\n      { value: 0.38, color: [168, 34, 150] },\n      { value: 0.5, color: [203, 70, 121] },\n      { value: 0.63, color: [229, 107, 93] },\n      { value: 0.75, color: [248, 148, 65] },\n      { value: 0.88, color: [253, 195, 40] },\n      { value: 1, color: [240, 249, 33] }\n    ]\n  }),\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [172, 0, 187] },\n      { value: 0.25, color: [219, 0, 170] },\n      { value: 0.38, color: [255, 0, 130] },\n      { value: 0.5, color: [255, 63, 74] },\n      { value: 0.63, color: [255, 123, 0] },\n      { value: 0.75, color: [234, 176, 0] },\n      { value: 0.88, color: [190, 228, 0] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [116, 0, 218] },\n      { value: 0.25, color: [98, 74, 237] },\n      { value: 0.38, color: [68, 146, 231] },\n      { value: 0.5, color: [0, 204, 197] },\n      { value: 0.63, color: [0, 247, 146] },\n      { value: 0.75, color: [0, 255, 88] },\n      { value: 0.88, color: [40, 255, 8] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.1, color: [199, 0, 180] },\n      { value: 0.2, color: [255, 0, 121] },\n      { value: 0.3, color: [255, 108, 0] },\n      { value: 0.4, color: [222, 194, 0] },\n      { value: 0.5, color: [150, 255, 0] },\n      { value: 0.6, color: [0, 255, 55] },\n      { value: 0.7, color: [0, 246, 150] },\n      { value: 0.8, color: [50, 167, 222] },\n      { value: 0.9, color: [103, 51, 235] },\n      { value: 1, color: [124, 0, 186] }\n    ]\n  }),\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new ColorRamp({\n    stops: [\n      { value: 0, color: [40, 26, 44] },\n      { value: 0.13, color: [59, 49, 90] },\n      { value: 0.25, color: [64, 76, 139] },\n      { value: 0.38, color: [63, 110, 151] },\n      { value: 0.5, color: [72, 142, 158] },\n      { value: 0.63, color: [85, 174, 163] },\n      { value: 0.75, color: [120, 206, 163] },\n      { value: 0.88, color: [187, 230, 172] },\n      { value: 1, color: [253, 254, 204] }\n    ]\n  }),\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new ColorRamp({\n    stops: [\n      { value: 0, color: [47, 15, 62] },\n      { value: 0.13, color: [87, 23, 86] },\n      { value: 0.25, color: [130, 28, 99] },\n      { value: 0.38, color: [171, 41, 96] },\n      { value: 0.5, color: [206, 67, 86] },\n      { value: 0.63, color: [230, 106, 84] },\n      { value: 0.75, color: [242, 149, 103] },\n      { value: 0.88, color: [249, 193, 135] },\n      { value: 1, color: [254, 237, 176] }\n    ]\n  }),\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new ColorRamp({\n    stops: [\n      { value: 0, color: [18, 36, 20] },\n      { value: 0.13, color: [25, 63, 41] },\n      { value: 0.25, color: [24, 91, 59] },\n      { value: 0.38, color: [13, 119, 72] },\n      { value: 0.5, color: [18, 148, 80] },\n      { value: 0.63, color: [80, 173, 89] },\n      { value: 0.75, color: [132, 196, 122] },\n      { value: 0.88, color: [175, 221, 162] },\n      { value: 1, color: [215, 249, 208] }\n    ]\n  }),\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [54, 14, 36] },\n      { value: 0.13, color: [89, 23, 80] },\n      { value: 0.25, color: [110, 45, 132] },\n      { value: 0.38, color: [120, 77, 178] },\n      { value: 0.5, color: [120, 113, 213] },\n      { value: 0.63, color: [115, 151, 228] },\n      { value: 0.75, color: [134, 185, 227] },\n      { value: 0.88, color: [177, 214, 227] },\n      { value: 1, color: [230, 241, 241] }\n    ]\n  }),\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [30, 4, 110] },\n      { value: 0.13, color: [47, 14, 176] },\n      { value: 0.25, color: [41, 45, 236] },\n      { value: 0.38, color: [25, 99, 212] },\n      { value: 0.5, color: [68, 131, 200] },\n      { value: 0.63, color: [114, 156, 197] },\n      { value: 0.75, color: [157, 181, 203] },\n      { value: 0.88, color: [200, 208, 216] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new ColorRamp({\n    stops: [\n      { value: 0, color: [60, 9, 18] },\n      { value: 0.13, color: [100, 17, 27] },\n      { value: 0.25, color: [142, 20, 29] },\n      { value: 0.38, color: [177, 43, 27] },\n      { value: 0.5, color: [192, 87, 63] },\n      { value: 0.63, color: [205, 125, 105] },\n      { value: 0.75, color: [216, 162, 148] },\n      { value: 0.88, color: [227, 199, 193] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [64, 5, 5] },\n      { value: 0.13, color: [106, 6, 15] },\n      { value: 0.25, color: [144, 26, 7] },\n      { value: 0.38, color: [168, 64, 3] },\n      { value: 0.5, color: [188, 100, 4] },\n      { value: 0.63, color: [206, 136, 11] },\n      { value: 0.75, color: [220, 174, 25] },\n      { value: 0.88, color: [231, 215, 44] },\n      { value: 1, color: [248, 254, 105] }\n    ]\n  }),\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new ColorRamp({\n    stops: [\n      { value: 0, color: [51, 20, 24] },\n      { value: 0.13, color: [90, 32, 35] },\n      { value: 0.25, color: [129, 44, 34] },\n      { value: 0.38, color: [159, 68, 25] },\n      { value: 0.5, color: [182, 99, 19] },\n      { value: 0.63, color: [199, 134, 22] },\n      { value: 0.75, color: [212, 171, 35] },\n      { value: 0.88, color: [221, 210, 54] },\n      { value: 1, color: [225, 253, 75] }\n    ]\n  }),\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new ColorRamp({\n    stops: [\n      { value: 0, color: [145, 105, 18] },\n      { value: 0.13, color: [184, 71, 38] },\n      { value: 0.25, color: [186, 58, 115] },\n      { value: 0.38, color: [160, 71, 185] },\n      { value: 0.5, color: [110, 97, 218] },\n      { value: 0.63, color: [50, 123, 164] },\n      { value: 0.75, color: [31, 131, 110] },\n      { value: 0.88, color: [77, 129, 34] },\n      { value: 1, color: [145, 105, 18] }\n    ]\n  }),\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [42, 24, 108] },\n      { value: 0.13, color: [33, 50, 162] },\n      { value: 0.25, color: [15, 90, 145] },\n      { value: 0.38, color: [40, 118, 137] },\n      { value: 0.5, color: [59, 146, 135] },\n      { value: 0.63, color: [79, 175, 126] },\n      { value: 0.75, color: [120, 203, 104] },\n      { value: 0.88, color: [193, 221, 100] },\n      { value: 1, color: [253, 239, 154] }\n    ]\n  }),\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new ColorRamp({\n    stops: [\n      { value: 0, color: [4, 35, 51] },\n      { value: 0.13, color: [23, 51, 122] },\n      { value: 0.25, color: [85, 59, 157] },\n      { value: 0.38, color: [129, 79, 143] },\n      { value: 0.5, color: [175, 95, 130] },\n      { value: 0.63, color: [222, 112, 101] },\n      { value: 0.75, color: [249, 146, 66] },\n      { value: 0.88, color: [249, 196, 65] },\n      { value: 1, color: [232, 250, 91] }\n    ]\n  }),\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [34, 31, 27] },\n      { value: 0.13, color: [65, 50, 41] },\n      { value: 0.25, color: [98, 69, 52] },\n      { value: 0.38, color: [131, 89, 57] },\n      { value: 0.5, color: [161, 112, 59] },\n      { value: 0.63, color: [185, 140, 66] },\n      { value: 0.75, color: [202, 174, 88] },\n      { value: 0.88, color: [216, 209, 126] },\n      { value: 1, color: [233, 246, 171] }\n    ]\n  }),\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [17, 32, 64] },\n      { value: 0.13, color: [35, 52, 116] },\n      { value: 0.25, color: [29, 81, 156] },\n      { value: 0.38, color: [31, 113, 162] },\n      { value: 0.5, color: [50, 144, 169] },\n      { value: 0.63, color: [87, 173, 176] },\n      { value: 0.75, color: [149, 196, 189] },\n      { value: 0.88, color: [203, 221, 211] },\n      { value: 1, color: [254, 251, 230] }\n    ]\n  }),\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [23, 35, 19] },\n      { value: 0.13, color: [24, 64, 38] },\n      { value: 0.25, color: [11, 95, 45] },\n      { value: 0.38, color: [39, 123, 35] },\n      { value: 0.5, color: [95, 146, 12] },\n      { value: 0.63, color: [152, 165, 18] },\n      { value: 0.75, color: [201, 186, 69] },\n      { value: 0.88, color: [233, 216, 137] },\n      { value: 1, color: [255, 253, 205] }\n    ]\n  }),\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.07, color: [22, 5, 59] },\n      { value: 0.13, color: [60, 4, 105] },\n      { value: 0.2, color: [109, 1, 135] },\n      { value: 0.27, color: [161, 0, 147] },\n      { value: 0.33, color: [210, 2, 142] },\n      { value: 0.4, color: [251, 11, 123] },\n      { value: 0.47, color: [255, 29, 97] },\n      { value: 0.53, color: [255, 54, 69] },\n      { value: 0.6, color: [255, 85, 46] },\n      { value: 0.67, color: [255, 120, 34] },\n      { value: 0.73, color: [255, 157, 37] },\n      { value: 0.8, color: [241, 191, 57] },\n      { value: 0.87, color: [224, 220, 93] },\n      { value: 0.93, color: [218, 241, 142] },\n      { value: 1, color: [227, 253, 198] }\n    ]\n  }),\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 32, 77, 255] },\n      { value: 0.125, color: [5, 54, 110, 255] },\n      { value: 0.25, color: [65, 77, 108, 255] },\n      { value: 0.375, color: [97, 100, 111, 255] },\n      { value: 0.5, color: [125, 124, 121, 255] },\n      { value: 0.625, color: [156, 149, 120, 255] },\n      { value: 0.75, color: [190, 175, 111, 255] },\n      { value: 0.875, color: [225, 204, 94, 255] },\n      { value: 1, color: [255, 235, 70, 255] }\n    ]\n  }),\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new ColorRamp({\n    stops: [\n      { value: 0, color: [48, 18, 59, 255] },\n      { value: 0.125, color: [70, 107, 227, 255] },\n      { value: 0.25, color: [40, 187, 236, 255] },\n      { value: 0.375, color: [49, 242, 153, 255] },\n      { value: 0.5, color: [162, 252, 60, 255] },\n      { value: 0.625, color: [237, 208, 58, 255] },\n      { value: 0.75, color: [251, 128, 34, 255] },\n      { value: 0.875, color: [210, 49, 5, 255] },\n      { value: 1, color: [122, 4, 3, 255] }\n    ]\n  }),\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new ColorRamp({\n    stops: [\n      { value: 0, color: [250, 235, 221, 0] },\n      { value: 0.133, color: [250, 235, 221, 255] },\n      { value: 0.266, color: [246, 170, 130, 255] },\n      { value: 0.4, color: [240, 96, 67, 255] },\n      { value: 0.533, color: [203, 27, 79, 255] },\n      { value: 0.666, color: [132, 30, 90, 255] },\n      { value: 0.8, color: [63, 27, 68, 255] },\n      { value: 1, color: [3, 5, 26, 255] }\n    ]\n  }),\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new ColorRamp({\n    stops: [\n      { value: 0, color: [11, 4, 5, 255] },\n      { value: 0.125, color: [43, 28, 53, 255] },\n      { value: 0.25, color: [62, 53, 107, 255] },\n      { value: 0.375, color: [59, 86, 152, 255] },\n      { value: 0.5, color: [53, 123, 162, 255] },\n      { value: 0.625, color: [53, 158, 170, 255] },\n      { value: 0.75, color: [73, 193, 173, 255] },\n      { value: 0.875, color: [150, 221, 181, 255] },\n      { value: 1, color: [222, 245, 229, 255] }\n    ]\n  })\n};\n\nconst colorPalettes = [\n  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n  [\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n  [\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n  [\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n  [\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n  [\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n  [\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n  [\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n  [\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n  [\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"]\n];\nfunction getRandomColor() {\n  return colorPalettes[~~(Math.random() * colorPalettes.length)][~~(Math.random() * 4)];\n}\nfunction generateRandomSourceName() {\n  return `maptiler_source_${generateRandomString()}`;\n}\nfunction generateRandomLayerName() {\n  return `maptiler_layer_${generateRandomString()}`;\n}\nfunction lerpZoomNumberValues(znv, z) {\n  if (z <= znv[0].zoom) {\n    return znv[0].value;\n  }\n  if (z >= znv[znv.length - 1].zoom) {\n    return znv[znv.length - 1].value;\n  }\n  for (let i = 0; i < znv.length - 1; i += 1) {\n    if (z >= znv[i].zoom && z < znv[i + 1].zoom) {\n      const zoomRange = znv[i + 1].zoom - znv[i].zoom;\n      const normalizedDistanceFromLowerBound = (z - znv[i].zoom) / zoomRange;\n      return normalizedDistanceFromLowerBound * znv[i + 1].value + (1 - normalizedDistanceFromLowerBound) * znv[i].value;\n    }\n  }\n  return 0;\n}\nfunction paintColorOptionsToPaintSpec(color) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    ...color.map((el) => [el.zoom, el.value]).flat()\n  ];\n}\nfunction rampedOptionsToLayerPaintSpec(ramp) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    ...ramp.map((el) => [el.zoom, el.value]).flat()\n  ];\n}\nfunction computeRampedOutlineWidth(lineWidth, outlineWidth) {\n  if (typeof outlineWidth === \"number\" && typeof lineWidth === \"number\") {\n    return 2 * outlineWidth + lineWidth;\n  } else if (typeof outlineWidth === \"number\" && Array.isArray(lineWidth)) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...lineWidth.map((el) => [el.zoom, 2 * outlineWidth + el.value]).flat()\n    ];\n  } else if (typeof lineWidth === \"number\" && Array.isArray(outlineWidth)) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...outlineWidth.map((el) => [el.zoom, 2 * el.value + lineWidth]).flat()\n    ];\n  }\n  if (Array.isArray(lineWidth) && Array.isArray(outlineWidth)) {\n    const allStops = Array.from(\n      /* @__PURE__ */ new Set([\n        ...lineWidth.map((el) => el.zoom),\n        ...outlineWidth.map((el) => el.zoom)\n      ])\n    ).sort((a, b) => a < b ? -1 : 1);\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...allStops.map((z) => [\n        z,\n        2 * lerpZoomNumberValues(outlineWidth, z) + lerpZoomNumberValues(lineWidth, z)\n      ]).flat()\n    ];\n  }\n  return 0;\n}\nfunction rampedPropertyValueWeight(ramp, property) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...ramp.map((el) => [el.propertyValue, el.value]).flat()\n  ];\n}\nfunction dashArrayMaker(pattern) {\n  const startTrimmedPattern = pattern.trimStart();\n  const fixedPattern = `${startTrimmedPattern}${\" \".repeat(\n    pattern.length - startTrimmedPattern.length\n  )}`;\n  const patternArr = Array.from(fixedPattern);\n  const isOnlyDashesAndSpaces = patternArr.every((c) => c === \" \" || c === \"_\");\n  if (!isOnlyDashesAndSpaces) {\n    throw new Error(\n      \"A dash pattern must be composed only of whitespace and underscore characters.\"\n    );\n  }\n  const hasBothDashesAndWhitespaces = patternArr.some((c) => c === \"_\") && patternArr.some((c) => c === \" \");\n  if (!hasBothDashesAndWhitespaces) {\n    throw new Error(\n      \"A dash pattern must contain at least one underscore and one whitespace character\"\n    );\n  }\n  const dashArray = [1];\n  for (let i = 1; i < patternArr.length; i += 1) {\n    const previous = patternArr[i - 1];\n    const current = patternArr[i];\n    if (previous === current) {\n      dashArray[dashArray.length - 1] += 1;\n    } else {\n      dashArray.push(1);\n    }\n  }\n  return dashArray;\n}\nfunction colorDrivenByProperty(style, property) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...style.map((el) => [el.value, el.color]).flat()\n  ];\n}\nfunction radiusDrivenByProperty(style, property, zoomCompensation = true) {\n  if (!zoomCompensation) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius]).flat()\n    ];\n  }\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.025]).flat()\n    ],\n    2,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.05]).flat()\n    ],\n    4,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.1]).flat()\n    ],\n    8,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.25]).flat()\n    ],\n    16,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius]).flat()\n    ]\n  ];\n}\nfunction radiusDrivenByPropertyHeatmap(style, property, zoomCompensation = true) {\n  if (!zoomCompensation) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value]).flat()\n    ];\n  }\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.025]).flat()\n    ],\n    2,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.05]).flat()\n    ],\n    4,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.1]).flat()\n    ],\n    8,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.25]).flat()\n    ],\n    16,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value]).flat()\n    ]\n  ];\n}\nfunction opacityDrivenByProperty(colorramp, property) {\n  if (colorramp.every((el) => el.color[3] === colorramp[0].color[3])) {\n    return colorramp[0].color[3] ? colorramp[0].color[3] / 255 : 1;\n  }\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...colorramp.getRawColorStops().map((el) => {\n      const value = el.value;\n      const color = el.color;\n      return [value, color.length === 4 ? color[3] / 255 : 1];\n    }).flat()\n  ];\n}\nfunction heatmapIntensityFromColorRamp(colorRamp, steps = 10) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"heatmap-density\"],\n    ...Array.from({ length: steps + 1 }, (_, i) => {\n      const unitStep = i / steps;\n      return [unitStep, colorRamp.getColorHex(unitStep)];\n    }).flat()\n  ];\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction addPolyline(_0, _1) {\n  return __async(this, arguments, function* (map, options, fetchOptions = {}) {\n    var _a, _b, _c;\n    if (!options.sourceId && !options.data) {\n      throw new Error(\n        \"Creating a polyline layer requires an existing .sourceId or a valid .data property\"\n      );\n    }\n    let data = options.data;\n    if (typeof data === \"string\") {\n      if (isUUID(data)) {\n        data = `https://api.maptiler.com/data/${options.data}/features.json?key=${config.apiKey}`;\n      } else if (((_a = data.split(\".\").pop()) == null ? void 0 : _a.toLowerCase().trim()) === \"gpx\") {\n        const res = yield fetch(data, fetchOptions);\n        const gpxStr = yield res.text();\n        data = gpx(gpxStr);\n      } else if (((_b = data.split(\".\").pop()) == null ? void 0 : _b.toLowerCase().trim()) === \"kml\") {\n        const res = yield fetch(data, fetchOptions);\n        const kmlStr = yield res.text();\n        data = kml(kmlStr);\n      } else {\n        const tmpData = (_c = jsonParseNoThrow(\n          data\n        )) != null ? _c : gpxOrKml(data);\n        if (tmpData)\n          data = tmpData;\n      }\n      if (!data) {\n        throw new Error(\n          \"Polyline data was provided as string but is incompatible with valid formats.\"\n        );\n      }\n    }\n    return addGeoJSONPolyline(map, __spreadProps(__spreadValues({}, options), {\n      data\n    }));\n  });\n}\nfunction addGeoJSONPolyline(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const returnedInfo = {\n    polylineLayerId: layerId,\n    polylineOutlineLayerId: \"\",\n    polylineSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: options.data\n    });\n  }\n  const lineWidth = (_c = options.lineWidth) != null ? _c : 3;\n  const lineColor = (_d = options.lineColor) != null ? _d : getRandomColor();\n  const lineOpacity = (_e = options.lineOpacity) != null ? _e : 1;\n  const lineBlur = (_f = options.lineBlur) != null ? _f : 0;\n  const lineGapWidth = (_g = options.lineGapWidth) != null ? _g : 0;\n  let lineDashArray = (_h = options.lineDashArray) != null ? _h : null;\n  const outlineWidth = (_i = options.outlineWidth) != null ? _i : 1;\n  const outlineColor = (_j = options.outlineColor) != null ? _j : \"#FFFFFF\";\n  const outlineOpacity = (_k = options.outlineOpacity) != null ? _k : 1;\n  const outlineBlur = (_l = options.outlineBlur) != null ? _l : 0;\n  if (typeof lineDashArray === \"string\") {\n    lineDashArray = dashArrayMaker(lineDashArray);\n  }\n  if (options.outline === true) {\n    const outlineLayerId = `${layerId}_outline`;\n    returnedInfo.polylineOutlineLayerId = outlineLayerId;\n    map.addLayer(\n      {\n        id: outlineLayerId,\n        type: \"line\",\n        source: sourceId,\n        layout: {\n          \"line-join\": (_m = options.lineJoin) != null ? _m : \"round\",\n          \"line-cap\": (_n = options.lineCap) != null ? _n : \"round\"\n        },\n        minzoom: (_o = options.minzoom) != null ? _o : 0,\n        maxzoom: (_p = options.maxzoom) != null ? _p : 23,\n        paint: {\n          \"line-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n          \"line-width\": computeRampedOutlineWidth(lineWidth, outlineWidth),\n          \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur)\n        }\n      },\n      options.beforeId\n    );\n  }\n  map.addLayer(\n    {\n      id: layerId,\n      type: \"line\",\n      source: sourceId,\n      layout: {\n        \"line-join\": (_q = options.lineJoin) != null ? _q : \"round\",\n        \"line-cap\": (_r = options.lineCap) != null ? _r : \"round\"\n      },\n      minzoom: (_s = options.minzoom) != null ? _s : 0,\n      maxzoom: (_t = options.maxzoom) != null ? _t : 23,\n      paint: __spreadValues({\n        \"line-opacity\": typeof lineOpacity === \"number\" ? lineOpacity : rampedOptionsToLayerPaintSpec(lineOpacity),\n        \"line-color\": typeof lineColor === \"string\" ? lineColor : paintColorOptionsToPaintSpec(lineColor),\n        \"line-width\": typeof lineWidth === \"number\" ? lineWidth : rampedOptionsToLayerPaintSpec(lineWidth),\n        \"line-blur\": typeof lineBlur === \"number\" ? lineBlur : rampedOptionsToLayerPaintSpec(lineBlur),\n        \"line-gap-width\": typeof lineGapWidth === \"number\" ? lineGapWidth : rampedOptionsToLayerPaintSpec(lineGapWidth)\n      }, lineDashArray && { \"line-dasharray\": lineDashArray })\n    },\n    options.beforeId\n  );\n  return returnedInfo;\n}\nfunction addPolygon(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const returnedInfo = {\n    polygonLayerId: layerId,\n    polygonOutlineLayerId: options.outline ? `${layerId}_outline` : \"\",\n    polygonSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data\n    });\n  }\n  let outlineDashArray = (_c = options.outlineDashArray) != null ? _c : null;\n  const outlineWidth = (_d = options.outlineWidth) != null ? _d : 1;\n  const outlineColor = (_e = options.outlineColor) != null ? _e : \"#FFFFFF\";\n  const outlineOpacity = (_f = options.outlineOpacity) != null ? _f : 1;\n  const outlineBlur = (_g = options.outlineBlur) != null ? _g : 0;\n  const fillColor = (_h = options.fillColor) != null ? _h : getRandomColor();\n  const fillOpacity = (_i = options.fillOpacity) != null ? _i : 1;\n  const outlinePosition = (_j = options.outlinePosition) != null ? _j : \"center\";\n  const pattern = (_k = options.pattern) != null ? _k : null;\n  if (typeof outlineDashArray === \"string\") {\n    outlineDashArray = dashArrayMaker(outlineDashArray);\n  }\n  const addLayers = (patternImageId = null) => {\n    var _a2, _b2, _c2, _d2, _e2, _f2;\n    map.addLayer(\n      {\n        id: layerId,\n        type: \"fill\",\n        source: sourceId,\n        minzoom: (_a2 = options.minzoom) != null ? _a2 : 0,\n        maxzoom: (_b2 = options.maxzoom) != null ? _b2 : 23,\n        paint: __spreadValues({\n          \"fill-color\": typeof fillColor === \"string\" ? fillColor : paintColorOptionsToPaintSpec(fillColor),\n          \"fill-opacity\": typeof fillOpacity === \"number\" ? fillOpacity : rampedOptionsToLayerPaintSpec(fillOpacity)\n        }, patternImageId && { \"fill-pattern\": patternImageId })\n      },\n      options.beforeId\n    );\n    if (options.outline === true) {\n      let computedOutlineOffset;\n      if (outlinePosition === \"inside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = 0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map(({ zoom, value }) => ({\n              zoom,\n              value: 0.5 * value\n            }))\n          );\n        }\n      } else if (outlinePosition === \"outside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = -0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map((el) => ({\n              zoom: el.zoom,\n              value: -0.5 * el.value\n            }))\n          );\n        }\n      } else {\n        computedOutlineOffset = 0;\n      }\n      map.addLayer(\n        {\n          id: returnedInfo.polygonOutlineLayerId,\n          type: \"line\",\n          source: sourceId,\n          layout: {\n            \"line-join\": (_c2 = options.outlineJoin) != null ? _c2 : \"round\",\n            \"line-cap\": (_d2 = options.outlineCap) != null ? _d2 : \"butt\"\n          },\n          minzoom: (_e2 = options.minzoom) != null ? _e2 : 0,\n          maxzoom: (_f2 = options.maxzoom) != null ? _f2 : 23,\n          paint: __spreadValues({\n            \"line-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n            \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n            \"line-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n            \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur),\n            \"line-offset\": computedOutlineOffset\n          }, outlineDashArray && {\n            \"line-dasharray\": outlineDashArray\n          })\n        },\n        options.beforeId\n      );\n    }\n  };\n  if (pattern) {\n    if (map.hasImage(pattern)) {\n      addLayers(pattern);\n    } else {\n      map.loadImage(\n        pattern,\n        // (error?: Error | null, image?: HTMLImageElement | ImageBitmap | null, expiry?: ExpiryData | null)\n        (error, image) => {\n          if (error) {\n            console.error(\"Could not load the pattern image.\", error.message);\n            return addLayers();\n          }\n          if (!image) {\n            console.error(\n              `An image cannot be created from the pattern URL ${pattern}.`\n            );\n            return addLayers();\n          }\n          map.addImage(pattern, image);\n          addLayers(pattern);\n        }\n      );\n    }\n  } else {\n    addLayers();\n  }\n  return returnedInfo;\n}\nfunction addPoint(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const minPointRadius = (_a = options.minPointRadius) != null ? _a : 10;\n  const maxPointRadius = (_b = options.maxPointRadius) != null ? _b : 50;\n  const cluster = (_c = options.cluster) != null ? _c : false;\n  const nbDefaultDataDrivenStyleSteps = 20;\n  const colorramp = Array.isArray(options.pointColor) ? options.pointColor : ColorRampCollection.TURBO.scale(\n    10,\n    options.cluster ? 1e4 : 1e3\n  ).resample(\"ease-out-square\");\n  const colorRampBounds = colorramp.getBounds();\n  const sourceId = (_d = options.sourceId) != null ? _d : generateRandomSourceName();\n  const layerId = (_e = options.layerId) != null ? _e : generateRandomLayerName();\n  const showLabel = (_f = options.showLabel) != null ? _f : cluster;\n  const alignOnViewport = (_g = options.alignOnViewport) != null ? _g : true;\n  const outline = (_h = options.outline) != null ? _h : false;\n  const outlineOpacity = (_i = options.outlineOpacity) != null ? _i : 1;\n  const outlineWidth = (_j = options.outlineWidth) != null ? _j : 1;\n  const outlineColor = (_k = options.outlineColor) != null ? _k : \"#FFFFFF\";\n  let pointOpacity;\n  const zoomCompensation = (_l = options.zoomCompensation) != null ? _l : true;\n  const minzoom = (_m = options.minzoom) != null ? _m : 0;\n  const maxzoom = (_n = options.maxzoom) != null ? _n : 23;\n  if (typeof options.pointOpacity === \"number\") {\n    pointOpacity = options.pointOpacity;\n  } else if (Array.isArray(options.pointOpacity)) {\n    pointOpacity = rampedOptionsToLayerPaintSpec(options.pointOpacity);\n  } else if (options.cluster) {\n    pointOpacity = opacityDrivenByProperty(colorramp, \"point_count\");\n  } else if (options.property) {\n    pointOpacity = opacityDrivenByProperty(colorramp, options.property);\n  } else {\n    pointOpacity = rampedOptionsToLayerPaintSpec([\n      { zoom: minzoom, value: 0 },\n      { zoom: minzoom + 0.25, value: 1 },\n      { zoom: maxzoom - 0.25, value: 1 },\n      { zoom: maxzoom, value: 0 }\n    ]);\n  }\n  const returnedInfo = {\n    pointLayerId: layerId,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data,\n      cluster\n    });\n  }\n  if (cluster) {\n    returnedInfo.clusterLayerId = `${layerId}_cluster`;\n    const clusterStyle = Array.from(\n      { length: nbDefaultDataDrivenStyleSteps },\n      (_, i) => {\n        const value = colorRampBounds.min + i * (colorRampBounds.max - colorRampBounds.min) / (nbDefaultDataDrivenStyleSteps - 1);\n        return {\n          value,\n          pointRadius: minPointRadius + (maxPointRadius - minPointRadius) * Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n          color: colorramp.getColorHex(value)\n        };\n      }\n    );\n    map.addLayer(\n      {\n        id: returnedInfo.clusterLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"has\", \"point_count\"],\n        paint: __spreadValues({\n          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-color\": typeof options.pointColor === \"string\" ? options.pointColor : colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-radius\": typeof options.pointRadius === \"number\" ? options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : radiusDrivenByProperty(clusterStyle, \"point_count\", false),\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-opacity\": pointOpacity\n        }, outline && {\n          \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n          \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n        }),\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"!\", [\"has\", \"point_count\"]],\n        paint: __spreadValues({\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n          \"circle-color\": typeof options.pointColor === \"string\" ? options.pointColor : colorramp.getColorHex(colorramp.getBounds().min),\n          \"circle-radius\": typeof options.pointRadius === \"number\" ? options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : clusterStyle[0].pointRadius * 0.75,\n          \"circle-opacity\": pointOpacity\n        }, outline && {\n          \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n          \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n        }),\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n  } else {\n    let pointColor = typeof options.pointColor === \"string\" ? options.pointColor : Array.isArray(options.pointColor) ? options.pointColor.getColorHex(options.pointColor.getBounds().min) : getRandomColor();\n    let pointRadius = typeof options.pointRadius === \"number\" ? zoomCompensation ? rampedOptionsToLayerPaintSpec([\n      { zoom: 0, value: options.pointRadius * 0.025 },\n      { zoom: 2, value: options.pointRadius * 0.05 },\n      { zoom: 4, value: options.pointRadius * 0.1 },\n      { zoom: 8, value: options.pointRadius * 0.25 },\n      { zoom: 16, value: options.pointRadius * 1 }\n    ]) : options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : zoomCompensation ? rampedOptionsToLayerPaintSpec([\n      { zoom: 0, value: minPointRadius * 0.05 },\n      { zoom: 2, value: minPointRadius * 0.1 },\n      { zoom: 4, value: minPointRadius * 0.2 },\n      { zoom: 8, value: minPointRadius * 0.5 },\n      { zoom: 16, value: minPointRadius * 1 }\n    ]) : minPointRadius;\n    if (options.property && Array.isArray(options.pointColor)) {\n      const dataDrivenStyle = Array.from(\n        { length: nbDefaultDataDrivenStyleSteps },\n        (_, i) => {\n          const value = colorRampBounds.min + i * (colorRampBounds.max - colorRampBounds.min) / (nbDefaultDataDrivenStyleSteps - 1);\n          return {\n            value,\n            pointRadius: typeof options.pointRadius === \"number\" ? options.pointRadius : minPointRadius + (maxPointRadius - minPointRadius) * Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n            color: typeof options.pointColor === \"string\" ? options.pointColor : colorramp.getColorHex(value)\n          };\n        }\n      );\n      pointColor = colorDrivenByProperty(dataDrivenStyle, options.property);\n      pointRadius = radiusDrivenByProperty(\n        dataDrivenStyle,\n        options.property,\n        zoomCompensation\n      );\n    }\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        layout: {\n          // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n          \"circle-sort-key\": options.property ? [\"/\", 1, [\"get\", options.property]] : 0\n        },\n        paint: __spreadValues({\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-color\": pointColor,\n          \"circle-opacity\": pointOpacity,\n          \"circle-radius\": pointRadius\n        }, outline && {\n          \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n          \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n        }),\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n  }\n  if (showLabel !== false && (options.cluster || options.property)) {\n    returnedInfo.labelLayerId = `${layerId}_label`;\n    const labelColor = (_o = options.labelColor) != null ? _o : \"#fff\";\n    const labelSize = (_p = options.labelSize) != null ? _p : 12;\n    map.addLayer(\n      {\n        id: returnedInfo.labelLayerId,\n        type: \"symbol\",\n        source: sourceId,\n        filter: [\n          \"has\",\n          options.cluster ? \"point_count\" : options.property\n        ],\n        layout: {\n          \"text-field\": options.cluster ? \"{point_count_abbreviated}\" : `{${options.property}}`,\n          \"text-font\": [\"Noto Sans Regular\"],\n          \"text-size\": labelSize,\n          \"text-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"symbol-sort-key\": [\n            \"/\",\n            1,\n            [\n              \"get\",\n              options.cluster ? \"point_count\" : options.property\n            ]\n          ]\n          // so that the largest value goes on top\n        },\n        paint: {\n          \"text-color\": labelColor,\n          \"text-opacity\": pointOpacity\n        },\n        minzoom,\n        maxzoom\n      },\n      options.beforeId\n    );\n  }\n  return returnedInfo;\n}\nfunction addHeatmap(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`\n    );\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const minzoom = (_c = options.minzoom) != null ? _c : 0;\n  const maxzoom = (_d = options.maxzoom) != null ? _d : 23;\n  const zoomCompensation = (_e = options.zoomCompensation) != null ? _e : true;\n  const opacity = (_f = options.opacity) != null ? _f : [\n    { zoom: minzoom, value: 0 },\n    { zoom: minzoom + 0.25, value: 1 },\n    { zoom: maxzoom - 0.25, value: 1 },\n    { zoom: maxzoom, value: 0 }\n  ];\n  let colorRamp = Array.isArray(options.colorRamp) ? options.colorRamp : ColorRampCollection.TURBO.transparentStart();\n  const crBounds = colorRamp.getBounds();\n  if (crBounds.min !== 0 || crBounds.max !== 1) {\n    colorRamp = colorRamp.scale(0, 1);\n  }\n  if (!colorRamp.hasTransparentStart()) {\n    colorRamp = colorRamp.transparentStart();\n  }\n  const intensity = (_g = options.intensity) != null ? _g : [\n    { zoom: 0, value: 0.01 },\n    { zoom: 4, value: 0.2 },\n    { zoom: 16, value: 1 }\n  ];\n  const property = (_h = options.property) != null ? _h : null;\n  const propertyValueWeight = (_i = options.weight) != null ? _i : 1;\n  let heatmapWeight = 1;\n  if (property) {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n      if (typeof options.weight === \"number\") {\n        console.warn(\n          \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\"\n        );\n      }\n    } else if (Array.isArray(propertyValueWeight)) {\n      heatmapWeight = rampedPropertyValueWeight(propertyValueWeight, property);\n    } else {\n      console.warn(\n        \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\"\n      );\n    }\n  } else {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n    } else if (Array.isArray(propertyValueWeight)) {\n      console.warn(\n        \"The options `.propertyValueWeights` can only be used when `.property` is provided.\"\n      );\n    }\n  }\n  const defaultRadiusZoomRamping = [\n    { zoom: 0, value: 50 * 0.025 },\n    { zoom: 2, value: 50 * 0.05 },\n    { zoom: 4, value: 50 * 0.1 },\n    { zoom: 8, value: 50 * 0.25 },\n    { zoom: 16, value: 50 }\n  ];\n  const radius = (_j = options.radius) != null ? _j : zoomCompensation ? defaultRadiusZoomRamping : 10;\n  let radiusHeatmap = 1;\n  if (typeof radius === \"number\") {\n    radiusHeatmap = radius;\n  } else if (Array.isArray(radius) && \"zoom\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(radius);\n  } else if (property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = radiusDrivenByPropertyHeatmap(\n      radius,\n      property,\n      zoomCompensation\n    );\n  } else if (!property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(\n      defaultRadiusZoomRamping\n    );\n    console.warn(\n      \"The option `.radius` can only be property-driven if the option `.property` is provided.\"\n    );\n  } else {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(\n      defaultRadiusZoomRamping\n    );\n  }\n  const returnedInfo = {\n    heatmapLayerId: layerId,\n    heatmapSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data\n    });\n  }\n  map.addLayer({\n    id: layerId,\n    type: \"heatmap\",\n    source: sourceId,\n    minzoom,\n    maxzoom,\n    paint: {\n      \"heatmap-weight\": heatmapWeight,\n      \"heatmap-intensity\": typeof intensity === \"number\" ? intensity : rampedOptionsToLayerPaintSpec(\n        intensity\n      ),\n      \"heatmap-color\": heatmapIntensityFromColorRamp(colorRamp),\n      \"heatmap-radius\": radiusHeatmap,\n      \"heatmap-opacity\": typeof opacity === \"number\" ? opacity : rampedOptionsToLayerPaintSpec(\n        opacity\n      )\n    }\n  });\n  return returnedInfo;\n}\n\nconst helpers = {\n  addPolyline,\n  addPolygon,\n  addPoint,\n  addHeatmap\n};\n\nconst {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol\n} = maplibregl__default;\nconst MapMLGL = maplibregl__default.Map;\nconst MarkerMLGL = maplibregl__default.Marker;\nconst PopupMLGL = maplibregl__default.Popup;\nconst StyleMLGL = maplibregl__default.Style;\nconst CanvasSourceMLGL = maplibregl__default.CanvasSource;\nconst GeoJSONSourceMLGL = maplibregl__default.GeoJSONSource;\nconst ImageSourceMLGL = maplibregl__default.ImageSource;\nconst RasterTileSourceMLGL = maplibregl__default.RasterTileSource;\nconst RasterDEMTileSourceMLGL = maplibregl__default.RasterDEMTileSource;\nconst VectorTileSourceMLGL = maplibregl__default.VectorTileSource;\nconst VideoSourceMLGL = maplibregl__default.VideoSource;\nmaplibregl__default.NavigationControl;\nmaplibregl__default.GeolocateControl;\nmaplibregl__default.AttributionControl;\nmaplibregl__default.LogoControl;\nmaplibregl__default.ScaleControl;\nmaplibregl__default.FullscreenControl;\nmaplibregl__default.TerrainControl;\n\nexport { AJAXError, AttributionControl, CanvasSource, CanvasSourceMLGL, ColorRamp, ColorRampCollection, Evented, FullscreenControl, GeoJSONSource, GeoJSONSourceMLGL, GeolocateControl, GeolocationType, ImageSource, ImageSourceMLGL, Language, LngLat, LngLatBounds, LogoControl, Map, MapMLGL, MaptilerGeolocateControl, MaptilerLogoControl, MaptilerNavigationControl, MaptilerTerrainControl, Marker, MarkerMLGL, MercatorCoordinate, NavigationControl, Point, Popup, PopupMLGL, RasterDEMTileSource, RasterDEMTileSourceMLGL, RasterTileSource, RasterTileSourceMLGL, ScaleControl, SdkConfig, Style, StyleMLGL, TerrainControl, VectorTileSource, VectorTileSourceMLGL, VideoSource, VideoSourceMLGL, addProtocol, clearPrewarmedResources, config, getBrowserLanguage, getRTLTextPluginStatus, gpx, gpxOrKml, hasChildNodeWithName, helpers, isLanguageSupported, kml, maxParallelImageRequests, prewarm, removeProtocol, setRTLTextPlugin, str2xml, version, workerCount, workerUrl, xml2str };\n//# sourceMappingURL=maptiler-sdk.mjs.map\n",
      "start": 1709123937413,
      "end": 1709123940617,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1709123940617,
      "end": 1709123940617,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1709123940617,
      "end": 1709123940618,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1709123940618,
      "end": 1709123940618,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1709123940618,
      "end": 1709123940618,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1709123940618,
      "end": 1709123940618,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1709123940618,
      "end": 1709123940618,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1709123940618,
      "end": 1709123940618,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1709123940618,
      "end": 1709123940618,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1709123940618,
      "end": 1709123940618,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709123940618,
      "end": 1709123940619,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1709123940619,
      "end": 1709123940620,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1709123940620,
      "end": 1709123940620,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1709123940620,
      "end": 1709123940620,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709123940620,
      "end": 1709123940621,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1709123940621,
      "end": 1709123940622,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1709123940622,
      "end": 1709123940622,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1709123940622,
      "end": 1709123940622,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1709123940622,
      "end": 1709123940622,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1709123940622,
      "end": 1709123940623,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1709123940631,
      "end": 1709123940631,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1709123940631,
      "end": 1709123940631,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1709123940631,
      "end": 1709123940631,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1709123940631,
      "end": 1709123940632,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1709123940632,
      "end": 1709123940632,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1709123940632,
      "end": 1709123940633,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1709123940633,
      "end": 1709123940634,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1709123940634,
      "end": 1709123940634,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1709123940634,
      "end": 1709123940634,
      "order": "post"
    },
    {
      "name": "quasar:directive",
      "start": 1709123940634,
      "end": 1709123940634,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1709123940634,
      "end": 1709123940634,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1709123940634,
      "end": 1709123940634,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1709123940634,
      "end": 1709123940635,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1709123940635,
      "end": 1709123940635,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1709123940635,
      "end": 1709123940973,
      "order": "normal"
    }
  ]
}
