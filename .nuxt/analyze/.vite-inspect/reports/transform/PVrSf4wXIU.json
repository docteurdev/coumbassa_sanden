{
  "resolvedId": "C:/Users/HP/Desktop/projets/next/000/update/coumbassa_sanden/node_modules/bootstrap-vue-next/dist/bootstrap-vue-next.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var zn = Object.defineProperty;\nvar Hn = (e, t, l) => t in e ? zn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l;\nvar Te = (e, t, l) => (Hn(e, typeof t != \"symbol\" ? t + \"\" : t, l), l);\nimport { unref as $, computed as u, ref as R, shallowRef as xa, watch as oe, getCurrentScope as oo, onScopeDispose as no, shallowReadonly as vt, watchEffect as Ht, readonly as ye, effectScope as so, isRef as La, toRef as ke, customRef as Rn, getCurrentInstance as ia, onMounted as He, nextTick as Ce, reactive as St, defineComponent as N, h as ie, Teleport as Na, toValue as Qe, onActivated as Mn, onBeforeUnmount as ro, openBlock as g, createElementBlock as P, Fragment as ce, createElementVNode as K, renderSlot as O, normalizeProps as Be, guardReactiveProps as Ve, createVNode as be, withCtx as j, mergeProps as ee, normalizeClass as H, normalizeStyle as ze, createTextVNode as ne, toDisplayString as Y, createCommentVNode as J, createApp as Dn, provide as De, createBlock as M, resolveDynamicComponent as le, inject as Oe, toHandlers as io, Transition as jn, useSlots as Fe, useAttrs as za, withModifiers as ot, renderList as he, withKeys as It, TransitionGroup as qn, withDirectives as rt, vShow as ua, isReactive as Gn, onUnmounted as Wn, vModelCheckbox as Un, vModelRadio as Xn, vModelSelect as Kn, createSlots as Ha } from \"vue\";\nconst Yn = (e) => typeof e == \"boolean\" || e === \"\" || e === \"true\" || e === \"false\", Ra = (e) => typeof e == \"boolean\" ? e : e === \"\" || e === \"true\";\nclass Ge {\n  constructor(t, l = {}) {\n    Te(this, \"cancelable\", !0);\n    Te(this, \"componentId\", null);\n    Te(this, \"_defaultPrevented\", !1);\n    Te(this, \"eventType\", \"\");\n    Te(this, \"nativeEvent\", null);\n    Te(this, \"_preventDefault\");\n    Te(this, \"relatedTarget\", null);\n    Te(this, \"target\", null);\n    if (!t)\n      throw new TypeError(\n        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`\n      );\n    Object.assign(this, Ge.Defaults, l, { eventType: t }), this._preventDefault = function() {\n      this.cancelable && (this.defaultPrevented = !0);\n    };\n  }\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  get defaultPrevented() {\n    return this._defaultPrevented;\n  }\n  set defaultPrevented(t) {\n    this._defaultPrevented = t;\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  get preventDefault() {\n    return this._preventDefault;\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  set preventDefault(t) {\n    this._preventDefault = t;\n  }\n  static get Defaults() {\n    return {\n      cancelable: !0,\n      componentId: null,\n      eventType: \"\",\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null\n    };\n  }\n}\nclass Rt extends Ge {\n  constructor(l, a = {}) {\n    super(l, a);\n    Te(this, \"trigger\", null);\n    Object.assign(this, Ge.Defaults, a, { eventType: l });\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null\n    };\n  }\n}\nclass uo extends Ge {\n  constructor(l, a) {\n    super(l, a);\n    Te(this, \"from\");\n    Te(this, \"to\");\n    Te(this, \"direction\");\n    Object.assign(this, Ge.Defaults, a, { eventType: l });\n    const { from: o, direction: n, to: s } = a;\n    this.from = o, this.to = s, this.direction = n;\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults\n    };\n  }\n}\nconst ba = (e) => e !== null && typeof e == \"object\", co = (e) => /^[0-9]*\\.?[0-9]+$/.test(String(e)), Jn = (e) => Object.prototype.toString.call(e) === \"[object Object]\", fo = /_/g, vo = /([a-z])([A-Z])/g, Zn = /(\\s|^)(\\w)/g, Qn = /(\\s|^)(\\w)/, Kt = /\\s+/, es = /^#/, ts = /^#[A-Za-z]+[\\w\\-:.]*$/, as = /-u-.+/, ls = /[-/\\\\^$*+?.()|[\\]{}]/g, os = /[\\s\\uFEFF\\xA0]+/g, Zt = (e, t = 2) => typeof e == \"string\" ? e : e == null ? \"\" : Array.isArray(e) || Jn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), il = (e) => e.replace(fo, \" \").replace(vo, (t, l, a) => `${l} ${a}`).replace(Qn, (t, l, a) => l + a.toUpperCase()), ul = (e) => e.replace(fo, \" \").replace(vo, (t, l, a) => `${l} ${a}`).replace(Zn, (t, l, a) => l + a.toUpperCase()), ns = (e) => {\n  const t = e.trim();\n  return t.charAt(0).toUpperCase() + t.slice(1);\n}, ss = (e) => e.replace(ls, \"\\\\$&\"), rs = (e) => ss(e).replace(os, \"\\\\s\"), ma = (e) => `\\\\${e}`, is = (e) => {\n  const t = Zt(e), { length: l } = t, a = t.charCodeAt(0);\n  return t.split(\"\").reduce((o, n, s) => {\n    const r = t.charCodeAt(s);\n    return r === 0 ? `${o}ï¿½` : (\n      // ... is U+007F OR\n      r === 127 || // ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\n      r >= 1 && r <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\n      s === 0 && r >= 48 && r <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n      // and the first character is a `-` (U+002D) ...\n      s === 1 && r >= 48 && r <= 57 && a === 45 ? o + ma(`${r.toString(16)} `) : (\n        // ... is the first character AND ...\n        s === 0 && // ... is a `-` (U+002D) AND ...\n        r === 45 && // ... there is no second character ...\n        l === 1 ? o + ma(n) : (\n          // ... is greater than or equal to U+0080 OR ...\n          r >= 128 || // ... is `-` (U+002D) OR ...\n          r === 45 || // ... is `_` (U+005F) OR ...\n          r === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...\n          r >= 48 && r <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...\n          r >= 65 && r <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...\n          r >= 97 && r <= 122 ? o + n : o + ma(n)\n        )\n      )\n    );\n  }, \"\");\n}, po = typeof window < \"u\", mo = typeof document < \"u\", us = typeof Element < \"u\", ds = typeof navigator < \"u\", cs = po && mo && ds, dl = po ? window : {}, Ma = mo ? document : {};\n(() => {\n  let e = !1;\n  if (cs)\n    try {\n      const t = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          return e = !0, e;\n        }\n      };\n      dl.addEventListener(\"test\", t, t), dl.removeEventListener(\"test\", t, t);\n    } catch {\n      e = !1;\n    }\n  return e;\n})();\nconst Da = typeof window < \"u\", fs = typeof document < \"u\", vs = typeof navigator < \"u\", ja = Da && fs && vs, cl = Da ? window : {}, ps = (() => {\n  let e = !1;\n  if (ja)\n    try {\n      const t = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          e = !0;\n        }\n      };\n      cl.addEventListener(\"test\", t, t), cl.removeEventListener(\"test\", t, t);\n    } catch {\n      e = !1;\n    }\n  return e;\n})(), xe = us ? Element.prototype : void 0, ms = (xe == null ? void 0 : xe.matches) || (xe == null ? void 0 : xe.msMatchesSelector) || (xe == null ? void 0 : xe.webkitMatchesSelector), Ue = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), gs = (e) => Ue(e) ? e.getBoundingClientRect() : null, ys = (e = []) => {\n  const { activeElement: t } = document;\n  return t && !e.some((l) => l === t) ? t : null;\n}, bs = (e) => Ue(e) && e === ys(), hs = (e, t = {}) => {\n  try {\n    e.focus(t);\n  } catch (l) {\n    console.error(l);\n  }\n  return bs(e);\n}, Bs = (e, t) => t && Ue(e) && e.getAttribute(t) || null, Ss = (e) => {\n  if (Bs(e, \"display\") === \"none\")\n    return !1;\n  const t = gs(e);\n  return !!(t && t.height > 0 && t.width > 0);\n}, Ae = (e) => ((e == null ? void 0 : e()) ?? []).length === 0, go = (e, t) => (Ue(t) ? t : Ma).querySelector(e) || null, ws = (e, t) => Array.from([(Ue(t) ? t : Ma).querySelectorAll(e)]), qa = (e, t) => t && Ue(e) ? e.getAttribute(t) : null, _s = (e) => Ma.getElementById(/^#/.test(e) ? e.slice(1) : e) || null, $s = (e, t, l) => {\n  t && Ue(e) && e.setAttribute(t, l);\n}, Cs = (e, t) => {\n  t && Ue(e) && e.removeAttribute(t);\n}, ks = (e, t) => Zt(e).toLowerCase() === Zt(t).toLowerCase(), jt = Da ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || // Fallback, but not a true polyfill\n// Only needed for Opera Mini\n((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), yo = (e, t) => Ue(e) ? ms.call(e, t) : !1, Ts = (xe == null ? void 0 : xe.closest) || function(e) {\n  let t = this;\n  if (!t)\n    return null;\n  do {\n    if (yo(t, e))\n      return t;\n    t = t.parentElement || t.parentNode;\n  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);\n  return null;\n}, fl = (e, t, l = !1) => {\n  if (!Ue(t))\n    return null;\n  const a = Ts.call(t, e);\n  return l ? a : a === t ? null : a;\n}, ha = (e) => {\n  const t = window.getComputedStyle(e), l = t.transitionDelay.split(\",\")[0] || \"\", a = t.transitionDuration.split(\",\")[0] || \"\", o = Number(l.slice(0, -1)) * 1e3, n = Number(a.slice(0, -1)) * 1e3;\n  return o + n;\n}, da = (e, t, l) => t.concat([\"sm\", \"md\", \"lg\", \"xl\", \"xxl\"]).reduce((a, o) => (a[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), /* @__PURE__ */ Object.create(null)), bo = (e, t, l, a = l) => Object.keys(t).reduce((o, n) => (e[n] && o.push(\n  [a, n.replace(l, \"\"), e[n]].filter((s) => s && typeof s != \"boolean\").join(\"-\").toLowerCase()\n), o), []), at = (e = \"\") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, wt = (e) => !!(e.href || e.to), Ne = (e, t = {}, l = {}) => {\n  const a = [e];\n  let o;\n  for (let n = 0; n < a.length && !o; n++) {\n    const s = a[n];\n    o = l[s];\n  }\n  return o && typeof o == \"function\" ? o(t) : o;\n}, lt = (e, t = NaN) => Number.isInteger(e) ? e : t, Vs = (e, t = NaN) => {\n  const l = Number.parseInt(e, 10);\n  return Number.isNaN(l) ? t : l;\n}, Et = (e, t = NaN) => {\n  const l = Number.parseFloat(e.toString());\n  return Number.isNaN(l) ? t : l;\n}, As = (e, t) => Object.keys(e).filter((l) => !t.map((a) => a.toString()).includes(l)).reduce((l, a) => ({ ...l, [a]: e[a] }), {}), Mt = (e, t) => [...t].reduce((l, a) => (l[a] = e[a], l), {}), vl = (e, t) => t + (e ? ns(e) : \"\"), ca = (e, t) => e === !0 || e === \"true\" || e === \"\" ? \"true\" : e === \"grammar\" || e === \"spelling\" ? e : t === !1 ? \"true\" : e === !1 || e === \"false\" ? \"false\" : void 0, ho = Symbol(\"carousel\"), Bo = Symbol(\"tabs\"), So = Symbol(\"progress\"), wo = Symbol(\"listGroup\"), _o = Symbol(\"avatarGroup\"), $o = Symbol(\"accordion\"), Co = Symbol(\"checkboxGroup\"), ko = Symbol(\"radioGroup\"), Ga = Symbol(\"collapse\"), To = Symbol(\"collapse\"), Wa = Symbol(\"navbar\"), Ba = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((l, a) => (typeof a.type == \"symbol\" ? l = l.concat(a.children) : l.push(a), l), []).filter((l) => {\n  var a;\n  return ((a = l.type) == null ? void 0 : a.__name) === t;\n});\nfunction qe(e) {\n  return e.split(\"-\")[1];\n}\nfunction Ua(e) {\n  return e === \"y\" ? \"height\" : \"width\";\n}\nfunction Re(e) {\n  return e.split(\"-\")[0];\n}\nfunction Tt(e) {\n  return [\"top\", \"bottom\"].includes(Re(e)) ? \"x\" : \"y\";\n}\nfunction pl(e, t, l) {\n  let { reference: a, floating: o } = e;\n  const n = a.x + a.width / 2 - o.width / 2, s = a.y + a.height / 2 - o.height / 2, r = Tt(t), i = Ua(r), v = a[i] / 2 - o[i] / 2, b = r === \"x\";\n  let h;\n  switch (Re(t)) {\n    case \"top\":\n      h = { x: n, y: a.y - o.height };\n      break;\n    case \"bottom\":\n      h = { x: n, y: a.y + a.height };\n      break;\n    case \"right\":\n      h = { x: a.x + a.width, y: s };\n      break;\n    case \"left\":\n      h = { x: a.x - o.width, y: s };\n      break;\n    default:\n      h = { x: a.x, y: a.y };\n  }\n  switch (qe(t)) {\n    case \"start\":\n      h[r] -= v * (l && b ? -1 : 1);\n      break;\n    case \"end\":\n      h[r] += v * (l && b ? -1 : 1);\n  }\n  return h;\n}\nconst Os = async (e, t, l) => {\n  const { placement: a = \"bottom\", strategy: o = \"absolute\", middleware: n = [], platform: s } = l, r = n.filter(Boolean), i = await (s.isRTL == null ? void 0 : s.isRTL(t));\n  let v = await s.getElementRects({ reference: e, floating: t, strategy: o }), { x: b, y: h } = pl(v, a, i), p = a, B = {}, S = 0;\n  for (let m = 0; m < r.length; m++) {\n    const { name: A, fn: y } = r[m], { x: k, y: w, data: _, reset: C } = await y({ x: b, y: h, initialPlacement: a, placement: p, strategy: o, middlewareData: B, rects: v, platform: s, elements: { reference: e, floating: t } });\n    b = k ?? b, h = w ?? h, B = { ...B, [A]: { ...B[A], ..._ } }, C && S <= 50 && (S++, typeof C == \"object\" && (C.placement && (p = C.placement), C.rects && (v = C.rects === !0 ? await s.getElementRects({ reference: e, floating: t, strategy: o }) : C.rects), { x: b, y: h } = pl(v, p, i)), m = -1);\n  }\n  return { x: b, y: h, placement: p, strategy: o, middlewareData: B };\n};\nfunction it(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction Xa(e) {\n  return typeof e != \"number\" ? function(t) {\n    return { top: 0, right: 0, bottom: 0, left: 0, ...t };\n  }(e) : { top: e, right: e, bottom: e, left: e };\n}\nfunction _t(e) {\n  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };\n}\nasync function xt(e, t) {\n  var l;\n  t === void 0 && (t = {});\n  const { x: a, y: o, platform: n, rects: s, elements: r, strategy: i } = e, { boundary: v = \"clippingAncestors\", rootBoundary: b = \"viewport\", elementContext: h = \"floating\", altBoundary: p = !1, padding: B = 0 } = it(t, e), S = Xa(B), m = r[p ? h === \"floating\" ? \"reference\" : \"floating\" : h], A = _t(await n.getClippingRect({ element: (l = await (n.isElement == null ? void 0 : n.isElement(m))) == null || l ? m : m.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(r.floating)), boundary: v, rootBoundary: b, strategy: i })), y = h === \"floating\" ? { ...s.floating, x: a, y: o } : s.reference, k = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(r.floating)), w = await (n.isElement == null ? void 0 : n.isElement(k)) && await (n.getScale == null ? void 0 : n.getScale(k)) || { x: 1, y: 1 }, _ = _t(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: y, offsetParent: k, strategy: i }) : y);\n  return { top: (A.top - _.top + S.top) / w.y, bottom: (_.bottom - A.bottom + S.bottom) / w.y, left: (A.left - _.left + S.left) / w.x, right: (_.right - A.right + S.right) / w.x };\n}\nconst $t = Math.min, Qt = Math.max;\nfunction Sa(e, t, l) {\n  return Qt(e, $t(t, l));\n}\nconst Fs = (e) => ({ name: \"arrow\", options: e, async fn(t) {\n  const { x: l, y: a, placement: o, rects: n, platform: s, elements: r } = t, { element: i, padding: v = 0 } = it(e, t) || {};\n  if (i == null)\n    return {};\n  const b = Xa(v), h = { x: l, y: a }, p = Tt(o), B = Ua(p), S = await s.getDimensions(i), m = p === \"y\", A = m ? \"top\" : \"left\", y = m ? \"bottom\" : \"right\", k = m ? \"clientHeight\" : \"clientWidth\", w = n.reference[B] + n.reference[p] - h[p] - n.floating[B], _ = h[p] - n.reference[p], C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(i));\n  let T = C ? C[k] : 0;\n  T && await (s.isElement == null ? void 0 : s.isElement(C)) || (T = r.floating[k] || n.floating[B]);\n  const c = w / 2 - _ / 2, V = T / 2 - S[B] / 2 - 1, F = $t(b[A], V), f = $t(b[y], V), I = F, E = T - S[B] - f, z = T / 2 - S[B] / 2 + c, Z = Sa(I, z, E), te = qe(o) != null && z != Z && n.reference[B] / 2 - (z < I ? F : f) - S[B] / 2 < 0 ? z < I ? I - z : E - z : 0;\n  return { [p]: h[p] - te, data: { [p]: Z, centerOffset: z - Z + te } };\n} }), Vo = [\"top\", \"right\", \"bottom\", \"left\"], ml = Vo.reduce((e, t) => e.concat(t, t + \"-start\", t + \"-end\"), []), Ps = { left: \"right\", right: \"left\", bottom: \"top\", top: \"bottom\" };\nfunction ea(e) {\n  return e.replace(/left|right|bottom|top/g, (t) => Ps[t]);\n}\nfunction Ao(e, t, l) {\n  l === void 0 && (l = !1);\n  const a = qe(e), o = Tt(e), n = Ua(o);\n  let s = o === \"x\" ? a === (l ? \"end\" : \"start\") ? \"right\" : \"left\" : a === \"start\" ? \"bottom\" : \"top\";\n  return t.reference[n] > t.floating[n] && (s = ea(s)), { main: s, cross: ea(s) };\n}\nconst Es = { start: \"end\", end: \"start\" };\nfunction Yt(e) {\n  return e.replace(/start|end/g, (t) => Es[t]);\n}\nconst Is = function(e) {\n  return e === void 0 && (e = {}), { name: \"autoPlacement\", options: e, async fn(t) {\n    var l, a, o;\n    const { rects: n, middlewareData: s, placement: r, platform: i, elements: v } = t, { crossAxis: b = !1, alignment: h, allowedPlacements: p = ml, autoAlignment: B = !0, ...S } = it(e, t), m = h !== void 0 || p === ml ? function(f, I, E) {\n      return (f ? [...E.filter((z) => qe(z) === f), ...E.filter((z) => qe(z) !== f)] : E.filter((z) => Re(z) === z)).filter((z) => !f || qe(z) === f || !!I && Yt(z) !== z);\n    }(h || null, B, p) : p, A = await xt(t, S), y = ((l = s.autoPlacement) == null ? void 0 : l.index) || 0, k = m[y];\n    if (k == null)\n      return {};\n    const { main: w, cross: _ } = Ao(k, n, await (i.isRTL == null ? void 0 : i.isRTL(v.floating)));\n    if (r !== k)\n      return { reset: { placement: m[0] } };\n    const C = [A[Re(k)], A[w], A[_]], T = [...((a = s.autoPlacement) == null ? void 0 : a.overflows) || [], { placement: k, overflows: C }], c = m[y + 1];\n    if (c)\n      return { data: { index: y + 1, overflows: T }, reset: { placement: c } };\n    const V = T.map((f) => {\n      const I = qe(f.placement);\n      return [f.placement, I && b ? f.overflows.slice(0, 2).reduce((E, z) => E + z, 0) : f.overflows[0], f.overflows];\n    }).sort((f, I) => f[1] - I[1]), F = ((o = V.filter((f) => f[2].slice(0, qe(f[0]) ? 2 : 3).every((I) => I <= 0))[0]) == null ? void 0 : o[0]) || V[0][0];\n    return F !== r ? { data: { index: y + 1, overflows: T }, reset: { placement: F } } : {};\n  } };\n}, Oo = function(e) {\n  return e === void 0 && (e = {}), { name: \"flip\", options: e, async fn(t) {\n    var l;\n    const { placement: a, middlewareData: o, rects: n, initialPlacement: s, platform: r, elements: i } = t, { mainAxis: v = !0, crossAxis: b = !0, fallbackPlacements: h, fallbackStrategy: p = \"bestFit\", fallbackAxisSideDirection: B = \"none\", flipAlignment: S = !0, ...m } = it(e, t), A = Re(a), y = Re(s) === s, k = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), w = h || (y || !S ? [ea(s)] : function(I) {\n      const E = ea(I);\n      return [Yt(I), E, Yt(E)];\n    }(s));\n    h || B === \"none\" || w.push(...function(I, E, z, Z) {\n      const te = qe(I);\n      let G = function(W, X, ve) {\n        const ge = [\"left\", \"right\"], pe = [\"right\", \"left\"], me = [\"top\", \"bottom\"], q = [\"bottom\", \"top\"];\n        switch (W) {\n          case \"top\":\n          case \"bottom\":\n            return ve ? X ? pe : ge : X ? ge : pe;\n          case \"left\":\n          case \"right\":\n            return X ? me : q;\n          default:\n            return [];\n        }\n      }(Re(I), z === \"start\", Z);\n      return te && (G = G.map((W) => W + \"-\" + te), E && (G = G.concat(G.map(Yt)))), G;\n    }(s, S, B, k));\n    const _ = [s, ...w], C = await xt(t, m), T = [];\n    let c = ((l = o.flip) == null ? void 0 : l.overflows) || [];\n    if (v && T.push(C[A]), b) {\n      const { main: I, cross: E } = Ao(a, n, k);\n      T.push(C[I], C[E]);\n    }\n    if (c = [...c, { placement: a, overflows: T }], !T.every((I) => I <= 0)) {\n      var V, F;\n      const I = (((V = o.flip) == null ? void 0 : V.index) || 0) + 1, E = _[I];\n      if (E)\n        return { data: { index: I, overflows: c }, reset: { placement: E } };\n      let z = (F = c.filter((Z) => Z.overflows[0] <= 0).sort((Z, te) => Z.overflows[1] - te.overflows[1])[0]) == null ? void 0 : F.placement;\n      if (!z)\n        switch (p) {\n          case \"bestFit\": {\n            var f;\n            const Z = (f = c.map((te) => [te.placement, te.overflows.filter((G) => G > 0).reduce((G, W) => G + W, 0)]).sort((te, G) => te[1] - G[1])[0]) == null ? void 0 : f[0];\n            Z && (z = Z);\n            break;\n          }\n          case \"initialPlacement\":\n            z = s;\n        }\n      if (a !== z)\n        return { reset: { placement: z } };\n    }\n    return {};\n  } };\n};\nfunction gl(e, t) {\n  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };\n}\nfunction yl(e) {\n  return Vo.some((t) => e[t] >= 0);\n}\nconst xs = function(e) {\n  return e === void 0 && (e = {}), { name: \"hide\", options: e, async fn(t) {\n    const { rects: l } = t, { strategy: a = \"referenceHidden\", ...o } = it(e, t);\n    switch (a) {\n      case \"referenceHidden\": {\n        const n = gl(await xt(t, { ...o, elementContext: \"reference\" }), l.reference);\n        return { data: { referenceHiddenOffsets: n, referenceHidden: yl(n) } };\n      }\n      case \"escaped\": {\n        const n = gl(await xt(t, { ...o, altBoundary: !0 }), l.floating);\n        return { data: { escapedOffsets: n, escaped: yl(n) } };\n      }\n      default:\n        return {};\n    }\n  } };\n};\nfunction bl(e) {\n  const t = $t(...e.map((a) => a.left)), l = $t(...e.map((a) => a.top));\n  return { x: t, y: l, width: Qt(...e.map((a) => a.right)) - t, height: Qt(...e.map((a) => a.bottom)) - l };\n}\nconst Ls = function(e) {\n  return e === void 0 && (e = {}), { name: \"inline\", options: e, async fn(t) {\n    const { placement: l, elements: a, rects: o, platform: n, strategy: s } = t, { padding: r = 2, x: i, y: v } = it(e, t), b = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(a.reference)) || []), h = function(m) {\n      const A = m.slice().sort((w, _) => w.y - _.y), y = [];\n      let k = null;\n      for (let w = 0; w < A.length; w++) {\n        const _ = A[w];\n        !k || _.y - k.y > k.height / 2 ? y.push([_]) : y[y.length - 1].push(_), k = _;\n      }\n      return y.map((w) => _t(bl(w)));\n    }(b), p = _t(bl(b)), B = Xa(r), S = await n.getElementRects({ reference: { getBoundingClientRect: function() {\n      if (h.length === 2 && h[0].left > h[1].right && i != null && v != null)\n        return h.find((m) => i > m.left - B.left && i < m.right + B.right && v > m.top - B.top && v < m.bottom + B.bottom) || p;\n      if (h.length >= 2) {\n        if (Tt(l) === \"x\") {\n          const C = h[0], T = h[h.length - 1], c = Re(l) === \"top\", V = C.top, F = T.bottom, f = c ? C.left : T.left, I = c ? C.right : T.right;\n          return { top: V, bottom: F, left: f, right: I, width: I - f, height: F - V, x: f, y: V };\n        }\n        const m = Re(l) === \"left\", A = Qt(...h.map((C) => C.right)), y = $t(...h.map((C) => C.left)), k = h.filter((C) => m ? C.left === y : C.right === A), w = k[0].top, _ = k[k.length - 1].bottom;\n        return { top: w, bottom: _, left: y, right: A, width: A - y, height: _ - w, x: y, y: w };\n      }\n      return p;\n    } }, floating: a.floating, strategy: s });\n    return o.reference.x !== S.reference.x || o.reference.y !== S.reference.y || o.reference.width !== S.reference.width || o.reference.height !== S.reference.height ? { reset: { rects: S } } : {};\n  } };\n}, Fo = function(e) {\n  return e === void 0 && (e = 0), { name: \"offset\", options: e, async fn(t) {\n    const { x: l, y: a } = t, o = await async function(n, s) {\n      const { placement: r, platform: i, elements: v } = n, b = await (i.isRTL == null ? void 0 : i.isRTL(v.floating)), h = Re(r), p = qe(r), B = Tt(r) === \"x\", S = [\"left\", \"top\"].includes(h) ? -1 : 1, m = b && B ? -1 : 1, A = it(s, n);\n      let { mainAxis: y, crossAxis: k, alignmentAxis: w } = typeof A == \"number\" ? { mainAxis: A, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...A };\n      return p && typeof w == \"number\" && (k = p === \"end\" ? -1 * w : w), B ? { x: k * m, y: y * S } : { x: y * S, y: k * m };\n    }(t, e);\n    return { x: l + o.x, y: a + o.y, data: o };\n  } };\n};\nfunction Ns(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nconst Po = function(e) {\n  return e === void 0 && (e = {}), { name: \"shift\", options: e, async fn(t) {\n    const { x: l, y: a, placement: o } = t, { mainAxis: n = !0, crossAxis: s = !1, limiter: r = { fn: (A) => {\n      let { x: y, y: k } = A;\n      return { x: y, y: k };\n    } }, ...i } = it(e, t), v = { x: l, y: a }, b = await xt(t, i), h = Tt(Re(o)), p = Ns(h);\n    let B = v[h], S = v[p];\n    if (n) {\n      const A = h === \"y\" ? \"bottom\" : \"right\";\n      B = Sa(B + b[h === \"y\" ? \"top\" : \"left\"], B, B - b[A]);\n    }\n    if (s) {\n      const A = p === \"y\" ? \"bottom\" : \"right\";\n      S = Sa(S + b[p === \"y\" ? \"top\" : \"left\"], S, S - b[A]);\n    }\n    const m = r.fn({ ...t, [h]: B, [p]: S });\n    return { ...m, data: { x: m.x - l, y: m.y - a } };\n  } };\n};\nfunction Pe(e) {\n  var t;\n  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;\n}\nfunction We(e) {\n  return Pe(e).getComputedStyle(e);\n}\nfunction Eo(e) {\n  return e instanceof Pe(e).Node;\n}\nfunction nt(e) {\n  return Eo(e) ? (e.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction Me(e) {\n  return e instanceof HTMLElement || e instanceof Pe(e).HTMLElement;\n}\nfunction hl(e) {\n  return typeof ShadowRoot < \"u\" && (e instanceof Pe(e).ShadowRoot || e instanceof ShadowRoot);\n}\nfunction Lt(e) {\n  const { overflow: t, overflowX: l, overflowY: a, display: o } = We(e);\n  return /auto|scroll|overlay|hidden|clip/.test(t + a + l) && ![\"inline\", \"contents\"].includes(o);\n}\nfunction zs(e) {\n  return [\"table\", \"td\", \"th\"].includes(nt(e));\n}\nfunction wa(e) {\n  const t = Ka(), l = We(e);\n  return l.transform !== \"none\" || l.perspective !== \"none\" || !!l.containerType && l.containerType !== \"normal\" || !t && !!l.backdropFilter && l.backdropFilter !== \"none\" || !t && !!l.filter && l.filter !== \"none\" || [\"transform\", \"perspective\", \"filter\"].some((a) => (l.willChange || \"\").includes(a)) || [\"paint\", \"layout\", \"strict\", \"content\"].some((a) => (l.contain || \"\").includes(a));\n}\nfunction Ka() {\n  return !(typeof CSS > \"u\" || !CSS.supports) && CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction fa(e) {\n  return [\"html\", \"body\", \"#document\"].includes(nt(e));\n}\nconst _a = Math.min, ht = Math.max, ta = Math.round, qt = Math.floor, st = (e) => ({ x: e, y: e });\nfunction Io(e) {\n  const t = We(e);\n  let l = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;\n  const o = Me(e), n = o ? e.offsetWidth : l, s = o ? e.offsetHeight : a, r = ta(l) !== n || ta(a) !== s;\n  return r && (l = n, a = s), { width: l, height: a, $: r };\n}\nfunction Ye(e) {\n  return e instanceof Element || e instanceof Pe(e).Element;\n}\nfunction Ya(e) {\n  return Ye(e) ? e : e.contextElement;\n}\nfunction Bt(e) {\n  const t = Ya(e);\n  if (!Me(t))\n    return st(1);\n  const l = t.getBoundingClientRect(), { width: a, height: o, $: n } = Io(t);\n  let s = (n ? ta(l.width) : l.width) / a, r = (n ? ta(l.height) : l.height) / o;\n  return s && Number.isFinite(s) || (s = 1), r && Number.isFinite(r) || (r = 1), { x: s, y: r };\n}\nconst Hs = st(0);\nfunction xo(e) {\n  const t = Pe(e);\n  return Ka() && t.visualViewport ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } : Hs;\n}\nfunction dt(e, t, l, a) {\n  t === void 0 && (t = !1), l === void 0 && (l = !1);\n  const o = e.getBoundingClientRect(), n = Ya(e);\n  let s = st(1);\n  t && (a ? Ye(a) && (s = Bt(a)) : s = Bt(e));\n  const r = function(p, B, S) {\n    return B === void 0 && (B = !1), !(!S || B && S !== Pe(p)) && B;\n  }(n, l, a) ? xo(n) : st(0);\n  let i = (o.left + r.x) / s.x, v = (o.top + r.y) / s.y, b = o.width / s.x, h = o.height / s.y;\n  if (n) {\n    const p = Pe(n), B = a && Ye(a) ? Pe(a) : a;\n    let S = p.frameElement;\n    for (; S && a && B !== p; ) {\n      const m = Bt(S), A = S.getBoundingClientRect(), y = getComputedStyle(S), k = A.left + (S.clientLeft + parseFloat(y.paddingLeft)) * m.x, w = A.top + (S.clientTop + parseFloat(y.paddingTop)) * m.y;\n      i *= m.x, v *= m.y, b *= m.x, h *= m.y, i += k, v += w, S = Pe(S).frameElement;\n    }\n  }\n  return _t({ width: b, height: h, x: i, y: v });\n}\nfunction va(e) {\n  return Ye(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };\n}\nfunction Je(e) {\n  var t;\n  return (t = (Eo(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;\n}\nfunction Lo(e) {\n  return dt(Je(e)).left + va(e).scrollLeft;\n}\nfunction Ct(e) {\n  if (nt(e) === \"html\")\n    return e;\n  const t = e.assignedSlot || e.parentNode || hl(e) && e.host || Je(e);\n  return hl(t) ? t.host : t;\n}\nfunction No(e) {\n  const t = Ct(e);\n  return fa(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Me(t) && Lt(t) ? t : No(t);\n}\nfunction aa(e, t) {\n  var l;\n  t === void 0 && (t = []);\n  const a = No(e), o = a === ((l = e.ownerDocument) == null ? void 0 : l.body), n = Pe(a);\n  return o ? t.concat(n, n.visualViewport || [], Lt(a) ? a : []) : t.concat(a, aa(a));\n}\nfunction Bl(e, t, l) {\n  let a;\n  if (t === \"viewport\")\n    a = function(o, n) {\n      const s = Pe(o), r = Je(o), i = s.visualViewport;\n      let v = r.clientWidth, b = r.clientHeight, h = 0, p = 0;\n      if (i) {\n        v = i.width, b = i.height;\n        const B = Ka();\n        (!B || B && n === \"fixed\") && (h = i.offsetLeft, p = i.offsetTop);\n      }\n      return { width: v, height: b, x: h, y: p };\n    }(e, l);\n  else if (t === \"document\")\n    a = function(o) {\n      const n = Je(o), s = va(o), r = o.ownerDocument.body, i = ht(n.scrollWidth, n.clientWidth, r.scrollWidth, r.clientWidth), v = ht(n.scrollHeight, n.clientHeight, r.scrollHeight, r.clientHeight);\n      let b = -s.scrollLeft + Lo(o);\n      const h = -s.scrollTop;\n      return We(r).direction === \"rtl\" && (b += ht(n.clientWidth, r.clientWidth) - i), { width: i, height: v, x: b, y: h };\n    }(Je(e));\n  else if (Ye(t))\n    a = function(o, n) {\n      const s = dt(o, !0, n === \"fixed\"), r = s.top + o.clientTop, i = s.left + o.clientLeft, v = Me(o) ? Bt(o) : st(1);\n      return { width: o.clientWidth * v.x, height: o.clientHeight * v.y, x: i * v.x, y: r * v.y };\n    }(t, l);\n  else {\n    const o = xo(e);\n    a = { ...t, x: t.x - o.x, y: t.y - o.y };\n  }\n  return _t(a);\n}\nfunction zo(e, t) {\n  const l = Ct(e);\n  return !(l === t || !Ye(l) || fa(l)) && (We(l).position === \"fixed\" || zo(l, t));\n}\nfunction Rs(e, t, l) {\n  const a = Me(t), o = Je(t), n = l === \"fixed\", s = dt(e, !0, n, t);\n  let r = { scrollLeft: 0, scrollTop: 0 };\n  const i = st(0);\n  if (a || !a && !n)\n    if ((nt(t) !== \"body\" || Lt(o)) && (r = va(t)), Me(t)) {\n      const v = dt(t, !0, n, t);\n      i.x = v.x + t.clientLeft, i.y = v.y + t.clientTop;\n    } else\n      o && (i.x = Lo(o));\n  return { x: s.left + r.scrollLeft - i.x, y: s.top + r.scrollTop - i.y, width: s.width, height: s.height };\n}\nfunction Sl(e, t) {\n  return Me(e) && We(e).position !== \"fixed\" ? t ? t(e) : e.offsetParent : null;\n}\nfunction wl(e, t) {\n  const l = Pe(e);\n  if (!Me(e))\n    return l;\n  let a = Sl(e, t);\n  for (; a && zs(a) && We(a).position === \"static\"; )\n    a = Sl(a, t);\n  return a && (nt(a) === \"html\" || nt(a) === \"body\" && We(a).position === \"static\" && !wa(a)) ? l : a || function(o) {\n    let n = Ct(o);\n    for (; Me(n) && !fa(n); ) {\n      if (wa(n))\n        return n;\n      n = Ct(n);\n    }\n    return null;\n  }(e) || l;\n}\nconst Ms = { convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {\n  let { rect: t, offsetParent: l, strategy: a } = e;\n  const o = Me(l), n = Je(l);\n  if (l === n)\n    return t;\n  let s = { scrollLeft: 0, scrollTop: 0 }, r = st(1);\n  const i = st(0);\n  if ((o || !o && a !== \"fixed\") && ((nt(l) !== \"body\" || Lt(n)) && (s = va(l)), Me(l))) {\n    const v = dt(l);\n    r = Bt(l), i.x = v.x + l.clientLeft, i.y = v.y + l.clientTop;\n  }\n  return { width: t.width * r.x, height: t.height * r.y, x: t.x * r.x - s.scrollLeft * r.x + i.x, y: t.y * r.y - s.scrollTop * r.y + i.y };\n}, getDocumentElement: Je, getClippingRect: function(e) {\n  let { element: t, boundary: l, rootBoundary: a, strategy: o } = e;\n  const n = [...l === \"clippingAncestors\" ? function(i, v) {\n    const b = v.get(i);\n    if (b)\n      return b;\n    let h = aa(i).filter((m) => Ye(m) && nt(m) !== \"body\"), p = null;\n    const B = We(i).position === \"fixed\";\n    let S = B ? Ct(i) : i;\n    for (; Ye(S) && !fa(S); ) {\n      const m = We(S), A = wa(S);\n      A || m.position !== \"fixed\" || (p = null), (B ? !A && !p : !A && m.position === \"static\" && p && [\"absolute\", \"fixed\"].includes(p.position) || Lt(S) && !A && zo(i, S)) ? h = h.filter((y) => y !== S) : p = m, S = Ct(S);\n    }\n    return v.set(i, h), h;\n  }(t, this._c) : [].concat(l), a], s = n[0], r = n.reduce((i, v) => {\n    const b = Bl(t, v, o);\n    return i.top = ht(b.top, i.top), i.right = _a(b.right, i.right), i.bottom = _a(b.bottom, i.bottom), i.left = ht(b.left, i.left), i;\n  }, Bl(t, s, o));\n  return { width: r.right - r.left, height: r.bottom - r.top, x: r.left, y: r.top };\n}, getOffsetParent: wl, getElementRects: async function(e) {\n  let { reference: t, floating: l, strategy: a } = e;\n  const o = this.getOffsetParent || wl, n = this.getDimensions;\n  return { reference: Rs(t, await o(l), a), floating: { x: 0, y: 0, ...await n(l) } };\n}, getClientRects: function(e) {\n  return Array.from(e.getClientRects());\n}, getDimensions: function(e) {\n  return Io(e);\n}, getScale: Bt, isElement: Ye, isRTL: function(e) {\n  return getComputedStyle(e).direction === \"rtl\";\n} };\nfunction Ho(e, t, l, a) {\n  a === void 0 && (a = {});\n  const { ancestorScroll: o = !0, ancestorResize: n = !0, elementResize: s = typeof ResizeObserver == \"function\", layoutShift: r = typeof IntersectionObserver == \"function\", animationFrame: i = !1 } = a, v = Ya(e), b = o || n ? [...v ? aa(v) : [], ...aa(t)] : [];\n  b.forEach((A) => {\n    o && A.addEventListener(\"scroll\", l, { passive: !0 }), n && A.addEventListener(\"resize\", l);\n  });\n  const h = v && r ? function(A, y) {\n    let k, w = null;\n    const _ = Je(A);\n    function C() {\n      clearTimeout(k), w && w.disconnect(), w = null;\n    }\n    return function T(c, V) {\n      c === void 0 && (c = !1), V === void 0 && (V = 1), C();\n      const { left: F, top: f, width: I, height: E } = A.getBoundingClientRect();\n      if (c || y(), !I || !E)\n        return;\n      const z = { rootMargin: -qt(f) + \"px \" + -qt(_.clientWidth - (F + I)) + \"px \" + -qt(_.clientHeight - (f + E)) + \"px \" + -qt(F) + \"px\", threshold: ht(0, _a(1, V)) || 1 };\n      let Z = !0;\n      function te(G) {\n        const W = G[0].intersectionRatio;\n        if (W !== V) {\n          if (!Z)\n            return T();\n          W ? T(!1, W) : k = setTimeout(() => {\n            T(!1, 1e-7);\n          }, 100);\n        }\n        Z = !1;\n      }\n      try {\n        w = new IntersectionObserver(te, { ...z, root: _.ownerDocument });\n      } catch {\n        w = new IntersectionObserver(te, z);\n      }\n      w.observe(A);\n    }(!0), C;\n  }(v, l) : null;\n  let p, B = -1, S = null;\n  s && (S = new ResizeObserver((A) => {\n    let [y] = A;\n    y && y.target === v && S && (S.unobserve(t), cancelAnimationFrame(B), B = requestAnimationFrame(() => {\n      S && S.observe(t);\n    })), l();\n  }), v && !i && S.observe(v), S.observe(t));\n  let m = i ? dt(e) : null;\n  return i && function A() {\n    const y = dt(e);\n    !m || y.x === m.x && y.y === m.y && y.width === m.width && y.height === m.height || l(), m = y, p = requestAnimationFrame(A);\n  }(), l(), () => {\n    b.forEach((A) => {\n      o && A.removeEventListener(\"scroll\", l), n && A.removeEventListener(\"resize\", l);\n    }), h && h(), S && S.disconnect(), S = null, i && cancelAnimationFrame(p);\n  };\n}\nconst Ds = (e, t, l) => {\n  const a = /* @__PURE__ */ new Map(), o = { platform: Ms, ...l }, n = { ...o.platform, _c: a };\n  return Os(e, t, { ...o, platform: n });\n};\nfunction $a(e) {\n  var t;\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nfunction js(e) {\n  return {\n    name: \"arrow\",\n    options: e,\n    fn(t) {\n      const l = $a($(e.element));\n      return l == null ? {} : Fs({\n        element: l,\n        padding: e.padding\n      }).fn(t);\n    }\n  };\n}\nfunction Ro(e) {\n  return typeof window > \"u\" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;\n}\nfunction _l(e, t) {\n  const l = Ro(e);\n  return Math.round(t * l) / l;\n}\nfunction Mo(e, t, l) {\n  l === void 0 && (l = {});\n  const a = l.whileElementsMounted, o = u(() => {\n    var c;\n    return (c = $(l.open)) != null ? c : !0;\n  }), n = u(() => $(l.middleware)), s = u(() => {\n    var c;\n    return (c = $(l.placement)) != null ? c : \"bottom\";\n  }), r = u(() => {\n    var c;\n    return (c = $(l.strategy)) != null ? c : \"absolute\";\n  }), i = u(() => {\n    var c;\n    return (c = $(l.transform)) != null ? c : !0;\n  }), v = u(() => $a(e.value)), b = u(() => $a(t.value)), h = R(0), p = R(0), B = R(r.value), S = R(s.value), m = xa({}), A = R(!1), y = u(() => {\n    const c = {\n      position: B.value,\n      left: \"0\",\n      top: \"0\"\n    };\n    if (!b.value)\n      return c;\n    const V = _l(b.value, h.value), F = _l(b.value, p.value);\n    return i.value ? {\n      ...c,\n      transform: \"translate(\" + V + \"px, \" + F + \"px)\",\n      ...Ro(b.value) >= 1.5 && {\n        willChange: \"transform\"\n      }\n    } : {\n      position: B.value,\n      left: V + \"px\",\n      top: F + \"px\"\n    };\n  });\n  let k;\n  function w() {\n    v.value == null || b.value == null || Ds(v.value, b.value, {\n      middleware: n.value,\n      placement: s.value,\n      strategy: r.value\n    }).then((c) => {\n      h.value = c.x, p.value = c.y, B.value = c.strategy, S.value = c.placement, m.value = c.middlewareData, A.value = !0;\n    });\n  }\n  function _() {\n    typeof k == \"function\" && (k(), k = void 0);\n  }\n  function C() {\n    if (_(), a === void 0) {\n      w();\n      return;\n    }\n    if (v.value != null && b.value != null) {\n      k = a(v.value, b.value, w);\n      return;\n    }\n  }\n  function T() {\n    o.value || (A.value = !1);\n  }\n  return oe([n, s, r], w, {\n    flush: \"sync\"\n  }), oe([v, b], C, {\n    flush: \"sync\"\n  }), oe(o, T, {\n    flush: \"sync\"\n  }), oo() && no(_), {\n    x: vt(h),\n    y: vt(p),\n    strategy: vt(B),\n    placement: vt(S),\n    middlewareData: vt(m),\n    isPositioned: vt(A),\n    floatingStyles: y,\n    update: w\n  };\n}\nconst qs = /* @__PURE__ */ new Set([\n  \"background\",\n  \"cite\",\n  \"href\",\n  \"itemtype\",\n  \"longdesc\",\n  \"poster\",\n  \"src\",\n  \"xlink:href\"\n]), Gs = /^aria-[\\w-]*$/i, Ws = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Us = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i, Xs = (e, t) => {\n  const l = e.nodeName.toLowerCase();\n  return t.includes(l) ? qs.has(l) ? !!(Ws.test(e.nodeValue || \"\") || Us.test(e.nodeValue || \"\")) : !0 : t.filter((a) => a instanceof RegExp).some((a) => a.test(l));\n}, gt = {\n  // Global attributes allowed on any supplied element below.\n  \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", Gs],\n  a: [\"target\", \"href\", \"title\", \"rel\"],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  div: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n}, yt = (e, t, l) => {\n  if (!e.length)\n    return e;\n  if (l && typeof l == \"function\")\n    return l(e);\n  const o = new window.DOMParser().parseFromString(e, \"text/html\"), n = o.body.querySelectorAll(\"*\");\n  for (const s of n) {\n    const r = s.nodeName.toLowerCase();\n    if (!Object.keys(t).includes(r)) {\n      s.remove();\n      continue;\n    }\n    const i = s.attributes, v = [...t[\"*\"] || [], ...t[r] || []];\n    for (const b of i)\n      Xs(b, v) || s.removeAttribute(b.nodeName);\n  }\n  return o.body.innerHTML;\n};\nvar Ks = Object.defineProperty, Ys = Object.defineProperties, Js = Object.getOwnPropertyDescriptors, $l = Object.getOwnPropertySymbols, Zs = Object.prototype.hasOwnProperty, Qs = Object.prototype.propertyIsEnumerable, Cl = (e, t, l) => t in e ? Ks(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, er = (e, t) => {\n  for (var l in t || (t = {}))\n    Zs.call(t, l) && Cl(e, l, t[l]);\n  if ($l)\n    for (var l of $l(t))\n      Qs.call(t, l) && Cl(e, l, t[l]);\n  return e;\n}, tr = (e, t) => Ys(e, Js(t));\nfunction Do(e, t) {\n  var l;\n  const a = xa();\n  return Ht(() => {\n    a.value = e();\n  }, tr(er({}, t), {\n    flush: (l = t == null ? void 0 : t.flush) != null ? l : \"sync\"\n  })), ye(a);\n}\nfunction ct(e) {\n  return oo() ? (no(e), !0) : !1;\n}\nfunction ar(e) {\n  let t = !1, l;\n  const a = so(!0);\n  return (...o) => (t || (l = a.run(() => e(...o)), t = !0), l);\n}\nfunction lr(e) {\n  let t = 0, l, a;\n  const o = () => {\n    t -= 1, a && t <= 0 && (a.stop(), l = void 0, a = void 0);\n  };\n  return (...n) => (t += 1, l || (a = so(!0), l = a.run(() => e(...n))), ct(o), l);\n}\nfunction ft(e) {\n  return typeof e == \"function\" ? e() : $(e);\n}\nconst la = typeof window < \"u\", or = (e) => typeof e < \"u\", Nt = () => {\n}, Ca = /* @__PURE__ */ nr();\nfunction nr() {\n  var e;\n  return la && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);\n}\nfunction sr(e, t) {\n  function l(...a) {\n    return new Promise((o, n) => {\n      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(o).catch(n);\n    });\n  }\n  return l;\n}\nconst jo = (e) => e();\nfunction rr(e = jo) {\n  const t = R(!0);\n  function l() {\n    t.value = !1;\n  }\n  function a() {\n    t.value = !0;\n  }\n  const o = (...n) => {\n    t.value && e(...n);\n  };\n  return { isActive: ye(t), pause: l, resume: a, eventFilter: o };\n}\nfunction Ja(...e) {\n  if (e.length !== 1)\n    return ke(...e);\n  const t = e[0];\n  return typeof t == \"function\" ? ye(Rn(() => ({ get: t, set: Nt }))) : R(t);\n}\nfunction ir(e, t = !0) {\n  ia() ? He(e) : t ? e() : Ce(e);\n}\nfunction ur(e = 0, t = {}) {\n  const l = R(e), {\n    max: a = 1 / 0,\n    min: o = -1 / 0\n  } = t, n = (b = 1) => l.value = Math.min(a, l.value + b), s = (b = 1) => l.value = Math.max(o, l.value - b), r = () => l.value, i = (b) => l.value = Math.max(o, Math.min(a, b));\n  return { count: l, inc: n, dec: s, get: r, set: i, reset: (b = e) => (e = b, i(b)) };\n}\nfunction qo(e, t = 1e3, l = {}) {\n  const {\n    immediate: a = !0,\n    immediateCallback: o = !1\n  } = l;\n  let n = null;\n  const s = R(!1);\n  function r() {\n    n && (clearInterval(n), n = null);\n  }\n  function i() {\n    s.value = !1, r();\n  }\n  function v() {\n    const b = ft(t);\n    b <= 0 || (s.value = !0, o && e(), r(), n = setInterval(e, b));\n  }\n  if (a && la && v(), La(t) || typeof t == \"function\") {\n    const b = oe(t, () => {\n      s.value && la && v();\n    });\n    ct(b);\n  }\n  return ct(i), {\n    isActive: s,\n    pause: i,\n    resume: v\n  };\n}\nfunction bt(e, t = {}) {\n  const {\n    method: l = \"parseFloat\",\n    radix: a,\n    nanToZero: o\n  } = t;\n  return u(() => {\n    let n = ft(e);\n    return typeof n == \"string\" && (n = Number[l](n, a)), o && Number.isNaN(n) && (n = 0), n;\n  });\n}\nvar kl = Object.getOwnPropertySymbols, dr = Object.prototype.hasOwnProperty, cr = Object.prototype.propertyIsEnumerable, fr = (e, t) => {\n  var l = {};\n  for (var a in e)\n    dr.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);\n  if (e != null && kl)\n    for (var a of kl(e))\n      t.indexOf(a) < 0 && cr.call(e, a) && (l[a] = e[a]);\n  return l;\n};\nfunction vr(e, t, l = {}) {\n  const a = l, {\n    eventFilter: o = jo\n  } = a, n = fr(a, [\n    \"eventFilter\"\n  ]);\n  return oe(\n    e,\n    sr(\n      o,\n      t\n    ),\n    n\n  );\n}\nvar pr = Object.defineProperty, mr = Object.defineProperties, gr = Object.getOwnPropertyDescriptors, oa = Object.getOwnPropertySymbols, Go = Object.prototype.hasOwnProperty, Wo = Object.prototype.propertyIsEnumerable, Tl = (e, t, l) => t in e ? pr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, yr = (e, t) => {\n  for (var l in t || (t = {}))\n    Go.call(t, l) && Tl(e, l, t[l]);\n  if (oa)\n    for (var l of oa(t))\n      Wo.call(t, l) && Tl(e, l, t[l]);\n  return e;\n}, br = (e, t) => mr(e, gr(t)), hr = (e, t) => {\n  var l = {};\n  for (var a in e)\n    Go.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);\n  if (e != null && oa)\n    for (var a of oa(e))\n      t.indexOf(a) < 0 && Wo.call(e, a) && (l[a] = e[a]);\n  return l;\n};\nfunction Br(e, t, l = {}) {\n  const a = l, {\n    eventFilter: o\n  } = a, n = hr(a, [\n    \"eventFilter\"\n  ]), { eventFilter: s, pause: r, resume: i, isActive: v } = rr(o);\n  return { stop: vr(\n    e,\n    t,\n    br(yr({}, n), {\n      eventFilter: s\n    })\n  ), pause: r, resume: i, isActive: v };\n}\nfunction Ke(e) {\n  var t;\n  const l = ft(e);\n  return (t = l == null ? void 0 : l.$el) != null ? t : l;\n}\nconst Ze = la ? window : void 0;\nfunction we(...e) {\n  let t, l, a, o;\n  if (typeof e[0] == \"string\" || Array.isArray(e[0]) ? ([l, a, o] = e, t = Ze) : [t, l, a, o] = e, !t)\n    return Nt;\n  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);\n  const n = [], s = () => {\n    n.forEach((b) => b()), n.length = 0;\n  }, r = (b, h, p, B) => (b.addEventListener(h, p, B), () => b.removeEventListener(h, p, B)), i = oe(\n    () => [Ke(t), ft(o)],\n    ([b, h]) => {\n      s(), b && n.push(\n        ...l.flatMap((p) => a.map((B) => r(b, p, B, h)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), v = () => {\n    i(), s();\n  };\n  return ct(v), v;\n}\nlet Vl = !1;\nfunction Uo(e, t, l = {}) {\n  const { window: a = Ze, ignore: o = [], capture: n = !0, detectIframe: s = !1 } = l;\n  if (!a)\n    return;\n  Ca && !Vl && (Vl = !0, Array.from(a.document.body.children).forEach((p) => p.addEventListener(\"click\", Nt)));\n  let r = !0;\n  const i = (p) => o.some((B) => {\n    if (typeof B == \"string\")\n      return Array.from(a.document.querySelectorAll(B)).some((S) => S === p.target || p.composedPath().includes(S));\n    {\n      const S = Ke(B);\n      return S && (p.target === S || p.composedPath().includes(S));\n    }\n  }), b = [\n    we(a, \"click\", (p) => {\n      const B = Ke(e);\n      if (!(!B || B === p.target || p.composedPath().includes(B))) {\n        if (p.detail === 0 && (r = !i(p)), !r) {\n          r = !0;\n          return;\n        }\n        t(p);\n      }\n    }, { passive: !0, capture: n }),\n    we(a, \"pointerdown\", (p) => {\n      const B = Ke(e);\n      B && (r = !p.composedPath().includes(B) && !i(p));\n    }, { passive: !0 }),\n    s && we(a, \"blur\", (p) => {\n      setTimeout(() => {\n        var B;\n        const S = Ke(e);\n        ((B = a.document.activeElement) == null ? void 0 : B.tagName) === \"IFRAME\" && !(S != null && S.contains(a.document.activeElement)) && t(p);\n      }, 0);\n    })\n  ].filter(Boolean);\n  return () => b.forEach((p) => p());\n}\nfunction Sr() {\n  const e = R(!1);\n  return ia() && He(() => {\n    e.value = !0;\n  }), e;\n}\nfunction wr(e) {\n  const t = Sr();\n  return u(() => (t.value, !!e()));\n}\nfunction _r(e, t = {}) {\n  const { window: l = Ze } = t, a = wr(() => l && \"matchMedia\" in l && typeof l.matchMedia == \"function\");\n  let o;\n  const n = R(!1), s = () => {\n    o && (\"removeEventListener\" in o ? o.removeEventListener(\"change\", r) : o.removeListener(r));\n  }, r = () => {\n    a.value && (s(), o = l.matchMedia(Ja(e).value), n.value = !!(o != null && o.matches), o && (\"addEventListener\" in o ? o.addEventListener(\"change\", r) : o.addListener(r)));\n  };\n  return Ht(r), ct(() => s()), n;\n}\nfunction $r(e) {\n  return JSON.parse(JSON.stringify(e));\n}\nconst Gt = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {}, Wt = \"__vueuse_ssr_handlers__\", Cr = /* @__PURE__ */ kr();\nfunction kr() {\n  return Wt in Gt || (Gt[Wt] = Gt[Wt] || {}), Gt[Wt];\n}\nfunction Za(e, t) {\n  return Cr[e] || t;\n}\nfunction Tr(e) {\n  return e == null ? \"any\" : e instanceof Set ? \"set\" : e instanceof Map ? \"map\" : e instanceof Date ? \"date\" : typeof e == \"boolean\" ? \"boolean\" : typeof e == \"string\" ? \"string\" : typeof e == \"object\" ? \"object\" : Number.isNaN(e) ? \"any\" : \"number\";\n}\nvar Vr = Object.defineProperty, Al = Object.getOwnPropertySymbols, Ar = Object.prototype.hasOwnProperty, Or = Object.prototype.propertyIsEnumerable, Ol = (e, t, l) => t in e ? Vr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, Fl = (e, t) => {\n  for (var l in t || (t = {}))\n    Ar.call(t, l) && Ol(e, l, t[l]);\n  if (Al)\n    for (var l of Al(t))\n      Or.call(t, l) && Ol(e, l, t[l]);\n  return e;\n};\nconst Fr = {\n  boolean: {\n    read: (e) => e === \"true\",\n    write: (e) => String(e)\n  },\n  object: {\n    read: (e) => JSON.parse(e),\n    write: (e) => JSON.stringify(e)\n  },\n  number: {\n    read: (e) => Number.parseFloat(e),\n    write: (e) => String(e)\n  },\n  any: {\n    read: (e) => e,\n    write: (e) => String(e)\n  },\n  string: {\n    read: (e) => e,\n    write: (e) => String(e)\n  },\n  map: {\n    read: (e) => new Map(JSON.parse(e)),\n    write: (e) => JSON.stringify(Array.from(e.entries()))\n  },\n  set: {\n    read: (e) => new Set(JSON.parse(e)),\n    write: (e) => JSON.stringify(Array.from(e))\n  },\n  date: {\n    read: (e) => new Date(e),\n    write: (e) => e.toISOString()\n  }\n}, Pl = \"vueuse-storage\";\nfunction Pr(e, t, l, a = {}) {\n  var o;\n  const {\n    flush: n = \"pre\",\n    deep: s = !0,\n    listenToStorageChanges: r = !0,\n    writeDefaults: i = !0,\n    mergeDefaults: v = !1,\n    shallow: b,\n    window: h = Ze,\n    eventFilter: p,\n    onError: B = (V) => {\n      console.error(V);\n    }\n  } = a, S = (b ? xa : R)(t);\n  if (!l)\n    try {\n      l = Za(\"getDefaultStorage\", () => {\n        var V;\n        return (V = Ze) == null ? void 0 : V.localStorage;\n      })();\n    } catch (V) {\n      B(V);\n    }\n  if (!l)\n    return S;\n  const m = ft(t), A = Tr(m), y = (o = a.serializer) != null ? o : Fr[A], { pause: k, resume: w } = Br(\n    S,\n    () => _(S.value),\n    { flush: n, deep: s, eventFilter: p }\n  );\n  return h && r && (we(h, \"storage\", c), we(h, Pl, T)), c(), S;\n  function _(V) {\n    try {\n      if (V == null)\n        l.removeItem(e);\n      else {\n        const F = y.write(V), f = l.getItem(e);\n        f !== F && (l.setItem(e, F), h && h.dispatchEvent(new CustomEvent(Pl, {\n          detail: {\n            key: e,\n            oldValue: f,\n            newValue: F,\n            storageArea: l\n          }\n        })));\n      }\n    } catch (F) {\n      B(F);\n    }\n  }\n  function C(V) {\n    const F = V ? V.newValue : l.getItem(e);\n    if (F == null)\n      return i && m !== null && l.setItem(e, y.write(m)), m;\n    if (!V && v) {\n      const f = y.read(F);\n      return typeof v == \"function\" ? v(f, m) : A === \"object\" && !Array.isArray(f) ? Fl(Fl({}, m), f) : f;\n    } else\n      return typeof F != \"string\" ? F : y.read(F);\n  }\n  function T(V) {\n    c(V.detail);\n  }\n  function c(V) {\n    if (!(V && V.storageArea !== l)) {\n      if (V && V.key == null) {\n        S.value = m;\n        return;\n      }\n      if (!(V && V.key !== e)) {\n        k();\n        try {\n          S.value = C(V);\n        } catch (F) {\n          B(F);\n        } finally {\n          V ? Ce(w) : w();\n        }\n      }\n    }\n  }\n}\nfunction Er(e) {\n  return _r(\"(prefers-color-scheme: dark)\", e);\n}\nvar Ir = Object.defineProperty, El = Object.getOwnPropertySymbols, xr = Object.prototype.hasOwnProperty, Lr = Object.prototype.propertyIsEnumerable, Il = (e, t, l) => t in e ? Ir(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, Nr = (e, t) => {\n  for (var l in t || (t = {}))\n    xr.call(t, l) && Il(e, l, t[l]);\n  if (El)\n    for (var l of El(t))\n      Lr.call(t, l) && Il(e, l, t[l]);\n  return e;\n};\nfunction zr(e = {}) {\n  const {\n    selector: t = \"html\",\n    attribute: l = \"class\",\n    initialValue: a = \"auto\",\n    window: o = Ze,\n    storage: n,\n    storageKey: s = \"vueuse-color-scheme\",\n    listenToStorageChanges: r = !0,\n    storageRef: i,\n    emitAuto: v,\n    disableTransition: b = !0\n  } = e, h = Nr({\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\"\n  }, e.modes || {}), p = Er({ window: o }), B = u(() => p.value ? \"dark\" : \"light\"), S = i || (s == null ? Ja(a) : Pr(s, a, n, { window: o, listenToStorageChanges: r })), m = u(\n    () => S.value === \"auto\" ? B.value : S.value\n  ), A = Za(\n    \"updateHTMLAttrs\",\n    (_, C, T) => {\n      const c = typeof _ == \"string\" ? o == null ? void 0 : o.document.querySelector(_) : Ke(_);\n      if (!c)\n        return;\n      let V;\n      if (b) {\n        V = o.document.createElement(\"style\");\n        const F = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        V.appendChild(document.createTextNode(F)), o.document.head.appendChild(V);\n      }\n      if (C === \"class\") {\n        const F = T.split(/\\s/g);\n        Object.values(h).flatMap((f) => (f || \"\").split(/\\s/g)).filter(Boolean).forEach((f) => {\n          F.includes(f) ? c.classList.add(f) : c.classList.remove(f);\n        });\n      } else\n        c.setAttribute(C, T);\n      b && (o.getComputedStyle(V).opacity, document.head.removeChild(V));\n    }\n  );\n  function y(_) {\n    var C;\n    A(t, l, (C = h[_]) != null ? C : _);\n  }\n  function k(_) {\n    e.onChanged ? e.onChanged(_, y) : y(_);\n  }\n  oe(m, k, { flush: \"post\", immediate: !0 }), ir(() => k(m.value));\n  const w = u({\n    get() {\n      return v ? S.value : m.value;\n    },\n    set(_) {\n      S.value = _;\n    }\n  });\n  try {\n    return Object.assign(w, { store: S, system: B, state: m });\n  } catch {\n    return w;\n  }\n}\nfunction Ee(e, t = {}) {\n  const { initialValue: l = !1 } = t, a = R(!1), o = u(() => Ke(e));\n  we(o, \"focus\", () => a.value = !0), we(o, \"blur\", () => a.value = !1);\n  const n = u({\n    get: () => a.value,\n    set(s) {\n      var r, i;\n      !s && a.value ? (r = o.value) == null || r.blur() : s && !a.value && ((i = o.value) == null || i.focus());\n    }\n  });\n  return oe(\n    o,\n    () => {\n      n.value = l;\n    },\n    { immediate: !0, flush: \"post\" }\n  ), { focused: n };\n}\nconst Hr = {\n  page: (e) => [e.pageX, e.pageY],\n  client: (e) => [e.clientX, e.clientY],\n  screen: (e) => [e.screenX, e.screenY],\n  movement: (e) => e instanceof Touch ? null : [e.movementX, e.movementY]\n};\nfunction Rr(e = {}) {\n  const {\n    type: t = \"page\",\n    touch: l = !0,\n    resetOnTouchEnds: a = !1,\n    initialValue: o = { x: 0, y: 0 },\n    window: n = Ze,\n    target: s = n,\n    eventFilter: r\n  } = e, i = R(o.x), v = R(o.y), b = R(null), h = typeof t == \"function\" ? t : Hr[t], p = (y) => {\n    const k = h(y);\n    k && ([i.value, v.value] = k, b.value = \"mouse\");\n  }, B = (y) => {\n    if (y.touches.length > 0) {\n      const k = h(y.touches[0]);\n      k && ([i.value, v.value] = k, b.value = \"touch\");\n    }\n  }, S = () => {\n    i.value = o.x, v.value = o.y;\n  }, m = r ? (y) => r(() => p(y), {}) : (y) => p(y), A = r ? (y) => r(() => B(y), {}) : (y) => B(y);\n  return s && (we(s, \"mousemove\", m, { passive: !0 }), we(s, \"dragover\", m, { passive: !0 }), l && t !== \"movement\" && (we(s, \"touchstart\", A, { passive: !0 }), we(s, \"touchmove\", A, { passive: !0 }), a && we(s, \"touchend\", S, { passive: !0 }))), {\n    x: i,\n    y: v,\n    sourceType: b\n  };\n}\nfunction xl(e, t = {}) {\n  const {\n    handleOutside: l = !0,\n    window: a = Ze\n  } = t, { x: o, y: n, sourceType: s } = Rr(t), r = R(e ?? (a == null ? void 0 : a.document.body)), i = R(0), v = R(0), b = R(0), h = R(0), p = R(0), B = R(0), S = R(!0);\n  let m = () => {\n  };\n  return a && (m = oe(\n    [r, o, n],\n    () => {\n      const A = Ke(r);\n      if (!A)\n        return;\n      const {\n        left: y,\n        top: k,\n        width: w,\n        height: _\n      } = A.getBoundingClientRect();\n      b.value = y + a.pageXOffset, h.value = k + a.pageYOffset, p.value = _, B.value = w;\n      const C = o.value - b.value, T = n.value - h.value;\n      S.value = w === 0 || _ === 0 || C < 0 || T < 0 || C > w || T > _, (l || !S.value) && (i.value = C, v.value = T);\n    },\n    { immediate: !0 }\n  ), we(document, \"mouseleave\", () => {\n    S.value = !0;\n  })), {\n    x: o,\n    y: n,\n    sourceType: s,\n    elementX: i,\n    elementY: v,\n    elementPositionX: b,\n    elementPositionY: h,\n    elementHeight: p,\n    elementWidth: B,\n    isOutside: S,\n    stop: m\n  };\n}\nfunction Xo(e) {\n  const t = window.getComputedStyle(e);\n  if (t.overflowX === \"scroll\" || t.overflowY === \"scroll\" || t.overflowX === \"auto\" && e.clientWidth < e.scrollWidth || t.overflowY === \"auto\" && e.clientHeight < e.scrollHeight)\n    return !0;\n  {\n    const l = e.parentNode;\n    return !l || l.tagName === \"BODY\" ? !1 : Xo(l);\n  }\n}\nfunction Mr(e) {\n  const t = e || window.event, l = t.target;\n  return Xo(l) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1);\n}\nfunction Dr(e, t = !1) {\n  const l = R(t);\n  let a = null, o;\n  oe(Ja(e), (r) => {\n    if (r) {\n      const i = r;\n      o = i.style.overflow, l.value && (i.style.overflow = \"hidden\");\n    }\n  }, {\n    immediate: !0\n  });\n  const n = () => {\n    const r = ft(e);\n    !r || l.value || (Ca && (a = we(\n      r,\n      \"touchmove\",\n      (i) => {\n        Mr(i);\n      },\n      { passive: !1 }\n    )), r.style.overflow = \"hidden\", l.value = !0);\n  }, s = () => {\n    const r = ft(e);\n    !r || !l.value || (Ca && (a == null || a()), r.style.overflow = o, l.value = !1);\n  };\n  return ct(s), u({\n    get() {\n      return l.value;\n    },\n    set(r) {\n      r ? n() : s();\n    }\n  });\n}\nfunction jr(e, t = {}) {\n  const {\n    threshold: l = 50,\n    onSwipe: a,\n    onSwipeEnd: o,\n    onSwipeStart: n,\n    passive: s = !0,\n    window: r = Ze\n  } = t, i = St({ x: 0, y: 0 }), v = St({ x: 0, y: 0 }), b = u(() => i.x - v.x), h = u(() => i.y - v.y), { max: p, abs: B } = Math, S = u(() => p(B(b.value), B(h.value)) >= l), m = R(!1), A = u(() => S.value ? B(b.value) > B(h.value) ? b.value > 0 ? \"left\" : \"right\" : h.value > 0 ? \"up\" : \"down\" : \"none\"), y = (F) => [F.touches[0].clientX, F.touches[0].clientY], k = (F, f) => {\n    i.x = F, i.y = f;\n  }, w = (F, f) => {\n    v.x = F, v.y = f;\n  };\n  let _;\n  const C = qr(r == null ? void 0 : r.document);\n  s ? _ = C ? { passive: !0 } : { capture: !1 } : _ = C ? { passive: !1, capture: !0 } : { capture: !0 };\n  const T = (F) => {\n    m.value && (o == null || o(F, A.value)), m.value = !1;\n  }, c = [\n    we(e, \"touchstart\", (F) => {\n      if (F.touches.length !== 1)\n        return;\n      _.capture && !_.passive && F.preventDefault();\n      const [f, I] = y(F);\n      k(f, I), w(f, I), n == null || n(F);\n    }, _),\n    we(e, \"touchmove\", (F) => {\n      if (F.touches.length !== 1)\n        return;\n      const [f, I] = y(F);\n      w(f, I), !m.value && S.value && (m.value = !0), m.value && (a == null || a(F));\n    }, _),\n    we(e, \"touchend\", T, _),\n    we(e, \"touchcancel\", T, _)\n  ];\n  return {\n    isPassiveEventSupported: C,\n    isSwiping: m,\n    direction: A,\n    coordsStart: i,\n    coordsEnd: v,\n    lengthX: b,\n    lengthY: h,\n    stop: () => c.forEach((F) => F())\n  };\n}\nfunction qr(e) {\n  if (!e)\n    return !1;\n  let t = !1;\n  const l = {\n    get passive() {\n      return t = !0, !1;\n    }\n  };\n  return e.addEventListener(\"x\", Nt, l), e.removeEventListener(\"x\", Nt), t;\n}\nfunction Se(e, t, l, a = {}) {\n  var o, n, s;\n  const {\n    clone: r = !1,\n    passive: i = !1,\n    eventName: v,\n    deep: b = !1,\n    defaultValue: h,\n    shouldEmit: p\n  } = a, B = ia(), S = l || (B == null ? void 0 : B.emit) || ((o = B == null ? void 0 : B.$emit) == null ? void 0 : o.bind(B)) || ((s = (n = B == null ? void 0 : B.proxy) == null ? void 0 : n.$emit) == null ? void 0 : s.bind(B == null ? void 0 : B.proxy));\n  let m = v;\n  t || (t = \"modelValue\"), m = m || `update:${t.toString()}`;\n  const A = (w) => r ? typeof r == \"function\" ? r(w) : $r(w) : w, y = () => or(e[t]) ? A(e[t]) : h, k = (w) => {\n    p ? p(w) && S(m, w) : S(m, w);\n  };\n  if (i) {\n    const w = y(), _ = R(w);\n    return oe(\n      () => e[t],\n      (C) => _.value = A(C)\n    ), oe(\n      _,\n      (C) => {\n        (C !== e[t] || b) && k(C);\n      },\n      { deep: b }\n    ), _;\n  } else\n    return u({\n      get() {\n        return y();\n      },\n      set(w) {\n        k(w);\n      }\n    });\n}\nconst Qa = N({\n  name: \"ComponentOrEmpty\",\n  slots: Object,\n  props: {\n    tag: {\n      type: String,\n      default: \"div\"\n    },\n    to: {\n      type: [String, Object],\n      default: null\n    },\n    skip: {\n      type: Boolean,\n      default: !1\n    }\n  },\n  setup(e, { slots: t, attrs: l }) {\n    return () => {\n      var a, o, n;\n      return e.skip ? (a = t.default) == null ? void 0 : a.call(t) : e.tag === \"Teleport\" ? ie(Na, { to: e.to }, [(o = t.default) == null ? void 0 : o.call(t)]) : ie(e.tag, { ...l }, [(n = t.default) == null ? void 0 : n.call(t)]);\n    };\n  }\n}), Dt = (e) => Do(() => {\n  const t = Qe(e);\n  return t ? `justify-content-${t}` : \"\";\n});\nfunction d(e) {\n  return Do(() => {\n    const t = Qe(e);\n    return t == null ? t : Ra(t);\n  });\n}\nconst Ko = ar(() => {\n  const e = St([]);\n  return { items: e, reset: () => {\n    e.splice(0, e.length);\n  } };\n}), Gr = (e = {}) => {\n  const t = e.persist ?? !1, l = \"data-bs-theme\", a = \"body\";\n  return zr({\n    attribute: l,\n    selector: a,\n    storageKey: t === !0 ? `bv-color-${e.attribute ?? l}-${e.selector ?? a}` : null,\n    ...e\n  });\n}, Wr = (e, t = R(1e3), l = {}) => {\n  const a = ye(ke(e)), o = ye(ke(t)), n = R(!1), s = R(0), r = u(() => Math.ceil(a.value / o.value)), i = u(\n    () => h.value || n.value ? Math.round(a.value - s.value * o.value) : 0\n  ), { pause: v, resume: b, isActive: h } = qo(\n    () => {\n      s.value = s.value + 1;\n    },\n    t,\n    l\n  ), p = () => {\n    n.value = !1, s.value = 0, b();\n  }, B = () => {\n    n.value = !1, s.value = r.value;\n  };\n  Ht(() => {\n    s.value > r.value && (s.value = r.value), s.value === r.value && v();\n  }), oe([o, a], () => {\n    B(), p();\n  });\n  const S = () => {\n    h.value !== !1 && (n.value = !0, v());\n  }, m = () => {\n    s.value !== r.value && (n.value = !1, b());\n  };\n  return {\n    isActive: ye(h),\n    isPaused: ye(n),\n    restart: p,\n    stop: B,\n    pause: S,\n    resume: m,\n    value: i\n  };\n}, Yo = (e) => u(() => {\n  const t = Qe(e);\n  return {\n    \"form-check\": t.plain === !1 && t.button === !1,\n    \"form-check-inline\": t.inline === !0,\n    \"form-switch\": t.switch === !0,\n    [`form-control-${t.size}`]: t.size !== void 0 && t.size !== \"md\" && t.button === !1\n  };\n}), Jo = (e) => u(() => {\n  const t = Qe(e);\n  return {\n    \"form-check-input\": t.plain === !1 && t.button === !1,\n    \"is-valid\": t.state === !0,\n    \"is-invalid\": t.state === !1,\n    \"btn-check\": t.button === !0\n  };\n}), Zo = (e) => u(() => {\n  const t = Qe(e);\n  return {\n    \"form-check-label\": t.plain === !1 && t.button === !1,\n    btn: t.button === !0,\n    [`btn-${t.buttonVariant}`]: t.button === !0 && t.buttonVariant !== void 0 && t.buttonVariant !== null,\n    [`btn-${t.size}`]: t.button && t.size && t.size !== \"md\"\n  };\n}), Qo = (e) => u(() => {\n  const t = Qe(e);\n  return {\n    \"aria-invalid\": ca(t.ariaInvalid, t.state),\n    \"aria-required\": t.required === !0 ? !0 : void 0\n  };\n}), en = (e) => u(() => {\n  const t = Qe(e);\n  return {\n    \"was-validated\": t.validated === !0,\n    \"btn-group\": t.buttons === !0 && t.stacked === !1,\n    \"btn-group-vertical\": t.stacked === !0 && t.buttons === !0,\n    [`btn-group-${t.size}`]: t.size !== void 0\n  };\n}), tn = (e, t) => {\n  const l = R(null);\n  let a = null, o = !0;\n  const n = _e(() => e.id, \"input\"), s = d(() => e.autofocus), r = d(() => e.disabled), i = d(() => e.lazy), v = d(() => e.lazyFormatter), b = d(() => e.number);\n  d(() => e.plaintext), d(() => e.readonly), d(() => e.required);\n  const h = d(() => e.state), p = d(() => e.trim), { focused: B } = Ee(l, {\n    initialValue: s.value\n  }), S = (c, V, F = !1) => (c = String(c), typeof e.formatter == \"function\" && (!v.value || F) ? (o = !1, e.formatter(c, V)) : c), m = (c) => p.value ? c.trim() : b.value ? Number.parseFloat(c) : c, A = () => {\n    s.value && (B.value = !0);\n  };\n  He(() => {\n    l.value && (l.value.value = e.modelValue);\n  }), Mn(() => {\n    Ce(() => {\n      A();\n    });\n  });\n  const y = u(\n    () => ca(e.ariaInvalid, h.value)\n  ), k = (c) => {\n    const { value: V } = c.target, F = S(V, c);\n    if (F === !1 || c.defaultPrevented) {\n      c.preventDefault();\n      return;\n    }\n    if (i.value)\n      return;\n    const f = m(F);\n    e.modelValue !== f && (a = V, t(\"update:modelValue\", f)), t(\"input\", F);\n  }, w = (c) => {\n    const { value: V } = c.target, F = S(V, c);\n    if (F === !1 || c.defaultPrevented) {\n      c.preventDefault();\n      return;\n    }\n    if (!i.value)\n      return;\n    a = V, t(\"update:modelValue\", F);\n    const f = m(F);\n    e.modelValue !== f && t(\"change\", F);\n  }, _ = (c) => {\n    if (t(\"blur\", c), !i.value && !v.value)\n      return;\n    const { value: V } = c.target, F = S(V, c, !0);\n    a = V, t(\"update:modelValue\", F);\n  }, C = () => {\n    r.value || (B.value = !0);\n  }, T = () => {\n    var c;\n    r.value || (c = l.value) == null || c.blur();\n  };\n  return oe(\n    () => e.modelValue,\n    (c) => {\n      l.value && (l.value.value = a && o ? a : c, a = null, o = !0);\n    }\n  ), {\n    input: l,\n    computedId: n,\n    computedAriaInvalid: y,\n    onInput: k,\n    onChange: w,\n    onBlur: _,\n    focus: C,\n    blur: T\n  };\n}, mt = (e, t) => {\n  if (!e)\n    return e;\n  if (t in e)\n    return e[t];\n  const l = t.split(\".\");\n  return mt(e[l[0]], l.splice(1).join(\".\"));\n}, ga = (e, t = null, l, a) => {\n  if (Object.prototype.toString.call(e) === \"[object Object]\") {\n    const o = mt(e, a.valueField), n = mt(e, a.textField), s = mt(e, a.htmlField), r = mt(e, a.disabledField), i = e[a.optionsField] || null;\n    return i !== null ? {\n      label: String(mt(e, a.labelField) || n),\n      options: el(i, l, a)\n    } : {\n      value: typeof o > \"u\" ? t || n : o,\n      text: String(typeof n > \"u\" ? t : n),\n      html: s,\n      disabled: !!r\n    };\n  }\n  return {\n    value: t || e,\n    text: String(e),\n    disabled: !1\n  };\n}, el = (e, t, l) => Array.isArray(e) ? e.map((a) => ga(a, null, t, l)) : Object.prototype.toString.call(e) === \"[object Object]\" ? (console.warn(\n  `[BootstrapVue warn]: ${t} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`\n), Object.keys(e).map((a) => {\n  const o = e[a];\n  switch (typeof o) {\n    case \"object\":\n      return ga(o.text, String(o.value), t, l);\n    default:\n      return ga(o, String(a), t, l);\n  }\n})) : [], _e = (e, t) => u(() => Qe(e) || at(t)), ya = \"modal-open\", Ur = lr(() => {\n  const { count: e, inc: t, dec: l } = ur(), a = Za(\"updateHTMLAttrs\", (o, n, s) => {\n    const r = typeof o == \"string\" ? window == null ? void 0 : window.document.querySelector(o) : Ke(o);\n    r && (n === \"class\" ? r.classList.toggle(ya, s === ya) : r.setAttribute(n, s));\n  });\n  return ct(() => {\n    a(\"body\", \"class\", \"\");\n  }), oe(e, (o) => {\n    a(\"body\", \"class\", o > 0 ? ya : \"\");\n  }), { inc: t, dec: l };\n}), Xr = (e) => {\n  const { inc: t, dec: l } = Ur();\n  oe(\n    e,\n    (a, o) => {\n      a ? t() : o && !a && l();\n    },\n    { immediate: !0 }\n  );\n}, an = (e, t) => {\n  const l = ye(ke(e)), a = ye(ke(t)), o = u(() => !a.value), n = R(null);\n  He(() => {\n    n.value = document.body;\n  });\n  const s = Dr(n, l.value && o.value);\n  oe([l, o], ([r, i]) => {\n    s.value = r && i;\n  });\n}, Vt = (e) => u(() => {\n  const t = Qe(e);\n  return t === !0 ? \"is-valid\" : t === !1 ? \"is-invalid\" : null;\n}), Kr = (e, t, l, a, o) => {\n  if (e === void 0 || t === void 0 || l === void 0 || a === void 0)\n    return t ?? [];\n  const n = l;\n  return t.sort((s, r) => {\n    if (o !== void 0)\n      return o(s, r, l, a);\n    const i = (h) => typeof h == \"object\" ? JSON.stringify(h) : h;\n    return i(s[n]) > i(r[n]) ? a ? -1 : 1 : i(r[n]) > i(s[n]) ? a ? 1 : -1 : 0;\n  });\n}, Yr = (e, t, l) => e.filter(\n  (a) => Object.entries(a).filter((o) => {\n    const [n, s] = o;\n    return !s || n[0] === \"_\" || l && l.length > 0 && !l.includes(n) ? !1 : (typeof s == \"object\" ? JSON.stringify(Object.values(s)) : s.toString()).toLowerCase().includes(t.toLowerCase());\n  }).length > 0\n), Jr = (e, t, l, a) => {\n  let o = e.value;\n  return \"isFilterableTable\" in l && l.isFilterableTable.value === !0 && t.filter && (o = Yr(o, t.filter, t.filterable)), \"isSortable\" in l && l.isSortable.value === !0 && (o = Kr(\n    t.fields,\n    o,\n    a == null ? void 0 : a.value,\n    l.sortDescBoolean.value,\n    t.sortCompare\n  )), o;\n}, Zr = (e, t, l, a) => {\n  const o = R(), n = R(e.items ?? []), s = R([0, n.value.length]), r = u(() => {\n    const h = l.value ? n.value : t.requireItemsMapping.value ? Jr(n, e, t, a) : e.items ?? [];\n    if (l.value && !t.noProviderPagingBoolean.value)\n      return h;\n    if (e.perPage !== void 0) {\n      const p = ((e.currentPage ?? 0) - 1) * e.perPage, B = p + e.perPage > h.length ? h.length : p + e.perPage;\n      s.value = [p, B];\n    }\n    return h;\n  }), i = u(() => e.perPage === void 0 ? r.value : r.value.slice(s.value[0], s.value[1]));\n  return {\n    internalItems: n,\n    computedItems: r,\n    updateInternalItems: async (h) => {\n      try {\n        return n.value = h, n.value;\n      } catch {\n        return;\n      }\n    },\n    filteredHandler: o,\n    notifyFilteredItems: () => {\n      o.value && o.value(r.value);\n    },\n    computedDisplayItems: i\n  };\n}, Qr = [\"id\"], ei = [\"innerHTML\"], ti = [\"innerHTML\"], tl = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BPopover\",\n  props: {\n    modelValue: { type: [String, Boolean], default: !1 },\n    container: { default: void 0 },\n    target: { type: [Function, String, null], default: null },\n    reference: { type: [Function, String, null], default: null },\n    content: { default: void 0 },\n    id: { default: void 0 },\n    title: { default: void 0 },\n    delay: { default: () => ({ show: 100, hide: 300 }) },\n    click: { type: [String, Boolean], default: !1 },\n    manual: { type: [String, Boolean], default: !1 },\n    variant: { default: null },\n    offset: { default: null },\n    customClass: { default: \"\" },\n    placement: { default: \"top\" },\n    strategy: { default: \"absolute\" },\n    floatingMiddleware: { default: void 0 },\n    noFlip: { type: [String, Boolean], default: !1 },\n    noShift: { type: [String, Boolean], default: !1 },\n    noFade: { type: [String, Boolean], default: !1 },\n    noAutoClose: { type: [String, Boolean], default: !1 },\n    hide: { type: [String, Boolean], default: !0 },\n    realtime: { type: [String, Boolean], default: !1 },\n    inline: { type: [String, Boolean], default: !1 },\n    tooltip: { type: [String, Boolean], default: !1 },\n    html: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"update:modelValue\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = d(() => a.modelValue), n = R(o.value), s = R(o.value);\n    Ht(() => {\n      l(\"update:modelValue\", n.value);\n    }), oe(o, () => {\n      o.value !== n.value && (o.value ? x() : D(new Event(\"update:modelValue\")));\n    });\n    const r = _e(() => a.id, \"popover\"), i = d(() => a.click), v = d(() => a.manual), b = d(() => a.noShift), h = d(() => a.noFlip), p = d(() => a.noFade), B = d(() => a.noAutoClose), S = d(() => a.hide), m = d(() => a.realtime), A = d(() => a.inline), y = d(() => a.tooltip), k = d(() => a.html), w = R(!1), _ = R(null), C = R(null), T = R(null), c = R(null), V = R(null), F = (U) => {\n      if (typeof U == \"string\" || U instanceof HTMLElement)\n        return U;\n      if (typeof U == \"function\")\n        return U().$el ? U().$el : U();\n      if (typeof U < \"u\")\n        return U.$el;\n    }, f = (U) => {\n      if (U) {\n        if (typeof U == \"string\") {\n          const se = document.getElementById(U);\n          return se || void 0;\n        }\n        return U;\n      }\n    }, I = u(\n      () => a.title ? yt(a.title, gt) : \"\"\n    ), E = u(\n      () => a.content ? yt(a.content, gt) : \"\"\n    ), z = u(() => a.placement.startsWith(\"auto\")), Z = u(() => {\n      if (a.floatingMiddleware !== void 0)\n        return a.floatingMiddleware;\n      const U = typeof a.offset == \"number\" ? a.offset : y.value ? 0 : 10, se = [Fo(U)];\n      return h.value === !1 && !z.value && se.push(Oo()), z.value && se.push(\n        Is({\n          alignment: a.placement.split(\"-\")[1] || void 0\n        })\n      ), b.value === !1 && se.push(Po()), S.value === !0 && se.push(xs({ padding: 10 })), A.value === !0 && se.push(Ls()), se.push(js({ element: T, padding: 10 })), se;\n    }), te = u(\n      () => z.value ? void 0 : a.placement\n    ), { x: G, y: W, strategy: X, middlewareData: ve, placement: ge, update: pe } = Mo(C, _, {\n      placement: te,\n      middleware: Z,\n      strategy: a.strategy,\n      whileElementsMounted: (...U) => Ho(...U, { animationFrame: m.value })\n    }), me = R({ position: \"absolute\" });\n    oe(ve, () => {\n      var U;\n      if (S.value === !0 && ((U = ve.value.hide) != null && U.referenceHidden ? w.value = !0 : w.value = !1), ve.value.arrow) {\n        const { x: se, y: Ie } = ve.value.arrow;\n        me.value = {\n          position: \"absolute\",\n          top: Ie ? `${Ie}px` : \"\",\n          left: se ? `${se}px` : \"\"\n        };\n      }\n    });\n    const q = u(() => {\n      const U = y.value ? \"tooltip\" : \"popover\";\n      return [\n        U,\n        `b-${U}`,\n        {\n          [`b-${U}-${a.variant}`]: a.variant !== null,\n          show: n.value && !w.value,\n          \"pe-none\": !n.value,\n          fade: !p.value,\n          \"d-none\": !n.value && p.value,\n          [`${a.customClass}`]: a.customClass !== void 0,\n          [`bs-${U}-${li(ge.value)}`]: ge.value !== void 0\n        }\n      ];\n    }), { isOutside: Q } = xl(_), { isOutside: re } = xl(c), de = (U) => {\n      const se = U ?? new Event(\"click\");\n      n.value ? D(se) : x();\n    }, L = (U, se = {}) => new Rt(U, {\n      cancelable: !1,\n      target: _.value || null,\n      relatedTarget: null,\n      trigger: null,\n      ...se,\n      componentId: r.value\n    }), x = () => {\n      const U = L(\"show\", { cancelable: !0 });\n      if (l(\"show\", U), U.defaultPrevented) {\n        l(\"show-prevented\");\n        return;\n      }\n      s.value = !0, Ce(() => {\n        var se;\n        pe(), setTimeout(\n          () => {\n            pe(), n.value = !0, Ce(() => {\n              l(\"shown\", L(\"shown\"));\n            });\n          },\n          typeof a.delay == \"number\" ? a.delay : ((se = a.delay) == null ? void 0 : se.show) || 0\n        );\n      });\n    }, D = (U) => {\n      var et;\n      const se = L(\"hide\", { cancelable: !0 });\n      if (l(\"hide\", se), se.defaultPrevented) {\n        l(\"hide-prevented\");\n        return;\n      }\n      const Ie = typeof a.delay == \"number\" ? a.delay : ((et = a.delay) == null ? void 0 : et.hide) || 100;\n      setTimeout(() => {\n        var tt;\n        (U == null ? void 0 : U.type) === \"click\" || (U == null ? void 0 : U.type) === \"update:modelValue\" && v.value || Q.value && re.value && !((tt = _.value) != null && tt.contains(document == null ? void 0 : document.activeElement)) ? (n.value = !1, Ce(() => {\n          setTimeout(\n            () => {\n              s.value = !1;\n            },\n            _.value ? ha(_.value) : 150\n          ), l(\"hidden\", L(\"hidden\"));\n        })) : setTimeout(() => {\n          D(U);\n        }, Ie);\n      }, Ie);\n    };\n    t({\n      hideFn: D,\n      show: x,\n      toggle: de\n    });\n    const ae = () => {\n      var U;\n      if (a.target) {\n        const se = f(F(a.target));\n        se ? c.value = se : console.warn(\"Target element not found\", a.target);\n      } else\n        c.value = (U = V.value) == null ? void 0 : U.nextElementSibling;\n      if (a.reference) {\n        const se = f(F(a.reference));\n        se ? C.value = se : console.warn(\"Reference element not found\", a.reference);\n      } else\n        C.value = c.value;\n      !c.value || v.value || ja && (i.value && c.value.addEventListener(\"click\", de), !i.value && c.value.addEventListener(\"pointerenter\", x), !i.value && c.value.addEventListener(\"pointerleave\", D), !i.value && c.value.addEventListener(\"focus\", x), !i.value && c.value.addEventListener(\"blur\", D));\n    }, ue = () => {\n      c.value && (c.value.removeEventListener(\"click\", de), c.value.removeEventListener(\"pointerenter\", x), c.value.removeEventListener(\"pointerleave\", D), c.value.removeEventListener(\"focus\", x), c.value.removeEventListener(\"blur\", D));\n    };\n    return Uo(\n      _,\n      () => {\n        n.value && i.value && !B.value && !v.value && D(new Event(\"clickOutside\"));\n      },\n      { ignore: [c] }\n    ), oe([() => a.click, () => a.target, () => a.reference], () => {\n      ue(), ae();\n    }), He(ae), ro(ue), (U, se) => (g(), P(ce, null, [\n      K(\"span\", {\n        ref_key: \"placeholder\",\n        ref: V\n      }, null, 512),\n      O(U.$slots, \"target\", Be(Ve({ show: x, hide: D, toggle: de, showState: n.value }))),\n      be(Qa, {\n        tag: \"Teleport\",\n        to: U.container,\n        skip: !U.container\n      }, {\n        default: j(() => [\n          s.value ? (g(), P(\"div\", ee({\n            key: 0,\n            id: U.id\n          }, U.$attrs, {\n            ref_key: \"element\",\n            ref: _,\n            class: q.value,\n            role: \"tooltip\",\n            tabindex: \"-1\",\n            style: {\n              position: $(X),\n              top: `${$(W)}px`,\n              left: `${$(G)}px`,\n              width: \"max-content\"\n            }\n          }), [\n            K(\"div\", {\n              ref_key: \"arrow\",\n              ref: T,\n              class: H(`${$(y) ? \"tooltip\" : \"popover\"}-arrow`),\n              style: ze(me.value),\n              \"data-popper-arrow\": \"\"\n            }, null, 6),\n            U.title || U.$slots.title ? (g(), P(ce, { key: 0 }, [\n              $(k) ? (g(), P(\"div\", {\n                key: 1,\n                class: H($(y) ? \"tooltip-inner\" : \"popover-header\"),\n                innerHTML: I.value\n              }, null, 10, ei)) : (g(), P(\"div\", {\n                key: 0,\n                class: H($(y) ? \"tooltip-inner\" : \"popover-header\")\n              }, [\n                O(U.$slots, \"title\", {}, () => [\n                  ne(Y(U.title), 1)\n                ])\n              ], 2))\n            ], 64)) : J(\"\", !0),\n            $(y) && !U.$slots.title && !U.title || !$(y) ? (g(), P(ce, { key: 1 }, [\n              $(k) ? (g(), P(\"div\", {\n                key: 1,\n                class: H($(y) ? \"tooltip-inner\" : \"popover-body\"),\n                innerHTML: E.value\n              }, null, 10, ti)) : (g(), P(\"div\", {\n                key: 0,\n                class: H($(y) ? \"tooltip-inner\" : \"popover-body\")\n              }, [\n                O(U.$slots, \"default\", {}, () => [\n                  ne(Y(U.content), 1)\n                ])\n              ], 2))\n            ], 64)) : J(\"\", !0)\n          ], 16, Qr)) : J(\"\", !0)\n        ]),\n        _: 3\n      }, 8, [\"to\", \"skip\"])\n    ], 64));\n  }\n}), ai = ({\n  top: e,\n  end: t,\n  start: l,\n  alignCenter: a,\n  alignEnd: o\n}) => {\n  const n = e ? \"top\" : l ? \"left\" : t ? \"right\" : \"bottom\", s = o ? \"end\" : a ? null : \"start\";\n  return `${n}${s ? `-${s}` : \"\"}`;\n}, li = (e) => {\n  const [t] = e.split(\"-\");\n  switch (t) {\n    case \"left\":\n      return \"start\";\n    case \"right\":\n      return \"end\";\n    default:\n      return t;\n  }\n}, zt = (e) => typeof e != \"object\" || e.active !== !1, na = (e, t) => {\n  if (!zt(e))\n    return {};\n  const a = typeof e > \"u\" || typeof e == \"object\" && !e.title && !e.content, o = t.getAttribute(\"title\") || t.getAttribute(\"data-original-title\");\n  return a ? o ? (t.removeAttribute(\"title\"), t.setAttribute(\"data-original-title\", o), {\n    content: yt(o, gt)\n  }) : (console.warn(\n    \"Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \\\"my title\\\"}'` nor `v-b-tooltip=\\\"'my title'\\\"` to define a title\"\n  ), {}) : typeof e == \"string\" ? {\n    content: yt(e, gt)\n  } : {\n    title: e != null && e.title ? yt(e == null ? void 0 : e.title, gt) : void 0,\n    content: e != null && e.content ? yt(e == null ? void 0 : e.content, gt) : void 0\n  };\n}, sa = (e, t) => ({\n  target: () => t,\n  modelValue: e.modifiers.show,\n  inline: e.modifiers.inline,\n  click: e.modifiers.click,\n  realtime: e.modifiers.realtime,\n  placement: e.modifiers.left ? \"left\" : e.modifiers.right ? \"right\" : e.modifiers.bottom ? \"bottom\" : e.modifiers.top ? \"top\" : void 0,\n  html: !0,\n  ...typeof e.value == \"object\" ? e.value : {},\n  title: null,\n  content: null\n}), ln = (e, t) => {\n  var a;\n  const l = document.createElement(\"span\");\n  t.modifiers.body ? document.body.appendChild(l) : t.modifiers.child ? e.appendChild(l) : (a = e.parentNode) == null || a.insertBefore(l, e.nextSibling), e.$__app = Dn({ render: () => {\n    var o;\n    return ie(tl, { ...(o = e.$__state) == null ? void 0 : o.value });\n  } }), e.$__app.mount(l), e.$__element = l;\n}, on = (e) => {\n  var l;\n  const t = e.$__element;\n  (l = e.$__app) == null || l.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {\n    t == null || t.remove();\n  }, 0), delete e.$__element;\n}, Ll = (e, t) => {\n  const { all: l, ...a } = e, o = {};\n  l && t.forEach((s) => {\n    o[s] = l;\n  });\n  const n = { ...o, ...a };\n  return Object.entries(n).filter(([s, r]) => !!r && t.includes(s)).map(([s]) => s);\n}, oi = [\"id\"], ni = /* @__PURE__ */ N({\n  __name: \"BAccordion\",\n  props: {\n    flush: { type: [String, Boolean], default: !1 },\n    free: { type: [String, Boolean], default: !1 },\n    id: { default: void 0 },\n    modelValue: { default: void 0 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(e, { emit: t }) {\n    const l = e, a = Se(l, \"modelValue\", t, { passive: !0 }), o = _e(() => l.id, \"accordion\"), n = d(() => l.flush), s = d(() => l.free), r = u(() => ({\n      \"accordion-flush\": n.value\n    }));\n    return De($o, {\n      openItem: ye(a),\n      free: s,\n      setOpenItem: (i) => {\n        a.value = i;\n      }\n    }), (i, v) => (g(), P(\"div\", {\n      id: $(o),\n      class: H([\"accordion\", r.value])\n    }, [\n      O(i.$slots, \"default\")\n    ], 10, oi));\n  }\n}), nn = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BCollapse\",\n  props: {\n    id: { default: void 0 },\n    modelValue: { type: [String, Boolean], default: !1 },\n    tag: { default: \"div\" },\n    toggle: { type: [String, Boolean], default: !1 },\n    horizontal: { type: [String, Boolean], default: !1 },\n    visible: { type: [String, Boolean], default: !1 },\n    isNav: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"update:modelValue\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = (C, T = {}) => new Rt(C, {\n      cancelable: !1,\n      target: p.value || null,\n      relatedTarget: null,\n      trigger: null,\n      ...T,\n      componentId: h.value\n    }), n = Se(a, \"modelValue\", l, { passive: !0 }), s = d(n), r = d(() => a.toggle), i = d(() => a.horizontal), v = d(() => a.isNav), b = d(() => a.visible), h = _e(() => a.id, \"collapse\"), p = R(null), B = R(!1), S = R(s.value), m = u(() => ({\n      show: S.value,\n      \"navbar-collapse\": v.value,\n      collapsing: B.value,\n      closing: S.value && !s.value,\n      \"collapse-horizontal\": i.value\n    })), A = () => {\n      n.value = !1;\n    }, y = () => {\n      n.value = !0;\n    }, k = () => {\n      n.value = !s.value;\n    }, w = () => {\n      S.value = !0, B.value = !0;\n      const C = o(\"show\", { cancelable: !0 });\n      if (l(\"show\", C), C.defaultPrevented) {\n        l(\"show-prevented\");\n        return;\n      }\n      Ce(() => {\n        p.value !== null && (i.value ? p.value.style.width = `${p.value.scrollWidth}px` : p.value.style.height = `${p.value.scrollHeight}px`, setTimeout(() => {\n          B.value = !1, l(\"shown\", o(\"shown\")), p.value !== null && (p.value.style.height = \"\", p.value.style.width = \"\");\n        }, ha(p.value)));\n      });\n    }, _ = () => {\n      const C = o(\"hide\", { cancelable: !0 });\n      if (l(\"hide\", C), C.defaultPrevented) {\n        l(\"hide-prevented\");\n        return;\n      }\n      p.value !== null && (i.value ? p.value.style.width = `${p.value.scrollWidth}px` : p.value.style.height = `${p.value.scrollHeight}px`, p.value.offsetHeight, B.value = !0, Ce(() => {\n        p.value !== null && (p.value.style.height = \"\", p.value.style.width = \"\", setTimeout(() => {\n          S.value = !1, B.value = !1, l(\"hidden\", o(\"hidden\"));\n        }, ha(p.value)));\n      }));\n    };\n    return oe([n, S], () => {\n      if (s.value === !0) {\n        if (S.value)\n          return;\n        w();\n        return;\n      }\n      _();\n    }), He(() => {\n      p.value !== null && !s.value && r.value && Ce(() => {\n        n.value = !0;\n      });\n    }), b.value && (n.value = !0, S.value = !0), oe(b, (C) => {\n      C ? y() : A();\n    }), we(p, \"bv-toggle\", () => {\n      n.value = !s.value;\n    }), t({\n      close: A,\n      open: y,\n      toggle: k,\n      visible: ye(S),\n      isNav: v\n    }), De(Ga, {\n      id: h,\n      close: A,\n      open: y,\n      toggle: k,\n      visible: ye(S),\n      isNav: v\n    }), (C, T) => (g(), P(ce, null, [\n      O(C.$slots, \"header\", Be(Ve({ visible: $(s), toggle: k, open: y, close: A, id: $(h) }))),\n      (g(), M(le(C.tag), ee({\n        id: $(h),\n        ref_key: \"element\",\n        ref: p,\n        class: [\"collapse\", m.value],\n        \"is-nav\": $(v)\n      }, C.$attrs), {\n        default: j(() => [\n          O(C.$slots, \"default\", Be(Ve({ visible: $(s), toggle: C.toggle, open: y, close: A })))\n        ]),\n        _: 3\n      }, 16, [\"id\", \"class\", \"is-nav\"])),\n      O(C.$slots, \"footer\", Be(Ve({ visible: $(s), toggle: k, open: y, close: A, id: $(h) })))\n    ], 64));\n  }\n}), si = { class: \"accordion-item\" }, ri = [\"aria-expanded\", \"aria-controls\", \"onClick\"], ii = { class: \"accordion-body\" }, ui = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BAccordionItem\",\n  props: {\n    id: { default: void 0 },\n    title: { default: void 0 },\n    modelValue: { type: [String, Boolean], default: !1 },\n    headerTag: { default: \"h2\" },\n    tag: { default: void 0 },\n    toggle: { type: [String, Boolean], default: void 0 },\n    horizontal: { type: [String, Boolean], default: void 0 },\n    visible: { type: [String, Boolean], default: !1 },\n    isNav: { type: [String, Boolean], default: void 0 }\n  },\n  emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"update:modelValue\"],\n  setup(e, { emit: t }) {\n    const l = e, a = {\n      show: (r) => t(\"show\", r),\n      shown: (r) => t(\"shown\", r),\n      hide: (r) => t(\"hide\", r),\n      hidden: (r) => t(\"hidden\", r),\n      \"hide-prevented\": () => t(\"hide-prevented\"),\n      \"show-prevented\": () => t(\"show-prevented\")\n    }, o = Se(l, \"modelValue\", t, { passive: !0 }), n = Oe($o, null), s = _e(() => l.id, \"accordion_item\");\n    return He(() => {\n      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value)), !o.value && (n == null ? void 0 : n.openItem.value) === s.value && (o.value = !0);\n    }), oe(\n      () => n == null ? void 0 : n.openItem.value,\n      () => o.value = (n == null ? void 0 : n.openItem.value) === s.value && !(n != null && n.free.value)\n    ), oe(o, () => {\n      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value));\n    }), (r, i) => (g(), P(\"div\", si, [\n      be(nn, ee({\n        id: $(s),\n        modelValue: $(o),\n        \"onUpdate:modelValue\": i[0] || (i[0] = (v) => La(o) ? o.value = v : null),\n        class: \"accordion-collapse\"\n      }, r.$attrs, {\n        \"aria-labelledby\": `${$(s)}-heading`,\n        tag: r.tag,\n        toggle: r.toggle,\n        horizontal: r.horizontal,\n        visible: r.visible,\n        \"is-nav\": r.isNav\n      }, io(a)), {\n        header: j(({ visible: v, toggle: b }) => [\n          (g(), M(le(r.headerTag), {\n            id: `${$(s)}-heading`,\n            class: \"accordion-header\"\n          }, {\n            default: j(() => [\n              K(\"button\", {\n                class: H([\"accordion-button\", { collapsed: !v }]),\n                type: \"button\",\n                \"aria-expanded\": v ? \"true\" : \"false\",\n                \"aria-controls\": $(s),\n                onClick: b\n              }, [\n                O(r.$slots, \"title\", {}, () => [\n                  ne(Y(r.title), 1)\n                ])\n              ], 10, ri)\n            ]),\n            _: 2\n          }, 1032, [\"id\"]))\n        ]),\n        default: j(() => [\n          K(\"div\", ii, [\n            O(r.$slots, \"default\")\n          ])\n        ]),\n        _: 3\n      }, 16, [\"id\", \"modelValue\", \"aria-labelledby\", \"tag\", \"toggle\", \"horizontal\", \"visible\", \"is-nav\"])\n    ]));\n  }\n}), At = /* @__PURE__ */ N({\n  __name: \"BTransition\",\n  props: {\n    appear: { type: [String, Boolean], default: !1 },\n    mode: { default: void 0 },\n    noFade: { type: [String, Boolean], default: !1 },\n    transProps: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.appear), a = d(() => t.noFade), o = u(() => {\n      const r = {\n        name: \"\",\n        enterActiveClass: \"\",\n        enterToClass: \"\",\n        leaveActiveClass: \"\",\n        leaveToClass: \"showing\",\n        enterFromClass: \"showing\",\n        leaveFromClass: \"\"\n      }, i = {\n        ...r,\n        enterActiveClass: \"fade showing\",\n        leaveActiveClass: \"fade showing\"\n      };\n      return a.value ? r : i;\n    }), n = u(() => ({ mode: t.mode, css: !0, ...o.value })), s = u(\n      () => t.transProps !== void 0 ? {\n        // Order matters here since the props.transProps would get overwritten if it came first\n        // But the goal of props.transProps is to overwrite base properties\n        ...n.value,\n        ...t.transProps\n      } : l.value ? {\n        ...n.value,\n        appear: !0,\n        appearActiveClass: o.value.enterActiveClass,\n        appearToClass: o.value.enterToClass\n      } : n.value\n    );\n    return (r, i) => (g(), M(jn, Be(Ve(s.value)), {\n      default: j(() => [\n        O(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nconst di = [\"type\", \"disabled\", \"aria-label\"], Ot = /* @__PURE__ */ N({\n  __name: \"BCloseButton\",\n  props: {\n    ariaLabel: { default: \"Close\" },\n    disabled: { type: [String, Boolean], default: !1 },\n    white: { type: [String, Boolean], default: !1 },\n    type: { default: \"button\" }\n  },\n  emits: [\"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.disabled), o = d(() => l.white), n = u(() => ({\n      \"btn-close-white\": o.value\n    }));\n    return (s, r) => (g(), P(\"button\", {\n      type: s.type,\n      class: H([\"btn-close\", n.value]),\n      disabled: $(a),\n      \"aria-label\": s.ariaLabel,\n      onClick: r[0] || (r[0] = (i) => t(\"click\", i))\n    }, null, 10, di));\n  }\n}), ci = {\n  key: 0,\n  class: \"visually-hidden\"\n}, pa = /* @__PURE__ */ N({\n  __name: \"BSpinner\",\n  props: {\n    label: { default: void 0 },\n    role: { default: \"status\" },\n    small: { type: [String, Boolean], default: !1 },\n    tag: { default: \"span\" },\n    type: { default: \"border\" },\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = Fe(), a = d(() => t.small), o = u(() => ({\n      \"spinner-border\": t.type === \"border\",\n      \"spinner-border-sm\": t.type === \"border\" && a.value,\n      \"spinner-grow\": t.type === \"grow\",\n      \"spinner-grow-sm\": t.type === \"grow\" && a.value,\n      [`text-${t.variant}`]: t.variant !== null\n    })), n = u(() => !Ae(l.label));\n    return (s, r) => (g(), M(le(s.tag), {\n      class: H(o.value),\n      role: s.label || n.value ? s.role : null,\n      \"aria-hidden\": s.label || n.value ? null : !0\n    }, {\n      default: j(() => [\n        s.label || n.value ? (g(), P(\"span\", ci, [\n          O(s.$slots, \"label\", {}, () => [\n            ne(Y(s.label), 1)\n          ])\n        ])) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"class\", \"role\", \"aria-hidden\"]));\n  }\n}), fi = {\n  active: { type: [Boolean, String, void 0], default: void 0 },\n  activeClass: { type: String, default: \"router-link-active\" },\n  append: { type: [Boolean, String], default: !1 },\n  disabled: { type: [Boolean, String], default: !1 },\n  event: { type: [String, Array], default: \"click\" },\n  href: { type: String },\n  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n  rel: { type: String, default: null },\n  replace: { type: [Boolean, String], default: !1 },\n  routerComponentName: { type: String, default: \"router-link\" },\n  routerTag: { type: String, default: \"a\" },\n  target: { type: String, default: \"_self\" },\n  to: { type: [String, Object], default: null },\n  variant: { type: String, default: null }\n}, Xe = /* @__PURE__ */ N({\n  __name: \"BLink\",\n  props: {\n    active: { type: [String, Boolean], default: void 0 },\n    activeClass: { default: \"router-link-active\" },\n    append: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    event: { default: \"click\" },\n    href: { default: void 0 },\n    rel: { default: void 0 },\n    replace: { type: [String, Boolean], default: !1 },\n    routerComponentName: { default: \"router-link\" },\n    routerTag: { default: \"a\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    variant: { default: null },\n    opacity: { default: void 0 },\n    opacityHover: { default: void 0 },\n    underlineVariant: { default: null },\n    underlineOffset: { default: void 0 },\n    underlineOffsetHover: { default: void 0 },\n    underlineOpacity: { default: void 0 },\n    underlineOpacityHover: { default: void 0 },\n    icon: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = za(), o = d(() => l.active), n = d(() => l.icon);\n    d(() => l.append);\n    const s = d(() => l.disabled);\n    d(() => l.replace);\n    const r = Oe(Ga, null), i = Oe(Wa, null), v = () => {\n      var y;\n      i !== null && ((y = r == null ? void 0 : r.close) == null || y.call(r));\n    }, b = ia(), h = u(() => {\n      const y = l.routerComponentName.split(\"-\").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(\"\");\n      return !((b == null ? void 0 : b.appContext.app.component(y)) !== void 0) || s.value || !l.to ? \"a\" : l.routerComponentName;\n    }), p = u(() => {\n      const y = \"#\";\n      if (l.href)\n        return l.href;\n      if (typeof l.to == \"string\")\n        return l.to || y;\n      const k = l.to;\n      if (Object.prototype.toString.call(k) === \"[object Object]\" && (k.path || k.query || k.hash)) {\n        const w = k.path || \"\", _ = k.query ? `?${Object.keys(k.query).map((T) => `${T}=${k.query[T]}`).join(\"=\")}` : \"\", C = !k.hash || k.hash.charAt(0) === \"#\" ? k.hash || \"\" : `#${k.hash}`;\n        return `${w}${_}${C}` || y;\n      }\n      return y;\n    }), B = u(() => ({\n      [`link-${l.variant}`]: l.variant !== null,\n      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,\n      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,\n      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,\n      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,\n      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,\n      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,\n      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,\n      \"icon-link\": n.value === !0\n    })), S = u(() => ({\n      class: B.value,\n      to: l.to,\n      href: p.value,\n      target: l.target,\n      rel: l.target === \"_blank\" && l.rel === void 0 ? \"noopener\" : l.rel || void 0,\n      tabindex: s.value ? \"-1\" : typeof a.tabindex > \"u\" ? null : a.tabindex,\n      \"aria-disabled\": s.value ? !0 : null\n    })), m = u(() => ({\n      [l.activeClass]: o.value,\n      disabled: s.value\n    })), A = (y) => {\n      var k;\n      if (s.value) {\n        y.preventDefault(), y.stopImmediatePropagation();\n        return;\n      }\n      (k = r == null ? void 0 : r.close) == null || k.call(r), t(\"click\", y);\n    };\n    return (y, k) => h.value === \"router-link\" ? (g(), M(le(h.value), ee({ key: 0 }, S.value, { custom: \"\" }), {\n      default: j(({ href: w, navigate: _, isActive: C }) => [\n        (g(), M(le(y.routerTag), ee({\n          href: w,\n          class: [($(o) ?? C) && y.activeClass]\n        }, y.$attrs, {\n          onClick: (T) => {\n            _(T), v(), A(T);\n          }\n        }), {\n          default: j(() => [\n            O(y.$slots, \"default\")\n          ]),\n          _: 2\n        }, 1040, [\"href\", \"class\", \"onClick\"]))\n      ]),\n      _: 3\n    }, 16)) : (g(), M(le(h.value), ee({\n      key: 1,\n      class: m.value\n    }, S.value, { onClick: A }), {\n      default: j(() => [\n        O(y.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"class\"]));\n  }\n}), kt = /* @__PURE__ */ N({\n  __name: \"BButton\",\n  props: {\n    pill: { type: [String, Boolean], default: !1 },\n    pressed: { type: [String, Boolean], default: void 0 },\n    size: { default: \"md\" },\n    squared: { type: [String, Boolean], default: !1 },\n    tag: { default: \"button\" },\n    type: { default: \"button\" },\n    variant: { default: \"secondary\" },\n    loading: { type: [String, Boolean], default: !1 },\n    loadingMode: { default: \"inline\" },\n    block: { type: [String, Boolean], default: !1 },\n    active: { type: [String, Boolean], default: !1 },\n    activeClass: { default: \"router-link-active\" },\n    append: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    event: { default: \"click\" },\n    href: { default: void 0 },\n    rel: { default: void 0 },\n    replace: { type: [String, Boolean], default: !1 },\n    routerComponentName: { default: \"router-link\" },\n    routerTag: { default: \"a\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    opacity: { default: void 0 },\n    opacityHover: { default: void 0 },\n    underlineVariant: { default: null },\n    underlineOffset: { default: void 0 },\n    underlineOffsetHover: { default: void 0 },\n    underlineOpacity: { default: void 0 },\n    underlineOpacityHover: { default: void 0 },\n    icon: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"click\", \"update:pressed\"],\n  setup(e, { emit: t }) {\n    const l = e, a = Se(l, \"pressed\", t), o = d(() => l.active), n = d(() => l.block), s = d(() => l.disabled), r = d(() => l.pill), i = d(() => l.pressed), v = d(() => l.squared), b = d(() => l.loading), h = u(() => typeof i.value == \"boolean\"), p = u(\n      () => l.tag === \"button\" && l.href === void 0 && l.to === void 0\n    ), B = u(() => wt(l)), S = u(() => l.to !== void 0), m = u(() => l.href !== void 0 ? !1 : !p.value), A = u(() => [\n      [`btn-${l.size}`],\n      {\n        [`btn-${l.variant}`]: l.variant !== null,\n        \"btn-block\": n.value,\n        active: o.value || i.value,\n        \"rounded-pill\": r.value,\n        \"rounded-0\": v.value,\n        disabled: s.value\n      }\n    ]), y = u(() => ({\n      \"aria-disabled\": m.value ? s.value : null,\n      \"aria-pressed\": h.value ? i.value : null,\n      autocomplete: h.value ? \"off\" : null,\n      disabled: p.value ? s.value : null,\n      href: l.href,\n      rel: B.value ? l.rel : null,\n      role: m.value || B.value ? \"button\" : null,\n      target: B.value ? l.target : null,\n      type: p.value ? l.type : null,\n      to: p.value ? null : l.to,\n      append: B.value ? l.append : null,\n      activeClass: S.value ? l.activeClass : null,\n      event: S.value ? l.event : null,\n      replace: S.value ? l.replace : null,\n      routerComponentName: S.value ? l.routerComponentName : null,\n      routerTag: S.value ? l.routerTag : null\n    })), k = u(\n      () => S.value ? Xe : l.href ? \"a\" : l.tag\n    ), w = (_) => {\n      if (s.value) {\n        _.preventDefault(), _.stopPropagation();\n        return;\n      }\n      t(\"click\", _), h.value && (a.value = !i.value);\n    };\n    return (_, C) => (g(), M(le(k.value), ee({\n      class: [\"btn\", A.value]\n    }, y.value, { onClick: w }), {\n      default: j(() => [\n        $(b) ? (g(), P(\"div\", {\n          key: 0,\n          class: H([\"btn-loading\", { \"mode-fill\": _.loadingMode === \"fill\", \"mode-inline\": _.loadingMode === \"inline\" }])\n        }, [\n          O(_.$slots, \"loading\", {}, () => [\n            be(pa, {\n              class: \"btn-spinner\",\n              small: _.size !== \"lg\"\n            }, null, 8, [\"small\"])\n          ])\n        ], 2)) : J(\"\", !0),\n        K(\"div\", {\n          class: H([\"btn-content\", { \"btn-loading-fill\": $(b) && _.loadingMode === \"fill\" }])\n        }, [\n          O(_.$slots, \"default\")\n        ], 2)\n      ]),\n      _: 3\n    }, 16, [\"class\"]));\n  }\n}), vi = [\"onMouseenter\"], pi = /* @__PURE__ */ N({\n  __name: \"BAlert\",\n  props: {\n    noHoverPause: { type: [String, Boolean], default: !1 },\n    dismissLabel: { default: \"Close\" },\n    dismissible: { type: [String, Boolean], default: !1 },\n    fade: { type: [String, Boolean], default: !1 },\n    closeVariant: { default: \"secondary\" },\n    modelValue: { type: [Boolean, Number], default: !1 },\n    variant: { default: \"info\" },\n    closeContent: { default: void 0 },\n    immediate: { type: [String, Boolean], default: !0 },\n    interval: { default: 1e3 },\n    showOnPause: { type: [String, Boolean], default: !0 }\n  },\n  emits: [\"closed\", \"close-countdown\", \"update:modelValue\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Fe(), n = Se(a, \"modelValue\", l), s = d(() => a.dismissible), r = d(() => a.fade), i = d(() => a.immediate), v = d(() => a.showOnPause), b = d(() => a.noHoverPause), h = u(() => !Ae(o.close)), p = u(\n      () => typeof n.value == \"boolean\" ? 0 : n.value\n    ), B = u(() => ({\n      [`alert-${a.variant}`]: a.variant !== null,\n      \"alert-dismissible\": s.value\n    })), {\n      isActive: S,\n      pause: m,\n      restart: A,\n      resume: y,\n      stop: k,\n      isPaused: w,\n      value: _\n    } = Wr(p, () => a.interval, {\n      immediate: typeof n.value == \"number\" && i.value\n    }), C = u(\n      () => typeof n.value == \"boolean\" ? n.value : S.value || v.value && w.value\n    ), T = u(() => ({\n      variant: a.closeVariant,\n      type: \"button\"\n    }));\n    Ht(() => l(\"close-countdown\", _.value));\n    const c = () => {\n      typeof n.value == \"boolean\" ? n.value = !1 : (n.value = 0, k()), l(\"closed\");\n    }, V = () => {\n      b.value || m();\n    };\n    return ro(k), t({ pause: m, resume: y, restart: A, stop: k }), (F, f) => (g(), M(At, {\n      \"no-fade\": !$(r),\n      \"trans-props\": { enterToClass: \"show\" }\n    }, {\n      default: j(() => [\n        C.value ? (g(), P(\"div\", {\n          key: 0,\n          class: H([\"alert\", B.value]),\n          role: \"alert\",\n          \"aria-live\": \"polite\",\n          \"aria-atomic\": \"true\",\n          onMouseenter: ot(V, [\"stop\"]),\n          onMouseleave: f[0] || (f[0] = ot(\n            //@ts-ignore\n            (...I) => $(y) && $(y)(...I),\n            [\"stop\"]\n          ))\n        }, [\n          O(F.$slots, \"default\"),\n          $(s) ? (g(), P(ce, { key: 0 }, [\n            h.value || F.closeContent ? (g(), M(kt, ee({ key: 0 }, T.value, { onClick: c }), {\n              default: j(() => [\n                O(F.$slots, \"close\", {}, () => [\n                  ne(Y(F.closeContent), 1)\n                ])\n              ]),\n              _: 3\n            }, 16)) : (g(), M(Ot, ee({\n              key: 1,\n              \"aria-label\": F.dismissLabel\n            }, T.value, { onClick: c }), null, 16, [\"aria-label\"]))\n          ], 64)) : J(\"\", !0)\n        ], 42, vi)) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"no-fade\"]));\n  }\n}), mi = {\n  key: 0,\n  class: \"b-avatar-custom\"\n}, gi = {\n  key: 1,\n  class: \"b-avatar-img\"\n}, yi = [\"src\", \"alt\"], ka = (e) => {\n  const t = typeof e == \"string\" && co(e) ? Et(e, 0) : e;\n  return typeof t == \"number\" ? `${t}px` : t || null;\n}, bi = /* @__PURE__ */ N({\n  __name: \"BAvatar\",\n  props: {\n    alt: { default: \"avatar\" },\n    ariaLabel: { default: void 0 },\n    badge: { type: [Boolean, String], default: !1 },\n    badgeLeft: { type: [String, Boolean], default: !1 },\n    badgeOffset: { default: void 0 },\n    badgeTop: { type: [String, Boolean], default: !1 },\n    badgeVariant: { default: \"primary\" },\n    button: { type: [String, Boolean], default: !1 },\n    buttonType: { default: \"button\" },\n    disabled: { type: [String, Boolean], default: !1 },\n    icon: { type: [String, Boolean], default: void 0 },\n    rounded: { type: [Boolean, String], default: \"circle\" },\n    size: { default: void 0 },\n    square: { type: [String, Boolean], default: !1 },\n    src: { default: void 0 },\n    text: { default: void 0 },\n    textVariant: { default: null },\n    variant: { default: \"secondary\" },\n    active: { type: [String, Boolean], default: void 0 },\n    activeClass: { default: \"router-link-active\" },\n    append: { type: [String, Boolean], default: !1 },\n    href: { default: void 0 },\n    rel: { default: void 0 },\n    replace: { type: [String, Boolean], default: !1 },\n    routerComponentName: { default: \"router-link\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    opacity: { default: void 0 },\n    opacityHover: { default: void 0 },\n    underlineVariant: { default: null },\n    underlineOffset: { default: void 0 },\n    underlineOffsetHover: { default: void 0 },\n    underlineOpacity: { default: void 0 },\n    underlineOpacityHover: { default: void 0 }\n  },\n  emits: [\"click\", \"img-error\"],\n  setup(e, { emit: t }) {\n    const l = e, a = Fe(), o = Oe(_o, null), n = [\"sm\", null, \"lg\"], s = 0.4, r = s * 0.7, i = d(() => l.badgeLeft), v = d(() => l.badgeTop), b = d(() => l.button), h = d(() => l.disabled), p = d(() => l.square), B = u(() => !Ae(a.default)), S = u(() => !Ae(a.badge)), m = u(() => !!l.badge || l.badge === \"\" || S.value), A = u(() => wt(l)), y = u(\n      () => (o == null ? void 0 : o.size.value) ?? ka(l.size)\n    ), k = u(\n      () => (o == null ? void 0 : o.variant.value) ?? l.variant\n    ), w = u(() => (o == null ? void 0 : o.rounded.value) ?? l.rounded), _ = u(() => ({\n      type: b.value && !A.value ? l.buttonType : void 0,\n      \"aria-label\": l.ariaLabel || null,\n      disabled: h.value || null,\n      // Link props\n      ...A.value ? Mt(l, [\n        \"active\",\n        \"activeClass\",\n        \"append\",\n        \"href\",\n        \"rel\",\n        \"replace\",\n        \"routerComponentName\",\n        \"target\",\n        \"to\",\n        \"variant\",\n        \"opacity\",\n        \"opacityHover\",\n        \"underlineVariant\",\n        \"underlineOffset\",\n        \"underlineOffsetHover\",\n        \"underlineOpacity\",\n        \"underlineOpacityHover\"\n      ]) : {}\n    })), C = u(() => ({\n      [`bg-${l.badgeVariant}`]: l.badgeVariant !== null\n    })), T = u(() => l.badge === !0 ? \"\" : l.badge), c = u(() => ({\n      [`text-${l.badgeVariant !== null && te(l.badgeVariant)}`]: l.badgeVariant !== null\n    })), V = u(() => ({\n      [`b-avatar-${l.size}`]: !!l.size && n.indexOf(ka(l.size)) !== -1,\n      [`bg-${k.value}`]: k.value !== null,\n      badge: !b.value && k.value !== null && B.value,\n      rounded: w.value === \"\" || w.value === !0,\n      \"rounded-circle\": !p.value && w.value === \"circle\",\n      \"rounded-0\": p.value || w.value === \"0\",\n      \"rounded-1\": !p.value && w.value === \"sm\",\n      \"rounded-3\": !p.value && w.value === \"lg\",\n      \"rounded-top\": !p.value && w.value === \"top\",\n      \"rounded-bottom\": !p.value && w.value === \"bottom\",\n      \"rounded-start\": !p.value && w.value === \"left\",\n      \"rounded-end\": !p.value && w.value === \"right\",\n      btn: b.value,\n      [`btn-${k.value}`]: b.value ? k.value !== null : !1\n    })), F = u(() => ({\n      [`text-${l.textVariant || k.value !== null && te(k.value)}`]: l.textVariant || k.value !== null\n    })), f = u(() => {\n      const X = l.badgeOffset || \"0px\";\n      return {\n        fontSize: (n.indexOf(y.value || null) === -1 ? `calc(${y.value} * ${r})` : \"\") || \"\",\n        top: v.value ? X : \"\",\n        bottom: v.value ? \"\" : X,\n        left: i.value ? X : \"\",\n        right: i.value ? \"\" : X\n      };\n    }), I = u(() => {\n      const X = n.indexOf(y.value || null) === -1 ? `calc(${y.value} * ${s})` : null;\n      return X ? { fontSize: X } : {};\n    }), E = u(() => {\n      var ge;\n      const X = ((ge = o == null ? void 0 : o.overlapScale) == null ? void 0 : ge.value) || 0, ve = y.value && X ? `calc(${y.value} * -${X})` : null;\n      return ve ? { marginLeft: ve, marginRight: ve } : {};\n    }), z = u(\n      () => A.value ? Xe : b.value ? \"button\" : \"span\"\n    ), Z = u(() => ({\n      ...E.value,\n      width: y.value ?? void 0,\n      height: y.value ?? void 0\n    })), te = (X) => X === \"light\" || X === \"warning\" ? \"dark\" : \"light\", G = (X) => {\n      !h.value && (A.value || b.value) && t(\"click\", X);\n    }, W = (X) => t(\"img-error\", X);\n    return (X, ve) => (g(), M(le(z.value), ee({\n      class: [\"b-avatar\", V.value],\n      style: Z.value\n    }, _.value, { onClick: G }), {\n      default: j(() => [\n        B.value ? (g(), P(\"span\", mi, [\n          O(X.$slots, \"default\")\n        ])) : X.src ? (g(), P(\"span\", gi, [\n          K(\"img\", {\n            src: X.src,\n            alt: X.alt,\n            onError: W\n          }, null, 40, yi)\n        ])) : X.text ? (g(), P(\"span\", {\n          key: 2,\n          class: H([\"b-avatar-text\", F.value]),\n          style: ze(I.value)\n        }, Y(X.text), 7)) : J(\"\", !0),\n        m.value ? (g(), P(\"span\", {\n          key: 3,\n          class: H([\"b-avatar-badge\", C.value]),\n          style: ze(f.value)\n        }, [\n          S.value ? O(X.$slots, \"badge\", { key: 0 }) : (g(), P(\"span\", {\n            key: 1,\n            class: H(c.value)\n          }, Y(T.value), 3))\n        ], 6)) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 16, [\"class\", \"style\"]));\n  }\n}), hi = /* @__PURE__ */ N({\n  __name: \"BAvatarGroup\",\n  props: {\n    overlap: { default: 0.3 },\n    rounded: { type: [Boolean, String], default: !1 },\n    size: { default: void 0 },\n    square: { type: [String, Boolean], default: !1 },\n    tag: { default: \"div\" },\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.square), a = u(() => ka(t.size)), o = u(\n      () => Math.min(Math.max(s(t.overlap), 0), 1) / 2\n    ), n = u(() => {\n      const r = a.value ? `calc(${a.value} * ${o.value})` : null;\n      return r ? { paddingLeft: r, paddingRight: r } : {};\n    }), s = (r) => typeof r == \"string\" && co(r) ? Et(r, 0) : r || 0;\n    return De(_o, {\n      overlapScale: o,\n      size: ye(ke(t, \"size\")),\n      square: l,\n      rounded: ye(ke(t, \"rounded\")),\n      variant: ye(ke(t, \"variant\"))\n    }), (r, i) => (g(), M(le(r.tag), {\n      class: \"b-avatar-group\",\n      role: \"group\"\n    }, {\n      default: j(() => [\n        K(\"div\", {\n          class: \"b-avatar-group-inner\",\n          style: ze(n.value)\n        }, [\n          O(r.$slots, \"default\")\n        ], 4)\n      ]),\n      _: 3\n    }));\n  }\n}), Bi = /* @__PURE__ */ N({\n  __name: \"BBadge\",\n  props: {\n    pill: { type: [String, Boolean], default: !1 },\n    tag: { default: \"span\" },\n    textIndicator: { type: [String, Boolean], default: !1 },\n    dotIndicator: { type: [String, Boolean], default: !1 },\n    active: { type: [String, Boolean], default: void 0 },\n    activeClass: { default: \"router-link-active\" },\n    append: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    href: { default: void 0 },\n    rel: { default: void 0 },\n    replace: { type: [String, Boolean], default: !1 },\n    routerComponentName: { default: \"router-link\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    variant: { default: \"secondary\" },\n    opacity: { default: void 0 },\n    opacityHover: { default: void 0 },\n    underlineVariant: { default: null },\n    underlineOffset: { default: void 0 },\n    underlineOffsetHover: { default: void 0 },\n    underlineOpacity: { default: void 0 },\n    underlineOpacityHover: { default: void 0 },\n    icon: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.pill), a = d(() => t.textIndicator), o = d(() => t.dotIndicator), n = d(() => t.active), s = d(() => t.disabled), r = u(() => wt(t)), i = u(() => r.value ? Xe : t.tag), v = u(() => ({\n      [`bg-${t.variant}`]: t.variant !== null,\n      active: n.value,\n      disabled: s.value,\n      \"text-dark\": t.variant !== null && [\"warning\", \"info\", \"light\"].includes(t.variant),\n      \"rounded-pill\": l.value,\n      \"position-absolute top-0 start-100 translate-middle\": a.value || o.value,\n      \"p-2 border border-light rounded-circle\": o.value,\n      \"text-decoration-none\": r.value\n    })), b = u(\n      () => r.value ? Mt(t, [\n        \"active\",\n        \"activeClass\",\n        \"append\",\n        \"disabled\",\n        \"href\",\n        \"rel\",\n        \"replace\",\n        \"routerComponentName\",\n        \"target\",\n        \"to\",\n        \"variant\",\n        \"opacity\",\n        \"opacityHover\",\n        \"underlineVariant\",\n        \"underlineOffset\",\n        \"underlineOffsetHover\",\n        \"underlineOpacity\",\n        \"underlineOpacityHover\",\n        \"icon\"\n      ]) : {}\n    );\n    return (h, p) => (g(), M(le(i.value), ee({\n      class: [\"badge\", v.value]\n    }, b.value), {\n      default: j(() => [\n        O(h.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"class\"]));\n  }\n}), sn = /* @__PURE__ */ N({\n  __name: \"BBreadcrumbItem\",\n  props: {\n    ariaCurrent: { default: \"location\" },\n    text: { default: void 0 },\n    active: { type: [String, Boolean], default: !1 },\n    activeClass: { default: \"router-link-active\" },\n    append: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    href: { default: void 0 },\n    rel: { default: void 0 },\n    replace: { type: [String, Boolean], default: !1 },\n    routerComponentName: { default: \"router-link\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    variant: { default: void 0 },\n    opacity: { default: void 0 },\n    opacityHover: { default: void 0 },\n    underlineVariant: { default: null },\n    underlineOffset: { default: void 0 },\n    underlineOffsetHover: { default: void 0 },\n    underlineOpacity: { default: void 0 },\n    underlineOpacityHover: { default: void 0 },\n    icon: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = u(() => ({\n      active: a.value\n    })), s = u(() => a.value ? \"span\" : Xe), r = u(() => a.value ? l.ariaCurrent : void 0), i = u(\n      () => s.value !== \"span\" ? Mt(l, [\n        \"active\",\n        \"activeClass\",\n        \"append\",\n        \"disabled\",\n        \"href\",\n        \"rel\",\n        \"replace\",\n        \"routerComponentName\",\n        \"target\",\n        \"to\",\n        \"variant\",\n        \"opacity\",\n        \"opacityHover\",\n        \"underlineVariant\",\n        \"underlineOffset\",\n        \"underlineOffsetHover\",\n        \"underlineOpacity\",\n        \"underlineOpacityHover\",\n        \"icon\"\n      ]) : {}\n    ), v = (b) => {\n      if (o.value || a.value) {\n        b.preventDefault(), b.stopImmediatePropagation();\n        return;\n      }\n      o.value || t(\"click\", b);\n    };\n    return (b, h) => (g(), P(\"li\", {\n      class: H([\"breadcrumb-item\", n.value])\n    }, [\n      (g(), M(le(s.value), ee({ \"aria-current\": r.value }, i.value, { onClick: v }), {\n        default: j(() => [\n          O(b.$slots, \"default\", {}, () => [\n            ne(Y(b.text), 1)\n          ])\n        ]),\n        _: 3\n      }, 16, [\"aria-current\"]))\n    ], 2));\n  }\n}), Si = { \"aria-label\": \"breadcrumb\" }, wi = { class: \"breadcrumb\" }, _i = /* @__PURE__ */ N({\n  __name: \"BBreadcrumb\",\n  props: {\n    items: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = Ko(), a = u(() => {\n      const o = t.items || (l == null ? void 0 : l.items) || [];\n      let n = !1;\n      return o.map((r, i) => (typeof r == \"string\" && (r = { text: r }, i < o.length - 1 && (r.href = \"#\")), r.active && (n = !0), !r.active && !n && (r.active = i + 1 === o.length), r));\n    });\n    return (o, n) => (g(), P(\"nav\", Si, [\n      K(\"ol\", wi, [\n        O(o.$slots, \"prepend\"),\n        (g(!0), P(ce, null, he(a.value, (s, r) => (g(), M(sn, ee({ key: r }, s), {\n          default: j(() => [\n            ne(Y(s.text), 1)\n          ]),\n          _: 2\n        }, 1040))), 128)),\n        O(o.$slots, \"default\"),\n        O(o.$slots, \"append\")\n      ])\n    ]));\n  }\n}), $i = /* @__PURE__ */ N({\n  __name: \"BButtonGroup\",\n  props: {\n    ariaLabel: { default: \"Group\" },\n    size: { default: \"md\" },\n    tag: { default: \"div\" },\n    vertical: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.vertical), a = u(() => ({\n      \"btn-group\": !l.value,\n      [`btn-group-${t.size}`]: t.size !== \"md\",\n      \"btn-group-vertical\": l.value\n    }));\n    return (o, n) => (g(), M(le(o.tag), {\n      class: H(a.value),\n      role: \"group\",\n      \"aria-label\": o.ariaLabel\n    }, {\n      default: j(() => [\n        O(o.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"class\", \"aria-label\"]));\n  }\n}), Ci = [\"role\", \"aria-label\"], ki = /* @__PURE__ */ N({\n  __name: \"BButtonToolbar\",\n  props: {\n    ariaLabel: { default: \"Group\" },\n    justify: { type: [String, Boolean], default: !1 },\n    role: { default: \"toolbar\" }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.justify), a = u(() => ({\n      \"justify-content-between\": l.value\n    }));\n    return (o, n) => (g(), P(\"div\", {\n      class: H([a.value, \"btn-toolbar\"]),\n      role: o.role,\n      \"aria-label\": o.ariaLabel\n    }, [\n      O(o.$slots, \"default\")\n    ], 10, Ci));\n  }\n}), Ti = '<svg width=\"%{w}\" height=\"%{h}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\"><rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect></svg>', al = /* @__PURE__ */ N({\n  __name: \"BImg\",\n  props: {\n    alt: { default: void 0 },\n    blank: { type: [String, Boolean], default: !1 },\n    blankColor: { default: \"transparent\" },\n    block: { type: [String, Boolean], default: !1 },\n    center: { type: [String, Boolean], default: !1 },\n    fluid: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: !1 },\n    fluidGrow: { type: [String, Boolean], default: !1 },\n    height: { default: void 0 },\n    start: { type: [String, Boolean], default: !1 },\n    end: { type: [String, Boolean], default: !1 },\n    rounded: { type: [Boolean, String], default: !1 },\n    sizes: { default: void 0 },\n    src: { default: void 0 },\n    srcset: { default: void 0 },\n    thumbnail: { type: [String, Boolean], default: !1 },\n    width: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.lazy), a = d(() => t.blank), o = d(() => t.block), n = d(() => t.center), s = d(() => t.fluid), r = d(() => t.fluidGrow), i = d(() => t.start), v = d(() => t.end), b = d(() => t.thumbnail), h = u(\n      () => typeof t.srcset == \"string\" ? t.srcset.split(\",\").filter((w) => w).join(\",\") : Array.isArray(t.srcset) ? t.srcset.filter((w) => w).join(\",\") : void 0\n    ), p = u(\n      () => typeof t.sizes == \"string\" ? t.sizes.split(\",\").filter((w) => w).join(\",\") : Array.isArray(t.sizes) ? t.sizes.filter((w) => w).join(\",\") : void 0\n    ), B = u(() => {\n      const w = (T) => T === void 0 ? void 0 : typeof T == \"number\" ? T : Number.parseInt(T, 10) || void 0, _ = w(t.width), C = w(t.height);\n      if (a.value) {\n        if (_ !== void 0 && C === void 0)\n          return { height: _, width: _ };\n        if (_ === void 0 && C !== void 0)\n          return { height: C, width: C };\n        if (_ === void 0 && C === void 0)\n          return { height: 1, width: 1 };\n      }\n      return {\n        width: _,\n        height: C\n      };\n    }), S = u(\n      () => k(B.value.width, B.value.height, t.blankColor)\n    ), m = u(() => ({\n      src: a.value ? S.value : t.src,\n      alt: t.alt,\n      width: B.value.width || void 0,\n      height: B.value.height || void 0,\n      srcset: a.value ? void 0 : h.value,\n      sizes: a.value ? void 0 : p.value,\n      loading: l.value ? \"lazy\" : \"eager\"\n    })), A = u(\n      () => i.value ? \"float-start\" : v.value ? \"float-end\" : n.value ? \"mx-auto\" : void 0\n    ), y = u(() => ({\n      \"img-thumbnail\": b.value,\n      \"img-fluid\": s.value || r.value,\n      \"w-100\": r.value,\n      rounded: t.rounded === \"\" || t.rounded === !0,\n      [`rounded-${t.rounded}`]: typeof t.rounded == \"string\" && t.rounded !== \"\",\n      [`${A.value}`]: A.value !== void 0,\n      \"d-block\": o.value || n.value\n    })), k = (w, _, C) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(\n      Ti.replace(\"%{w}\", String(w)).replace(\"%{h}\", String(_)).replace(\"%{f}\", C)\n    )}`;\n    return (w, _) => (g(), P(\"img\", ee({ class: y.value }, m.value), null, 16));\n  }\n}), ra = /* @__PURE__ */ N({\n  __name: \"BCardImg\",\n  props: {\n    alt: { default: void 0 },\n    blank: { type: [String, Boolean], default: !1 },\n    blankColor: { default: void 0 },\n    bottom: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: !1 },\n    height: { default: void 0 },\n    start: { type: [String, Boolean], default: !1 },\n    end: { type: [String, Boolean], default: !1 },\n    sizes: { default: void 0 },\n    src: { default: void 0 },\n    srcset: { default: void 0 },\n    top: { type: [String, Boolean], default: !1 },\n    width: { default: void 0 }\n  },\n  emits: [\"load\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.bottom), o = d(() => l.end), n = d(() => l.start), s = d(() => l.top), r = u(\n      () => s.value ? \"card-img-top\" : o.value ? \"card-img-right\" : a.value ? \"card-img-bottom\" : n.value ? \"card-img-left\" : \"card-img\"\n    ), i = u(() => ({\n      alt: l.alt,\n      height: l.height,\n      src: l.src,\n      lazy: l.lazy,\n      width: l.width,\n      blank: l.blank,\n      blankColor: l.blankColor,\n      sizes: l.sizes,\n      srcset: l.srcset\n    }));\n    return (v, b) => (g(), M(al, ee({ class: r.value }, i.value, {\n      onLoad: b[0] || (b[0] = (h) => t(\"load\", h))\n    }), null, 16, [\"class\"]));\n  }\n}), Vi = [\"innerHTML\"], rn = /* @__PURE__ */ N({\n  __name: \"BCardHeadFoot\",\n  props: {\n    text: { default: void 0 },\n    bgVariant: { default: null },\n    borderVariant: { default: null },\n    html: { default: void 0 },\n    tag: { default: \"div\" },\n    textVariant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`text-${t.textVariant}`]: t.textVariant !== null,\n      [`bg-${t.bgVariant}`]: t.bgVariant !== null,\n      [`border-${t.borderVariant}`]: t.borderVariant !== null\n    }));\n    return (a, o) => (g(), M(le(a.tag), {\n      class: H(l.value)\n    }, {\n      default: j(() => [\n        a.html ? (g(), P(\"div\", {\n          key: 0,\n          innerHTML: a.html\n        }, null, 8, Vi)) : O(a.$slots, \"default\", { key: 1 }, () => [\n          ne(Y(a.text), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"class\"]));\n  }\n}), un = /* @__PURE__ */ N({\n  __name: \"BCardHeader\",\n  props: {\n    text: { default: void 0 },\n    bgVariant: { default: void 0 },\n    borderVariant: { default: void 0 },\n    html: { default: void 0 },\n    tag: { default: \"div\" },\n    textVariant: { default: void 0 }\n  },\n  setup(e) {\n    const t = e;\n    return (l, a) => (g(), M(rn, ee({ class: \"card-header\" }, t), {\n      default: j(() => [\n        O(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dn = /* @__PURE__ */ N({\n  __name: \"BCardTitle\",\n  props: {\n    text: { default: void 0 },\n    tag: { default: \"h4\" }\n  },\n  setup(e) {\n    return (t, l) => (g(), M(le(t.tag), { class: \"card-title\" }, {\n      default: j(() => [\n        O(t.$slots, \"default\", {}, () => [\n          ne(Y(t.text), 1)\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), cn = /* @__PURE__ */ N({\n  __name: \"BCardSubtitle\",\n  props: {\n    text: { default: void 0 },\n    tag: { default: \"h6\" },\n    textVariant: { default: \"muted\" }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`text-${t.textVariant}`]: t.textVariant !== null\n    }));\n    return (a, o) => (g(), M(le(a.tag), {\n      class: H([\"card-subtitle mb-2\", l.value])\n    }, {\n      default: j(() => [\n        O(a.$slots, \"default\", {}, () => [\n          ne(Y(a.text), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"class\"]));\n  }\n}), fn = /* @__PURE__ */ N({\n  __name: \"BCardBody\",\n  props: {\n    bodyBgVariant: { default: null },\n    bodyTag: { default: \"div\" },\n    bodyTextVariant: { default: null },\n    overlay: { type: [String, Boolean], default: !1 },\n    subtitle: { default: void 0 },\n    subtitleTag: { default: \"h4\" },\n    subtitleTextVariant: { default: void 0 },\n    title: { default: void 0 },\n    titleTag: { default: \"h4\" },\n    text: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = Fe(), a = d(() => t.overlay), o = u(() => !Ae(l.title)), n = u(() => !Ae(l.subtitle)), s = u(() => ({\n      \"card-img-overlay\": a.value,\n      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== null,\n      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== null\n    }));\n    return (r, i) => (g(), M(le(r.bodyTag), {\n      class: H([\"card-body\", s.value])\n    }, {\n      default: j(() => [\n        r.title || o.value ? (g(), M(dn, {\n          key: 0,\n          tag: r.titleTag\n        }, {\n          default: j(() => [\n            O(r.$slots, \"title\", {}, () => [\n              ne(Y(r.title), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"tag\"])) : J(\"\", !0),\n        r.subtitle || n.value ? (g(), M(cn, {\n          key: 1,\n          tag: r.subtitleTag,\n          \"text-variant\": r.subtitleTextVariant\n        }, {\n          default: j(() => [\n            O(r.$slots, \"subtitle\", {}, () => [\n              ne(Y(r.subtitle), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"tag\", \"text-variant\"])) : J(\"\", !0),\n        O(r.$slots, \"default\", {}, () => [\n          ne(Y(r.text), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"class\"]));\n  }\n}), vn = /* @__PURE__ */ N({\n  __name: \"BCardFooter\",\n  props: {\n    text: { default: void 0 },\n    bgVariant: { default: void 0 },\n    borderVariant: { default: void 0 },\n    html: { default: void 0 },\n    tag: { default: \"div\" },\n    textVariant: { default: void 0 }\n  },\n  setup(e) {\n    const t = e;\n    return (l, a) => (g(), M(rn, ee({ class: \"card-footer\" }, t), {\n      default: j(() => [\n        O(l.$slots, \"default\", {}, () => [\n          ne(Y(l.text), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pn = /* @__PURE__ */ N({\n  __name: \"BCard\",\n  props: {\n    align: { default: void 0 },\n    bgVariant: { default: null },\n    bodyBgVariant: { default: void 0 },\n    bodyClass: { default: void 0 },\n    bodyTag: { default: \"div\" },\n    bodyTextVariant: { default: void 0 },\n    borderVariant: { default: null },\n    footer: { default: void 0 },\n    footerBgVariant: { default: void 0 },\n    footerBorderVariant: { default: void 0 },\n    footerClass: { default: void 0 },\n    footerHtml: { default: \"\" },\n    footerTag: { default: \"div\" },\n    footerTextVariant: { default: void 0 },\n    header: { default: void 0 },\n    headerBgVariant: { default: void 0 },\n    headerBorderVariant: { default: void 0 },\n    headerClass: { default: void 0 },\n    headerHtml: { default: \"\" },\n    headerTag: { default: \"div\" },\n    headerTextVariant: { default: void 0 },\n    imgAlt: { default: void 0 },\n    imgBottom: { type: [String, Boolean], default: !1 },\n    imgEnd: { type: [String, Boolean], default: !1 },\n    imgHeight: { default: void 0 },\n    imgSrc: { default: void 0 },\n    imgStart: { type: [String, Boolean], default: !1 },\n    imgTop: { type: [String, Boolean], default: !1 },\n    imgWidth: { default: void 0 },\n    noBody: { type: [String, Boolean], default: !1 },\n    overlay: { type: [String, Boolean], default: !1 },\n    subtitle: { default: void 0 },\n    subtitleTag: { default: \"h6\" },\n    subtitleTextVariant: { default: \"muted\" },\n    tag: { default: \"div\" },\n    textVariant: { default: null },\n    title: { default: void 0 },\n    titleTag: { default: \"h4\" },\n    bodyText: { default: \"\" }\n  },\n  setup(e) {\n    const t = e, l = Fe(), a = d(() => t.imgBottom), o = d(() => t.imgEnd), n = d(() => t.imgStart), s = d(() => t.noBody), r = u(() => !Ae(l.header)), i = u(() => !Ae(l.footer)), v = u(() => ({\n      [`text-${t.align}`]: t.align !== void 0,\n      [`text-${t.textVariant}`]: t.textVariant !== null,\n      [`bg-${t.bgVariant}`]: t.bgVariant !== null,\n      [`border-${t.borderVariant}`]: t.borderVariant !== null,\n      \"flex-row\": n.value,\n      \"flex-row-reverse\": o.value\n    })), b = u(() => ({\n      bgVariant: t.headerBgVariant,\n      borderVariant: t.headerBorderVariant,\n      html: t.headerHtml,\n      tag: t.headerTag,\n      textVariant: t.headerTextVariant\n    })), h = u(() => ({\n      overlay: t.overlay,\n      bodyBgVariant: t.bodyBgVariant,\n      bodyTag: t.bodyTag,\n      bodyTextVariant: t.bodyTextVariant,\n      subtitle: t.subtitle,\n      subtitleTag: t.subtitleTag,\n      subtitleTextVariant: t.subtitleTextVariant,\n      title: t.title,\n      titleTag: t.titleTag\n    })), p = u(() => ({\n      bgVariant: t.footerBgVariant,\n      borderVariant: t.footerBorderVariant,\n      html: t.footerHtml,\n      tag: t.footerTag,\n      textVariant: t.footerTextVariant\n    })), B = u(() => ({\n      src: t.imgSrc,\n      alt: t.imgAlt,\n      height: t.imgHeight,\n      width: t.imgWidth,\n      bottom: t.imgBottom,\n      end: t.imgEnd,\n      start: t.imgStart,\n      top: t.imgTop\n    }));\n    return (S, m) => (g(), M(le(S.tag), {\n      class: H([\"card\", v.value])\n    }, {\n      default: j(() => [\n        $(a) ? J(\"\", !0) : O(S.$slots, \"img\", { key: 0 }, () => [\n          S.imgSrc ? (g(), M(ra, Be(ee({ key: 0 }, B.value)), null, 16)) : J(\"\", !0)\n        ]),\n        S.header || r.value || S.headerHtml ? (g(), M(un, ee({ key: 1 }, b.value, { class: S.headerClass }), {\n          default: j(() => [\n            O(S.$slots, \"header\", {}, () => [\n              ne(Y(S.header), 1)\n            ])\n          ]),\n          _: 3\n        }, 16, [\"class\"])) : J(\"\", !0),\n        $(s) ? O(S.$slots, \"default\", { key: 3 }, () => [\n          ne(Y(S.bodyText), 1)\n        ]) : (g(), M(fn, ee({ key: 2 }, h.value, { class: S.bodyClass }), {\n          default: j(() => [\n            O(S.$slots, \"default\", {}, () => [\n              ne(Y(S.bodyText), 1)\n            ])\n          ]),\n          _: 3\n        }, 16, [\"class\"])),\n        S.footer || i.value || S.footerHtml ? (g(), M(vn, ee({ key: 4 }, p.value, { class: S.footerClass }), {\n          default: j(() => [\n            O(S.$slots, \"footer\", {}, () => [\n              ne(Y(S.footer), 1)\n            ])\n          ]),\n          _: 3\n        }, 16, [\"class\"])) : J(\"\", !0),\n        $(a) ? O(S.$slots, \"img\", { key: 5 }, () => [\n          S.imgSrc ? (g(), M(ra, Be(ee({ key: 0 }, B.value)), null, 16)) : J(\"\", !0)\n        ]) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"class\"]));\n  }\n}), Ai = /* @__PURE__ */ N({\n  __name: \"BCardGroup\",\n  props: {\n    columns: { type: [String, Boolean], default: !1 },\n    deck: { type: [String, Boolean], default: !1 },\n    tag: { default: \"div\" }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.columns), a = d(() => t.deck), o = u(\n      () => a.value ? \"card-deck\" : l.value ? \"card-columns\" : \"card-group\"\n    ), n = u(() => [o.value]);\n    return (s, r) => (g(), M(le(s.tag), {\n      class: H(n.value)\n    }, {\n      default: j(() => [\n        O(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"class\"]));\n  }\n}), Oi = /* @__PURE__ */ N({\n  __name: \"BCardText\",\n  props: {\n    text: { default: void 0 },\n    tag: { default: \"p\" }\n  },\n  setup(e) {\n    return (t, l) => (g(), M(le(t.tag), { class: \"card-text\" }, {\n      default: j(() => [\n        O(t.$slots, \"default\", {}, () => [\n          ne(Y(t.text), 1)\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), Fi = [\"id\", \"onMouseenter\", \"onMouseleave\"], Pi = {\n  key: 0,\n  class: \"carousel-indicators\"\n}, Ei = [\"aria-current\", \"aria-label\", \"onClick\"], Ii = /* @__PURE__ */ K(\"span\", {\n  class: \"carousel-control-prev-icon\",\n  \"aria-hidden\": \"true\"\n}, null, -1), xi = { class: \"visually-hidden\" }, Li = /* @__PURE__ */ K(\"span\", {\n  class: \"carousel-control-next-icon\",\n  \"aria-hidden\": \"true\"\n}, null, -1), Ni = { class: \"visually-hidden\" }, zi = /* @__PURE__ */ N({\n  __name: \"BCarousel\",\n  props: {\n    ride: { type: [Boolean, String], default: !1 },\n    noHoverPause: { type: [String, Boolean], default: !1 },\n    rideReverse: { type: [String, Boolean], default: !1 },\n    fade: { type: [String, Boolean], default: !1 },\n    id: { default: void 0 },\n    imgHeight: { default: void 0 },\n    imgWidth: { default: void 0 },\n    background: { default: void 0 },\n    modelValue: { default: 0 },\n    controls: { type: [String, Boolean], default: !1 },\n    indicators: { type: [String, Boolean], default: !1 },\n    interval: { default: 5e3 },\n    noTouch: { type: [String, Boolean], default: !1 },\n    noWrap: { type: [String, Boolean], default: !1 },\n    controlsPrevText: { default: \"Previous\" },\n    controlsNextText: { default: \"Next\" },\n    indicatorsButtonLabel: { default: \"Slide\" },\n    keyboard: { type: [String, Boolean], default: !0 },\n    touchThreshold: { default: 50 }\n  },\n  emits: [\"slid\", \"slide\", \"update:modelValue\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Fe(), n = _e(() => a.id, \"carousel\"), s = Se(a, \"modelValue\", l, { passive: !0 }), r = d(() => a.keyboard), i = d(() => a.rideReverse), v = d(() => a.noHoverPause), b = d(() => a.fade), h = d(() => a.controls), p = d(() => a.indicators), B = d(() => a.noTouch), S = d(() => a.noWrap), m = bt(() => a.touchThreshold, {\n      nanToZero: !0,\n      method: \"parseInt\"\n    }), A = R(!1), y = R(!1), k = R(!0), w = R(null), _ = R(null), C = R(s.value), T = u(\n      () => Yn(a.ride) ? Ra(a.ride) : a.ride\n    ), c = u(\n      () => `carousel-item carousel-item-${k.value ? \"prev\" : \"next\"} carousel-item-${k.value ? \"end\" : \"start\"}`\n    ), V = u(\n      () => `carousel-item active carousel-item-${k.value ? \"start\" : \"end\"}`\n    ), { pause: F, resume: f } = qo(\n      () => {\n        i.value ? G() : W();\n      },\n      () => a.interval,\n      { immediate: T.value === \"carousel\" }\n    ), I = u(\n      () => T.value === !0 && y.value === !0 || T.value === \"carousel\"\n    ), E = u(() => Ba(o.default, \"BCarouselSlide\")), z = u(() => [\n      \"carousel\",\n      \"slide\",\n      \"pointer-event\",\n      { \"carousel-fade\": b.value }\n    ]), Z = (Q) => {\n      var re;\n      return new uo(Q, {\n        componentId: n.value,\n        cancelable: !1,\n        target: _.value,\n        direction: k.value ? \"right\" : \"left\",\n        from: C.value,\n        to: s.value,\n        relatedTarget: ((re = w.value) == null ? void 0 : re.children[s.value]) ?? null\n      });\n    }, te = (Q) => {\n      if (A.value !== !0) {\n        if (T.value === !0 && (y.value = !0), I.value === !0 && f(), k.value = !(Q < s.value), Q >= E.value.length) {\n          if (S.value)\n            return;\n          s.value = 0;\n          return;\n        }\n        if (Q < 0) {\n          if (S.value)\n            return;\n          s.value = E.value.length - 1;\n          return;\n        }\n        C.value = s.value, s.value = Q;\n      }\n    }, G = () => {\n      te(s.value - 1);\n    }, W = () => {\n      te(s.value + 1);\n    }, X = (Q) => {\n      r.value !== !1 && Q();\n    }, ve = () => {\n      v.value || F();\n    }, ge = () => {\n      I.value && f();\n    }, { lengthX: pe } = jr(_, {\n      passive: !0,\n      onSwipeStart() {\n        B.value !== !0 && F();\n      },\n      onSwipeEnd() {\n        if (B.value === !0)\n          return;\n        const Q = () => {\n          I.value !== !1 && f();\n        };\n        if (pe.value >= m.value) {\n          W(), Q();\n          return;\n        }\n        pe.value <= -m.value && (G(), Q());\n      }\n    }), me = () => {\n      l(\"slide\", Z(\"slide\")), A.value = !0;\n    }, q = () => {\n      l(\"slid\", Z(\"slid\")), A.value = !1;\n    };\n    return oe(\n      () => a.ride,\n      () => {\n        y.value = !1;\n      }\n    ), t({ pause: F, resume: f, prev: G, next: W }), De(ho, {\n      background: ye(ke(a, \"background\")),\n      width: ye(ke(a, \"imgWidth\")),\n      height: ye(ke(a, \"imgHeight\"))\n    }), (Q, re) => (g(), P(\"div\", {\n      id: $(n),\n      ref_key: \"element\",\n      ref: _,\n      class: H(z.value),\n      onKeydown: [\n        re[0] || (re[0] = It((de) => X(G), [\"left\"])),\n        re[1] || (re[1] = It((de) => X(W), [\"right\"]))\n      ],\n      onMouseenter: ot(ve, [\"stop\"]),\n      onMouseleave: ot(ge, [\"stop\"])\n    }, [\n      $(p) ? (g(), P(\"div\", Pi, [\n        (g(!0), P(ce, null, he(E.value.length, (de, L) => (g(), P(\"button\", {\n          key: L,\n          type: \"button\",\n          \"data-bs-target\": \"\",\n          class: H(L === $(s) ? \"active\" : \"\"),\n          \"aria-current\": L === $(s) ? !0 : void 0,\n          \"aria-label\": `${Q.indicatorsButtonLabel} ${L}`,\n          onClick: (x) => te(L)\n        }, null, 10, Ei))), 128))\n      ])) : J(\"\", !0),\n      K(\"div\", {\n        ref_key: \"relatedTarget\",\n        ref: w,\n        class: \"carousel-inner\"\n      }, [\n        be(qn, {\n          \"enter-from-class\": c.value,\n          \"enter-active-class\": c.value,\n          \"enter-to-class\": c.value,\n          \"leave-from-class\": V.value,\n          \"leave-active-class\": V.value,\n          \"leave-to-class\": V.value,\n          onBeforeLeave: me,\n          onAfterLeave: q\n        }, {\n          default: j(() => [\n            (g(!0), P(ce, null, he(E.value, (de, L) => rt((g(), M(le(de), {\n              key: L,\n              class: H({ active: L === $(s) && A.value === !1 })\n            }, null, 8, [\"class\"])), [\n              [ua, L === $(s)]\n            ])), 128))\n          ]),\n          _: 1\n        }, 8, [\"enter-from-class\", \"enter-active-class\", \"enter-to-class\", \"leave-from-class\", \"leave-active-class\", \"leave-to-class\"])\n      ], 512),\n      $(h) ? (g(), P(ce, { key: 1 }, [\n        K(\"button\", {\n          class: \"carousel-control-prev\",\n          type: \"button\",\n          onClick: G\n        }, [\n          Ii,\n          K(\"span\", xi, Y(Q.controlsPrevText), 1)\n        ]),\n        K(\"button\", {\n          class: \"carousel-control-next\",\n          type: \"button\",\n          onClick: W\n        }, [\n          Li,\n          K(\"span\", Ni, Y(Q.controlsNextText), 1)\n        ])\n      ], 64)) : J(\"\", !0)\n    ], 42, Fi));\n  }\n}), Hi = [\"innerHTML\"], Ri = { key: 1 }, Mi = [\"innerHTML\"], Di = { key: 1 }, ji = /* @__PURE__ */ N({\n  __name: \"BCarouselSlide\",\n  props: {\n    imgSrc: { default: void 0 },\n    imgHeight: { default: void 0 },\n    imgWidth: { default: void 0 },\n    interval: { default: void 0 },\n    background: { default: void 0 },\n    caption: { default: void 0 },\n    captionHtml: { default: void 0 },\n    captionTag: { default: \"h3\" },\n    contentTag: { default: \"div\" },\n    contentVisibleUp: { default: void 0 },\n    id: { default: void 0 },\n    imgAlt: { default: void 0 },\n    imgBlank: { type: [String, Boolean], default: !1 },\n    imgBlankColor: { default: \"transparent\" },\n    text: { default: void 0 },\n    textHtml: { default: void 0 },\n    textTag: { default: \"p\" }\n  },\n  setup(e) {\n    const t = e, l = Fe(), a = Oe(ho, null), o = u(() => t.text || t.textHtml || !Ae(l.text)), n = u(() => t.caption || t.captionHtml || !Ae(l.caption)), s = u(() => o.value || n.value || !Ae(l.default)), r = u(() => ({\n      background: `${t.background || (a == null ? void 0 : a.background.value) || \"rgb(171, 171, 171)\"} none repeat scroll 0% 0%`\n    })), i = u(() => ({\n      \"d-none\": t.contentVisibleUp !== void 0,\n      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0\n    }));\n    return (v, b) => (g(), P(\"div\", {\n      class: \"carousel-item\",\n      style: ze(r.value)\n    }, [\n      O(v.$slots, \"img\", {}, () => {\n        var h, p;\n        return [\n          be(al, {\n            class: \"d-block w-100\",\n            alt: v.imgAlt,\n            src: v.imgSrc,\n            width: v.imgWidth || ((h = $(a)) == null ? void 0 : h.width.value),\n            height: v.imgHeight || ((p = $(a)) == null ? void 0 : p.height.value),\n            blank: v.imgBlank,\n            \"blank-color\": v.imgBlankColor\n          }, null, 8, [\"alt\", \"src\", \"width\", \"height\", \"blank\", \"blank-color\"])\n        ];\n      }),\n      s.value ? (g(), M(le(v.contentTag), {\n        key: 0,\n        class: H([\"carousel-caption\", i.value])\n      }, {\n        default: j(() => [\n          n.value ? (g(), M(le(v.captionTag), { key: 0 }, {\n            default: j(() => [\n              O(v.$slots, \"caption\", {}, () => [\n                v.captionHtml ? (g(), P(\"span\", {\n                  key: 0,\n                  innerHTML: v.captionHtml\n                }, null, 8, Hi)) : (g(), P(\"span\", Ri, Y(v.caption), 1))\n              ])\n            ]),\n            _: 3\n          })) : J(\"\", !0),\n          o.value ? (g(), M(le(v.textTag), { key: 1 }, {\n            default: j(() => [\n              O(v.$slots, \"text\", {}, () => [\n                v.textHtml ? (g(), P(\"span\", {\n                  key: 0,\n                  innerHTML: v.textHtml\n                }, null, 8, Mi)) : (g(), P(\"span\", Di, Y(v.text), 1))\n              ])\n            ]),\n            _: 3\n          })) : J(\"\", !0),\n          O(v.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"class\"])) : J(\"\", !0)\n    ], 4));\n  }\n}), Nl = da(\"\", [], { type: [Boolean, String, Number], default: !1 }), zl = da(\"offset\", [\"\"], { type: [String, Number], default: null }), Hl = da(\"order\", [\"\"], { type: [String, Number], default: null }), qi = N({\n  name: \"BCol\",\n  slots: Object,\n  props: {\n    col: { type: [Boolean, String], default: !1 },\n    // Generic flexbox .col (xs)\n    cols: { type: [String, Number], default: null },\n    // .col-[1-12]|auto (xs)\n    ...Nl,\n    offset: { type: [String, Number], default: null },\n    ...zl,\n    order: { type: [String, Number], default: null },\n    ...Hl,\n    alignSelf: { type: String, default: null },\n    tag: { type: String, default: \"div\" }\n  },\n  setup(e) {\n    const t = [\n      { content: Nl, propPrefix: \"cols\", classPrefix: \"col\" },\n      { content: zl, propPrefix: \"offset\" },\n      { content: Hl, propPrefix: \"order\" }\n    ], l = d(() => e.col), a = u(\n      () => t.flatMap((n) => bo(e, n.content, n.propPrefix, n.classPrefix))\n    );\n    return {\n      computedClasses: u(() => [\n        a.value,\n        {\n          col: l.value || !a.value.some((n) => /^col-/.test(n)) && !e.cols,\n          [`col-${e.cols}`]: !!e.cols,\n          [`offset-${e.offset}`]: !!e.offset,\n          [`order-${e.order}`]: !!e.order,\n          [`align-self-${e.alignSelf}`]: !!e.alignSelf\n        }\n      ])\n    };\n  }\n}), ll = (e, t) => {\n  const l = e.__vccOpts || e;\n  for (const [a, o] of t)\n    l[a] = o;\n  return l;\n};\nfunction Gi(e, t, l, a, o, n) {\n  return g(), M(le(e.tag), {\n    class: H(e.computedClasses)\n  }, {\n    default: j(() => [\n      O(e.$slots, \"default\")\n    ]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst Pt = /* @__PURE__ */ ll(qi, [[\"render\", Gi]]), pt = {\n  autoHide: !0,\n  delay: 5e3,\n  noCloseButton: !1,\n  pos: \"top-right\",\n  value: !0\n};\nclass Rl {\n  constructor(t) {\n    Te(this, \"vm\");\n    Te(this, \"containerPositions\");\n    Gn(t) ? this.vm = t : this.vm = St(t), this.containerPositions = u(() => {\n      const l = /* @__PURE__ */ new Set([]);\n      return this.vm.toasts.map((a) => {\n        a.options.pos && l.add(a.options.pos);\n      }), l;\n    });\n  }\n  toasts(t) {\n    return t ? u(\n      () => this.vm.toasts.filter((l) => {\n        if (l.options.pos === t && l.options.value)\n          return l;\n      })\n    ) : u(() => this.vm.toasts);\n  }\n  remove(...t) {\n    this.vm.toasts = this.vm.toasts.filter((l) => {\n      if (l.options.id && !t.includes(l.options.id))\n        return l;\n    });\n  }\n  isRoot() {\n    return this.vm.root ?? !1;\n  }\n  show(t, l = pt) {\n    const a = { id: at(), ...pt, ...l }, o = {\n      options: St(a),\n      content: t\n    };\n    return this.vm.toasts.push(o), o;\n  }\n  info(t, l = pt) {\n    return this.show(t, { variant: \"info\", ...l });\n  }\n  danger(t, l = pt) {\n    return this.show(t, { variant: \"danger\", ...l });\n  }\n  warning(t, l = pt) {\n    return this.show(t, { variant: \"warning\", ...l });\n  }\n  success(t, l = pt) {\n    return this.show(t, { variant: \"success\", ...l });\n  }\n  hide() {\n  }\n}\nclass Wi {\n  constructor() {\n    Te(this, \"vms\");\n    Te(this, \"rootInstance\");\n    Te(this, \"useToast\", gn);\n    this.vms = {};\n  }\n  getOrCreateViewModel(t) {\n    if (!t) {\n      if (this.rootInstance)\n        return this.vms[this.rootInstance];\n      const l = { root: !0, toasts: [], container: void 0, id: Symbol(\"toast\") };\n      return this.rootInstance = l.id, this.vms[l.id] = l, l;\n    }\n    if (t.root) {\n      if (this.rootInstance)\n        return this.vms[this.rootInstance];\n      this.rootInstance = t.id;\n    }\n    return this.vms[t.id] = t, t;\n  }\n  getVM(t) {\n    if (!t && this.rootInstance)\n      return this.vms[this.rootInstance];\n    if (t)\n      return this.vms[t];\n  }\n}\nconst Ta = Symbol(\"toast\"), mn = Symbol(\"toastFetch\"), Ui = {\n  container: void 0,\n  toasts: [],\n  root: !1\n};\nfunction Xi() {\n  return Oe(mn);\n}\nfunction gn(e, t = Ta) {\n  const l = Oe(Xi());\n  if (!e)\n    return new Rl(l.getOrCreateViewModel());\n  const a = { id: Symbol(\"toastInstance\") }, o = { ...Ui, ...a, ...e }, n = l.getOrCreateViewModel(o);\n  return new Rl(n);\n}\nconst yn = {\n  install: (e, t) => {\n    var a;\n    const l = typeof (t == null ? void 0 : t.BToast) == \"object\" ? ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? Ta : Ta;\n    e.provide(mn, l), e.provide(l, new Wi());\n  }\n}, Ki = \"toast-title\", Ml = 1e3, bn = N({\n  components: { BLink: Xe },\n  props: {\n    ...fi,\n    delay: { type: Number, default: 5e3 },\n    bodyClass: { type: String, default: void 0 },\n    body: { type: [Object, String], default: void 0 },\n    headerClass: { type: String, default: void 0 },\n    headerTag: { type: String, default: \"div\" },\n    animation: { type: [Boolean, String], default: !0 },\n    id: { type: String, default: void 0 },\n    // Switches role to 'status' and aria-live to 'polite'\n    isStatus: { type: [Boolean, String], default: !1 },\n    autoHide: { type: [Boolean, String], default: !0 },\n    noCloseButton: { type: [Boolean, String], default: !1 },\n    noFade: { type: [Boolean, String], default: !1 },\n    noHoverPause: { type: [Boolean, String], default: !1 },\n    solid: { type: [Boolean, String], default: !1 },\n    // Render the toast in place, rather than in a portal-target\n    static: { type: [Boolean, String], default: !1 },\n    title: { type: String, default: void 0 },\n    modelValue: { type: [Boolean, String], default: !1 },\n    toastClass: { type: Array, default: void 0 },\n    variant: { type: String, default: null }\n  },\n  emits: [\"destroyed\", \"update:modelValue\"],\n  setup(e, { emit: t, slots: l }) {\n    d(() => e.animation);\n    const a = d(() => e.isStatus), o = d(() => e.autoHide), n = d(() => e.noCloseButton), s = d(() => e.noFade), r = d(() => e.noHoverPause);\n    d(() => e.solid), d(() => e.static);\n    const i = d(() => e.modelValue), v = R(!1), b = R(!1), h = R(!1), p = u(() => ({\n      [`b-toast-${e.variant}`]: e.variant !== null,\n      show: h.value || v.value\n    }));\n    let B, S, m;\n    const A = () => {\n      typeof B > \"u\" || (clearTimeout(B), B = void 0);\n    }, y = u(\n      () => (\n        // Minimum supported duration is 1 second\n        Math.max(lt(e.delay, 0), Ml)\n      )\n    ), k = () => {\n      i.value && (S = m = 0, A(), b.value = !0, jt(() => {\n        h.value = !1;\n      }));\n    }, w = () => {\n      A(), t(\"update:modelValue\", !0), S = m = 0, b.value = !1, Ce(() => {\n        jt(() => {\n          h.value = !0;\n        });\n      });\n    }, _ = () => {\n      if (!o.value || r.value || !B || m)\n        return;\n      const E = Date.now() - S;\n      E > 0 && (A(), m = Math.max(y.value - E, Ml));\n    }, C = () => {\n      (!o.value || r.value || !m) && (m = S = 0), T();\n    };\n    oe(i, (E) => {\n      E ? w() : k();\n    });\n    const T = () => {\n      A(), o.value && (B = setTimeout(k, m || y.value), S = Date.now(), m = 0);\n    }, c = () => {\n      v.value = !0, t(\"update:modelValue\", !0);\n    }, V = () => {\n      v.value = !1, T();\n    }, F = () => {\n      v.value = !0;\n    }, f = () => {\n      v.value = !1, m = S = 0, t(\"update:modelValue\", !1);\n    };\n    Wn(() => {\n      A(), o.value && t(\"destroyed\", e.id);\n    }), He(() => {\n      Ce(() => {\n        i.value && jt(() => {\n          w();\n        });\n      });\n    });\n    const I = () => {\n      Ce(() => {\n        jt(() => {\n          k();\n        });\n      });\n    };\n    return () => {\n      const E = () => {\n        const z = [], Z = Ne(Ki, { hide: k }, l);\n        Z ? z.push(ie(Z)) : e.title && z.push(ie(\"strong\", { class: \"me-auto\" }, e.title)), !n.value && z.length !== 0 && z.push(\n          ie(Ot, {\n            class: [\"btn-close\"],\n            onClick: () => {\n              k();\n            }\n          })\n        );\n        const te = [];\n        if (z.length > 0 && te.push(\n          ie(\n            e.headerTag,\n            {\n              class: \"toast-header\"\n            },\n            { default: () => z }\n          )\n        ), Ne(\"default\", { hide: k }, l) || e.body) {\n          const G = ie(\n            wt(e) ? \"b-link\" : \"div\",\n            {\n              class: [\"toast-body\", e.bodyClass],\n              onClick: wt(e) ? { click: I } : {}\n            },\n            Ne(\"default\", { hide: k }, l) || e.body\n          );\n          te.push(G);\n        }\n        return ie(\n          \"div\",\n          {\n            class: [\"toast\", e.toastClass, p.value],\n            tabindex: \"0\"\n          },\n          te\n        );\n      };\n      return ie(\n        \"div\",\n        {\n          class: [\"b-toast\"],\n          id: e.id,\n          role: b.value ? null : a.value ? \"status\" : \"alert\",\n          \"aria-live\": b.value ? null : a.value ? \"polite\" : \"assertive\",\n          \"aria-atomic\": b.value ? null : !0,\n          onmouseenter: _,\n          onmouseleave: C\n        },\n        [\n          ie(\n            At,\n            {\n              noFade: s.value,\n              onAfterEnter: V,\n              onBeforeEnter: c,\n              onAfterLeave: f,\n              onBeforeLeave: F\n            },\n            () => [h.value ? E() : \"\"]\n          )\n        ]\n      );\n    };\n  }\n}), Va = /* @__PURE__ */ N({\n  __name: \"BToaster\",\n  props: {\n    position: { default: \"top-right\" },\n    instance: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = {\n      \"top-left\": \"top-0 start-0\",\n      \"top-center\": \"top-0 start-50 translate-middle-x\",\n      \"top-right\": \"top-0 end-0\",\n      \"middle-left\": \"top-50 start-0 translate-middle-y\",\n      \"middle-center\": \"top-50 start-50 translate-middle\",\n      \"middle-right\": \"top-50 end-0 translate-middle-y\",\n      \"bottom-left\": \"bottom-0 start-0\",\n      \"bottom-center\": \"bottom-0 start-50 translate-middle-x\",\n      \"bottom-right\": \"bottom-0 end-0\"\n    }, a = u(() => l[t.position]), o = (n) => {\n      var s;\n      (s = t.instance) == null || s.remove(n);\n    };\n    return (n, s) => {\n      var r;\n      return g(), P(\"div\", {\n        class: H([[a.value], \"b-toaster position-fixed p-3\"]),\n        style: { \"z-index\": \"11\" }\n      }, [\n        (g(!0), P(ce, null, he((r = n.instance) == null ? void 0 : r.toasts(n.position).value, (i) => (g(), M(bn, {\n          id: i.options.id,\n          key: i.options.id,\n          modelValue: i.options.value,\n          \"onUpdate:modelValue\": (v) => i.options.value = v,\n          \"auto-hide\": i.options.autoHide,\n          delay: i.options.delay,\n          \"no-close-button\": i.options.noCloseButton,\n          title: i.content.title,\n          body: i.content.body,\n          component: i.content.body,\n          variant: i.options.variant,\n          onDestroyed: o\n        }, null, 8, [\"id\", \"modelValue\", \"onUpdate:modelValue\", \"auto-hide\", \"delay\", \"no-close-button\", \"title\", \"body\", \"component\", \"variant\"]))), 128))\n      ], 2);\n    };\n  }\n}), Yi = N({\n  slots: Object,\n  props: {\n    gutterX: { type: String, default: null },\n    gutterY: { type: String, default: null },\n    fluid: { type: [Boolean, String], default: !1 },\n    toast: { type: Object, default: void 0 },\n    position: { type: String, default: void 0 }\n  },\n  setup(e, { slots: t, expose: l }) {\n    const a = R();\n    let o;\n    const n = u(() => ({\n      container: !e.fluid,\n      \"container-fluid\": typeof e.fluid == \"boolean\" && e.fluid,\n      [`container-${e.fluid}`]: typeof e.fluid == \"string\",\n      [`gx-${e.gutterX}`]: e.gutterX !== null,\n      [`gy-${e.gutterY}`]: e.gutterY !== null\n    }));\n    return He(() => {\n      e.toast;\n    }), e.toast && (o = gn({ container: a, root: e.toast.root }), l({\n      // ...toastInstance?.useMethods,\n    })), () => {\n      var r;\n      const s = [];\n      return o == null || o.containerPositions.value.forEach((i) => {\n        s.push(ie(Va, { key: i, instance: o, position: i }));\n      }), ie(\"div\", { class: [n.value, e.position], ref: a }, [\n        ...s,\n        (r = t.default) == null ? void 0 : r.call(t)\n      ]);\n    };\n  },\n  methods: {}\n}), Ji = { class: \"visually-hidden\" }, Zi = [\"aria-labelledby\", \"role\"], hn = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BDropdown\",\n  props: {\n    ariaLabel: { default: void 0 },\n    id: { default: void 0 },\n    menuClass: { default: void 0 },\n    size: { default: \"md\" },\n    splitClass: { default: void 0 },\n    splitVariant: { default: void 0 },\n    text: { default: void 0 },\n    toggleClass: { default: void 0 },\n    autoClose: { type: [Boolean, String], default: !0 },\n    block: { type: [String, Boolean], default: !1 },\n    dark: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    isNav: { type: [String, Boolean], default: !1 },\n    dropup: { type: [String, Boolean], default: !1 },\n    dropend: { type: [String, Boolean], default: !1 },\n    dropstart: { type: [String, Boolean], default: !1 },\n    center: { type: [String, Boolean], default: !1 },\n    end: { type: [String, Boolean], default: !1 },\n    noFlip: { type: [String, Boolean], default: !1 },\n    noShift: { type: [String, Boolean], default: !1 },\n    offset: { default: 0 },\n    role: { default: \"menu\" },\n    split: { type: [String, Boolean], default: !1 },\n    splitButtonType: { default: \"button\" },\n    splitHref: { default: void 0 },\n    splitDisabled: { type: [String, Boolean], default: void 0 },\n    noCaret: { type: [String, Boolean], default: !1 },\n    toggleText: { default: \"Toggle dropdown\" },\n    variant: { default: \"secondary\" },\n    modelValue: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: !1 },\n    strategy: { default: \"absolute\" },\n    floatingMiddleware: { default: void 0 },\n    splitTo: { default: void 0 }\n  },\n  emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"click\", \"toggle\", \"update:modelValue\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = _e(() => a.id, \"dropdown\"), n = Se(a, \"modelValue\", l, { passive: !0 }), s = d(n), r = d(() => a.block), i = d(() => a.dark), v = d(() => a.dropup), b = d(() => a.dropend), h = d(() => a.isNav), p = d(() => a.dropstart), B = d(() => a.center), S = d(() => a.end), m = d(() => a.split), A = d(() => a.noCaret), y = d(() => a.noFlip), k = d(() => a.noShift), w = d(() => a.lazy), _ = d(() => a.splitDisabled), C = u(\n      () => typeof a.offset == \"string\" || typeof a.offset == \"number\" ? a.offset : NaN\n    ), T = bt(C, { method: \"parseInt\", nanToZero: !0 }), c = R(null), V = R(null), F = R(null), f = u(() => m.value ? V.value : F.value), I = u(\n      () => ai({\n        top: v.value,\n        start: p.value,\n        end: b.value,\n        alignCenter: B.value,\n        alignEnd: S.value\n      })\n    ), E = u(() => {\n      if (a.floatingMiddleware !== void 0)\n        return a.floatingMiddleware;\n      const L = typeof a.offset == \"string\" || typeof a.offset == \"number\" ? T.value : a.offset, x = [Fo(L)];\n      return y.value === !1 && x.push(Oo()), k.value === !1 && x.push(Po()), x;\n    }), { x: z, y: Z, strategy: te, update: G } = Mo(f, c, {\n      placement: I,\n      middleware: E,\n      strategy: a.strategy,\n      whileElementsMounted: Ho\n    }), W = u(() => ({\n      \"d-grid\": r.value,\n      dropup: v.value,\n      dropend: b.value,\n      dropstart: p.value,\n      \"d-flex\": r.value && m.value\n    })), X = u(() => [\n      m.value ? a.splitClass : a.toggleClass,\n      {\n        \"nav-link\": h.value,\n        \"dropdown-toggle\": !m.value,\n        \"dropdown-toggle-no-caret\": A.value && !m.value,\n        \"w-100\": m.value && r.value,\n        show: m.value ? void 0 : s.value\n      }\n    ]), ve = u(() => [\n      a.menuClass,\n      {\n        \"dropdown-menu-dark\": i.value\n      }\n    ]), ge = u(() => ({\n      \"aria-label\": a.ariaLabel,\n      \"aria-expanded\": m.value ? void 0 : s.value,\n      \"aria-haspopup\": m.value ? void 0 : \"menu\",\n      href: m.value ? a.splitHref : void 0,\n      to: m.value && a.splitTo ? a.splitTo : void 0\n    })), pe = () => {\n      l(\"toggle\");\n      const L = s.value, x = new Ge(L ? \"hide\" : \"show\");\n      if (l(L ? \"hide\" : \"show\", x), x.defaultPrevented) {\n        l(L ? \"hide-prevented\" : \"show-prevented\");\n        return;\n      }\n      n.value = !L, l(L ? \"hidden\" : \"shown\");\n    }, me = (L) => {\n      m.value ? l(\"click\", L) : pe();\n    };\n    Uo(\n      c,\n      () => {\n        s.value && (a.autoClose === !0 || a.autoClose === \"outside\") && de();\n      },\n      { ignore: [V, F] }\n    );\n    const q = () => {\n      s.value && (a.autoClose === !0 || a.autoClose === \"inside\") && de();\n    }, Q = () => {\n      n.value = !1;\n    }, re = () => {\n      n.value = !0;\n    }, de = () => {\n      n.value = !s.value;\n    };\n    return oe(s, G), t({\n      close: Q,\n      open: re,\n      toggle: de\n    }), De(To, {\n      id: o,\n      open: re,\n      close: Q,\n      toggle: de,\n      visible: s,\n      isNav: h\n    }), (L, x) => (g(), P(ce, null, [\n      K(\"div\", ee({\n        class: [W.value, \"btn-group\"]\n      }, L.$attrs), [\n        be(kt, ee({\n          id: $(o),\n          ref_key: \"splitButton\",\n          ref: F,\n          variant: L.splitVariant || L.variant,\n          size: L.size,\n          class: X.value,\n          disabled: $(_) || L.disabled,\n          type: L.splitButtonType\n        }, ge.value, {\n          onClick: me,\n          onKeydown: x[0] || (x[0] = It((D) => n.value = !$(s), [\"esc\"]))\n        }), {\n          default: j(() => [\n            O(L.$slots, \"button-content\", {}, () => [\n              ne(Y(L.text), 1)\n            ])\n          ]),\n          _: 3\n        }, 16, [\"id\", \"variant\", \"size\", \"class\", \"disabled\", \"type\"]),\n        $(m) ? (g(), M(kt, {\n          key: 0,\n          ref_key: \"button\",\n          ref: V,\n          variant: L.variant,\n          size: L.size,\n          disabled: L.disabled,\n          class: H([[L.toggleClass, $(s) ? \"show\" : void 0], \"dropdown-toggle-split dropdown-toggle\"]),\n          \"aria-expanded\": $(s),\n          \"aria-haspopup\": \"menu\",\n          onClick: pe\n        }, {\n          default: j(() => [\n            K(\"span\", Ji, [\n              O(L.$slots, \"toggle-text\", {}, () => [\n                ne(Y(L.toggleText), 1)\n              ])\n            ])\n          ]),\n          _: 3\n        }, 8, [\"variant\", \"size\", \"disabled\", \"class\", \"aria-expanded\"])) : J(\"\", !0)\n      ], 16),\n      !$(w) || $(s) ? rt((g(), P(\"ul\", {\n        key: 0,\n        ref_key: \"floating\",\n        ref: c,\n        style: ze({\n          position: $(te) === \"absolute\" ? void 0 : \"fixed\",\n          top: `${$(Z)}px`,\n          left: `${$(z)}px`,\n          width: \"max-content\"\n        }),\n        class: H([\"dropdown-menu show\", ve.value]),\n        \"aria-labelledby\": $(o),\n        role: L.role,\n        onClick: q\n      }, [\n        O(L.$slots, \"default\")\n      ], 14, Zi)), [\n        [ua, $(w) || $(s)]\n      ]) : J(\"\", !0)\n    ], 64));\n  }\n}), Qi = { role: \"presentation\" }, eu = /* @__PURE__ */ N({\n  __name: \"BDropdownDivider\",\n  props: {\n    tag: { default: \"hr\" }\n  },\n  setup(e) {\n    return (t, l) => (g(), P(\"li\", Qi, [\n      (g(), M(le(t.tag), {\n        class: \"dropdown-divider\",\n        role: \"separator\",\n        \"aria-orientation\": \"horizontal\"\n      }))\n    ]));\n  }\n}), tu = { role: \"presentation\" }, au = { class: \"px-4 py-3\" }, lu = /* @__PURE__ */ N({\n  __name: \"BDropdownForm\",\n  setup(e) {\n    return (t, l) => (g(), P(\"li\", tu, [\n      K(\"form\", au, [\n        O(t.$slots, \"default\")\n      ])\n    ]));\n  }\n}), ou = { role: \"presentation\" }, nu = [\"id\", \"aria-describedby\"], su = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BDropdownGroup\",\n  props: {\n    id: { default: void 0 },\n    ariaDescribedby: { default: void 0 },\n    header: { default: void 0 },\n    headerClass: { default: void 0 },\n    headerTag: { default: \"header\" },\n    headerVariant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = u(\n      () => t.id ? `${t.id}_group_dd_header` : void 0\n    ), a = u(\n      () => t.headerTag === \"header\" ? void 0 : \"heading\"\n    ), o = u(() => [\n      t.headerClass,\n      {\n        [`text-${t.headerVariant}`]: t.headerVariant !== null\n      }\n    ]);\n    return (n, s) => (g(), P(\"li\", ou, [\n      (g(), M(le(n.headerTag), {\n        id: l.value,\n        class: H([\"dropdown-header\", o.value]),\n        role: a.value\n      }, {\n        default: j(() => [\n          O(n.$slots, \"header\", {}, () => [\n            ne(Y(n.header), 1)\n          ])\n        ]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"role\"])),\n      K(\"ul\", ee({\n        id: n.id,\n        role: \"group\",\n        class: \"list-unstyled\"\n      }, n.$attrs, {\n        \"aria-describedby\": n.ariaDescribedby || l.value\n      }), [\n        O(n.$slots, \"default\")\n      ], 16, nu)\n    ]));\n  }\n}), ru = { class: \"dropdown-header\" }, iu = /* @__PURE__ */ N({\n  __name: \"BDropdownHeader\",\n  setup(e) {\n    return (t, l) => (g(), P(\"li\", null, [\n      K(\"h6\", ru, [\n        O(t.$slots, \"default\")\n      ])\n    ]));\n  }\n}), uu = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BDropdownItem\",\n  props: {\n    href: { default: void 0 },\n    linkClass: { default: void 0 },\n    active: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    rel: { default: void 0 },\n    target: { default: \"_self\" },\n    variant: { default: null }\n  },\n  emits: [\"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = za(), s = u(() => [\n      l.linkClass,\n      {\n        active: a.value,\n        disabled: o.value,\n        [`text-${l.variant}`]: l.variant !== null\n      }\n    ]), r = u(\n      () => l.href ? \"a\" : n.to ? Xe : \"button\"\n    ), i = u(() => ({\n      disabled: o.value,\n      \"aria-current\": a.value ? !0 : null,\n      href: r.value === \"a\" ? l.href : null,\n      rel: l.rel,\n      type: r.value === \"button\" ? \"button\" : null,\n      target: l.target,\n      ...n.to ? { activeClass: \"active\", ...n } : n\n    })), v = Oe(Ga, null), b = Oe(To, null), h = Oe(Wa, null), p = (B) => {\n      var S, m;\n      t(\"click\", B), h !== null && ((S = v == null ? void 0 : v.close) == null || S.call(v)), (m = b == null ? void 0 : b.close) == null || m.call(b);\n    };\n    return (B, S) => (g(), P(\"li\", {\n      role: \"presentation\",\n      class: H(B.$attrs.class)\n    }, [\n      (g(), M(le(r.value), ee({\n        class: [\"dropdown-item\", s.value]\n      }, i.value, { onClick: p }), {\n        default: j(() => [\n          O(B.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"class\"]))\n    ], 2));\n  }\n}), du = [\"disabled\"], cu = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BDropdownItemButton\",\n  props: {\n    buttonClass: { default: void 0 },\n    active: { type: [String, Boolean], default: !1 },\n    activeClass: { default: \"active\" },\n    disabled: { type: [String, Boolean], default: !1 },\n    variant: { default: null }\n  },\n  emits: [\"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = u(() => [\n      l.buttonClass,\n      {\n        [l.activeClass]: a.value,\n        disabled: o.value,\n        [`text-${l.variant}`]: l.variant !== null\n      }\n    ]), s = (r) => t(\"click\", r);\n    return (r, i) => (g(), P(\"li\", {\n      role: \"presentation\",\n      class: H(r.$attrs.class)\n    }, [\n      K(\"button\", {\n        role: \"menu\",\n        type: \"button\",\n        class: H([\"dropdown-item\", n.value]),\n        disabled: $(o),\n        onClick: s\n      }, [\n        O(r.$slots, \"default\")\n      ], 10, du)\n    ], 2));\n  }\n}), fu = { role: \"presentation\" }, vu = { class: \"px-4 py-1 mb-0 text-muted\" }, pu = /* @__PURE__ */ N({\n  __name: \"BDropdownText\",\n  props: {\n    text: { default: \"\" }\n  },\n  setup(e) {\n    return (t, l) => (g(), P(\"li\", fu, [\n      K(\"p\", vu, [\n        O(t.$slots, \"default\", {}, () => [\n          ne(Y(t.text), 1)\n        ])\n      ])\n    ]));\n  }\n}), mu = [\"id\", \"novalidate\", \"onSubmit\"], Bn = /* @__PURE__ */ N({\n  __name: \"BForm\",\n  props: {\n    id: { default: void 0 },\n    floating: { type: [String, Boolean], default: !1 },\n    novalidate: { type: [String, Boolean], default: !1 },\n    validated: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"submit\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.floating), o = d(() => l.novalidate), n = d(() => l.validated), s = u(() => ({\n      \"form-floating\": a.value,\n      \"was-validated\": n.value\n    })), r = (i) => t(\"submit\", i);\n    return (i, v) => (g(), P(\"form\", {\n      id: i.id,\n      novalidate: $(o),\n      class: H(s.value),\n      onSubmit: ot(r, [\"prevent\"])\n    }, [\n      O(i.$slots, \"default\")\n    ], 42, mu));\n  }\n}), gu = { class: \"form-floating\" }, yu = [\"for\"], bu = /* @__PURE__ */ N({\n  __name: \"BFormFloatingLabel\",\n  props: {\n    labelFor: { default: void 0 },\n    label: { default: void 0 },\n    text: { default: void 0 }\n  },\n  setup(e) {\n    return (t, l) => (g(), P(\"div\", gu, [\n      O(t.$slots, \"default\", {}, () => [\n        ne(Y(t.text), 1)\n      ]),\n      K(\"label\", { for: t.labelFor }, [\n        O(t.$slots, \"label\", {}, () => [\n          ne(Y(t.label), 1)\n        ])\n      ], 8, yu)\n    ]));\n  }\n}), Aa = /* @__PURE__ */ N({\n  __name: \"BFormInvalidFeedback\",\n  props: {\n    ariaLive: { default: void 0 },\n    forceShow: { type: [String, Boolean], default: !1 },\n    id: { default: void 0 },\n    text: { default: void 0 },\n    role: { default: void 0 },\n    state: { type: [String, Boolean, null], default: null },\n    tag: { default: \"div\" },\n    tooltip: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.forceShow), a = d(() => t.state), o = d(() => t.tooltip), n = u(\n      () => l.value === !0 || a.value === !1\n    ), s = u(() => ({\n      \"d-block\": n.value,\n      \"invalid-feedback\": !o.value,\n      \"invalid-tooltip\": o.value\n    })), r = u(() => ({\n      id: t.id,\n      role: t.role,\n      \"aria-live\": t.ariaLive,\n      \"aria-atomic\": t.ariaLive ? !0 : void 0\n    }));\n    return (i, v) => (g(), M(le(i.tag), ee({ class: s.value }, r.value), {\n      default: j(() => [\n        O(i.$slots, \"default\", {}, () => [\n          ne(Y(i.text), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"class\"]));\n  }\n}), Jt = /* @__PURE__ */ N({\n  __name: \"BFormRow\",\n  props: {\n    tag: { default: \"div\" }\n  },\n  setup(e) {\n    return (t, l) => (g(), M(le(t.tag), { class: \"row d-flex flex-wrap\" }, {\n      default: j(() => [\n        O(t.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Oa = /* @__PURE__ */ N({\n  __name: \"BFormText\",\n  props: {\n    id: { default: void 0 },\n    inline: { type: [String, Boolean], default: !1 },\n    tag: { default: \"small\" },\n    text: { default: void 0 },\n    textVariant: { default: \"muted\" }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.inline), a = u(() => ({\n      [`text-${t.textVariant}`]: t.textVariant !== null,\n      \"form-text\": !l.value\n    }));\n    return (o, n) => (g(), M(le(o.tag), {\n      id: o.id,\n      class: H(a.value)\n    }, {\n      default: j(() => [\n        O(o.$slots, \"default\", {}, () => [\n          ne(Y(o.text), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"id\", \"class\"]));\n  }\n}), Fa = /* @__PURE__ */ N({\n  __name: \"BFormValidFeedback\",\n  props: {\n    ariaLive: { default: void 0 },\n    forceShow: { type: [String, Boolean], default: !1 },\n    id: { default: void 0 },\n    role: { default: void 0 },\n    text: { default: void 0 },\n    state: { type: [String, Boolean, null], default: null },\n    tag: { default: \"div\" },\n    tooltip: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.forceShow), a = d(() => t.state), o = d(() => t.tooltip), n = u(\n      () => l.value === !0 || a.value === !0\n    ), s = u(() => ({\n      \"d-block\": n.value,\n      \"valid-feedback\": !o.value,\n      \"valid-tooltip\": o.value\n    })), r = u(() => t.ariaLive ? !0 : void 0);\n    return (i, v) => (g(), M(le(i.tag), {\n      id: i.id,\n      role: i.role,\n      \"aria-live\": i.ariaLive,\n      \"aria-atomic\": r.value,\n      class: H(s.value)\n    }, {\n      default: j(() => [\n        O(i.$slots, \"default\", {}, () => [\n          ne(Y(i.text), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"id\", \"role\", \"aria-live\", \"aria-atomic\", \"class\"]));\n  }\n}), hu = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"aria-required\", \"value\", \"indeterminate\"], Bu = [\"for\"], Sn = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BFormCheckbox\",\n  props: {\n    ariaLabel: { default: void 0 },\n    ariaLabelledBy: { default: void 0 },\n    form: { default: void 0 },\n    indeterminate: { type: [String, Boolean], default: void 0 },\n    name: { default: void 0 },\n    id: { default: void 0 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    plain: { type: [String, Boolean], default: !1 },\n    button: { type: [String, Boolean], default: !1 },\n    buttonGroup: { type: [String, Boolean], default: !1 },\n    switch: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    buttonVariant: { default: null },\n    inline: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: void 0 },\n    size: { default: void 0 },\n    state: { type: [String, Boolean, null], default: null },\n    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: !1 },\n    value: { type: [Array, Set, Boolean, String, Object, Number, null], default: !0 },\n    modelValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 }\n  },\n  emits: [\"update:modelValue\", \"input\", \"change\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Fe(), n = Se(a, \"modelValue\", l, { passive: !0 }), s = _e(() => a.id, \"form-check\"), r = d(() => a.indeterminate), i = d(() => a.autofocus), v = d(() => a.plain), b = d(() => a.button), h = d(() => a.buttonGroup), p = d(() => a.switch), B = d(() => a.disabled), S = d(() => a.inline), m = d(() => a.required), A = d(() => a.state), y = Oe(Co, null), k = R(null), { focused: w } = Ee(k, {\n      initialValue: i.value\n    }), _ = u(() => !Ae(o.default)), C = u({\n      get: () => y !== null ? y.modelValue.value.map((E) => JSON.stringify(E)).includes(JSON.stringify(a.value)) : JSON.stringify(n.value) === JSON.stringify(a.value),\n      set: (E) => {\n        const z = E ? a.value : a.uncheckedValue;\n        l(\"input\", z), n.value = z, Ce(() => {\n          l(\"change\", z);\n        });\n      }\n    });\n    oe(n, (E) => {\n      if (y !== null) {\n        if (E === !1) {\n          y.remove(a.value);\n          return;\n        }\n        y.set(a.value);\n      }\n    });\n    const T = u(\n      () => !!(a.name ?? (y == null ? void 0 : y.name.value)) && (m.value || (y == null ? void 0 : y.required.value))\n    ), c = u(\n      () => h.value || ((y == null ? void 0 : y.buttons.value) ?? !1)\n    ), V = u(() => ({\n      plain: v.value || ((y == null ? void 0 : y.plain.value) ?? !1),\n      button: b.value || ((y == null ? void 0 : y.buttons.value) ?? !1),\n      inline: S.value || ((y == null ? void 0 : y.inline.value) ?? !1),\n      switch: p.value || ((y == null ? void 0 : y.switch.value) ?? !1),\n      state: A.value || (y == null ? void 0 : y.state.value),\n      size: a.size !== void 0 ? a.size : (y == null ? void 0 : y.size.value) ?? \"md\",\n      // This is where the true default is made\n      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (y == null ? void 0 : y.buttonVariant.value) ?? \"secondary\"\n      // This is where the true default is made\n    })), F = Yo(V), f = Jo(V), I = Zo(V);\n    return t({\n      focus: () => {\n        w.value = !0;\n      },\n      blur: () => {\n        w.value = !1;\n      }\n    }), (E, z) => (g(), M(Qa, {\n      skip: c.value,\n      class: H($(F))\n    }, {\n      default: j(() => {\n        var Z, te, G;\n        return [\n          rt(K(\"input\", ee({ id: $(s) }, E.$attrs, {\n            ref_key: \"input\",\n            ref: k,\n            \"onUpdate:modelValue\": z[0] || (z[0] = (W) => C.value = W),\n            class: $(f),\n            type: \"checkbox\",\n            disabled: $(B) || ((Z = $(y)) == null ? void 0 : Z.disabled.value),\n            required: T.value || void 0,\n            name: E.name || ((te = $(y)) == null ? void 0 : te.name.value),\n            form: E.form || ((G = $(y)) == null ? void 0 : G.form.value),\n            \"aria-label\": E.ariaLabel,\n            \"aria-labelledby\": E.ariaLabelledBy,\n            \"aria-required\": T.value || void 0,\n            value: E.value,\n            indeterminate: $(r)\n          }), null, 16, hu), [\n            [Un, C.value]\n          ]),\n          _.value || $(v) === !1 ? (g(), P(\"label\", {\n            key: 0,\n            for: $(s),\n            class: H($(I))\n          }, [\n            O(E.$slots, \"default\")\n          ], 10, Bu)) : J(\"\", !0)\n        ];\n      }),\n      _: 3\n    }, 8, [\"skip\", \"class\"]));\n  }\n}), Su = [\"id\"], wu = [\"innerHTML\"], _u = [\"textContent\"], $u = /* @__PURE__ */ N({\n  __name: \"BFormCheckboxGroup\",\n  props: {\n    id: { default: void 0 },\n    form: { default: void 0 },\n    modelValue: { default: () => [] },\n    ariaInvalid: { type: [String, Boolean], default: void 0 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    buttonVariant: { default: \"secondary\" },\n    buttons: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    disabledField: { default: \"disabled\" },\n    htmlField: { default: \"html\" },\n    name: { default: void 0 },\n    options: { default: () => [] },\n    plain: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    size: { default: \"md\" },\n    stacked: { type: [String, Boolean], default: !1 },\n    state: { type: [String, Boolean, null], default: null },\n    switches: { type: [String, Boolean], default: !1 },\n    textField: { default: \"text\" },\n    validated: { type: [String, Boolean], default: !1 },\n    valueField: { default: \"value\" }\n  },\n  emits: [\"input\", \"update:modelValue\", \"change\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Se(a, \"modelValue\", l), n = _e(() => a.id, \"checkbox\"), s = _e(() => a.name, \"checkbox\"), r = d(() => a.autofocus), i = d(() => a.buttons), v = d(() => a.disabled), b = d(() => a.plain), h = d(() => a.required), p = d(() => a.stacked), B = d(() => a.state), S = d(() => a.switches), m = d(() => a.validated), A = R(null), { focused: y } = Ee(A, {\n      initialValue: r.value\n    });\n    De(Co, {\n      set: (T) => {\n        const c = [...o.value];\n        c.push(T), l(\"input\", c), o.value = c, Ce(() => {\n          l(\"change\", c);\n        });\n      },\n      remove: (T) => {\n        const c = [...o.value];\n        c.splice(o.value.indexOf(T), 1), l(\"input\", c), o.value = c, Ce(() => {\n          l(\"change\", c);\n        });\n      },\n      modelValue: u(() => o.value),\n      switch: S,\n      buttonVariant: ye(ke(a, \"buttonVariant\")),\n      form: ye(ke(a, \"form\")),\n      name: s,\n      state: B,\n      plain: b,\n      size: ye(ke(a, \"size\")),\n      inline: u(() => !p.value),\n      required: h,\n      buttons: i,\n      disabled: v\n    });\n    const k = u(\n      () => a.options.map(\n        (T, c) => typeof T == \"string\" || typeof T == \"number\" ? {\n          props: {\n            value: T,\n            disabled: v.value\n          },\n          text: T.toString(),\n          html: void 0,\n          self: Symbol(`checkboxGroupOptionItem${c}`)\n        } : {\n          props: {\n            value: T[a.valueField],\n            disabled: T[a.disabledField],\n            ...T.props ? T.props : {}\n          },\n          text: T[a.textField],\n          html: T[a.htmlField],\n          self: Symbol(`checkboxGroupOptionItem${c}`)\n        }\n      )\n    ), w = u(() => ({\n      required: h.value,\n      ariaInvalid: a.ariaInvalid,\n      state: B.value,\n      validated: m.value,\n      buttons: i.value,\n      stacked: p.value,\n      size: a.size\n    })), _ = Qo(w), C = en(w);\n    return t({\n      focus: () => {\n        y.value = !0;\n      },\n      blur: () => {\n        y.value = !1;\n      }\n    }), (T, c) => (g(), P(\"div\", ee($(_), {\n      id: $(n),\n      ref_key: \"element\",\n      ref: A,\n      role: \"group\",\n      class: [$(C), \"bv-no-focus-ring\"],\n      tabindex: \"-1\"\n    }), [\n      O(T.$slots, \"first\"),\n      (g(!0), P(ce, null, he(k.value, (V) => (g(), M(Sn, ee({\n        key: V.self\n      }, V.props), {\n        default: j(() => [\n          V.html ? (g(), P(\"span\", {\n            key: 0,\n            innerHTML: V.html\n          }, null, 8, wu)) : (g(), P(\"span\", {\n            key: 1,\n            textContent: Y(V.text)\n          }, null, 8, _u))\n        ]),\n        _: 2\n      }, 1040))), 128)),\n      O(T.$slots, \"default\")\n    ], 16, Su));\n  }\n}), Cu = [\"for\"], ku = [\"id\", \"form\", \"name\", \"multiple\", \"disabled\", \"capture\", \"accept\", \"required\", \"aria-required\", \"directory\", \"webkitdirectory\"], Tu = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BFormFile\",\n  props: {\n    accept: { default: \"\" },\n    autofocus: { type: [String, Boolean], default: !1 },\n    capture: { type: [Boolean, String], default: !1 },\n    directory: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    form: { default: void 0 },\n    id: { default: void 0 },\n    multiple: { type: [String, Boolean], default: !1 },\n    name: { default: void 0 },\n    noDrop: { type: [String, Boolean], default: !1 },\n    noTraverse: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    size: { default: void 0 },\n    state: { type: [String, Boolean, null], default: null },\n    modelValue: { default: null },\n    label: { default: \"\" },\n    labelClasses: { default: void 0 }\n  },\n  emits: [\"update:modelValue\", \"change\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Fe(), n = Se(a, \"modelValue\", l), s = _e(() => a.id), r = d(() => a.autofocus), i = d(() => a.directory), v = d(() => a.disabled), b = d(() => a.multiple), h = d(() => a.noDrop);\n    d(() => a.noTraverse);\n    const p = d(() => a.required), B = d(() => a.state), S = Vt(B), m = R(null), { focused: A } = Ee(m, { initialValue: r.value }), y = u(() => !Ae(o.label)), k = u(\n      () => typeof a.accept == \"string\" ? a.accept : a.accept.join(\",\")\n    ), w = u(\n      () => a.capture === \"user\" || a.capture === \"environment\" ? a.capture : Ra(a.capture)\n    ), _ = u(() => [\n      S.value,\n      {\n        [`form-control-${a.size}`]: a.size !== void 0\n      }\n    ]), C = (V) => {\n      var f, I;\n      const F = ((f = m.value) == null ? void 0 : f.files) === null || ((I = m.value) == null ? void 0 : I.files) === void 0 ? null : [...m.value.files];\n      n.value = F === null ? null : b.value === !0 ? F : F[0], l(\"change\", V);\n    }, T = (V) => {\n      h.value === !0 && V.preventDefault();\n    }, c = () => {\n      n.value = null;\n    };\n    return oe(n, (V) => {\n      V === null && m.value !== null && (m.value.value = \"\");\n    }), t({\n      focus: () => {\n        A.value = !0;\n      },\n      blur: () => {\n        A.value = !1;\n      },\n      reset: c\n    }), (V, F) => (g(), P(ce, null, [\n      y.value || V.label ? (g(), P(\"label\", {\n        key: 0,\n        for: $(s),\n        class: H([\"form-label\", V.labelClasses])\n      }, [\n        O(V.$slots, \"label\", {}, () => [\n          ne(Y(V.label), 1)\n        ])\n      ], 10, Cu)) : J(\"\", !0),\n      K(\"input\", ee({ id: $(s) }, V.$attrs, {\n        ref_key: \"input\",\n        ref: m,\n        type: \"file\",\n        class: [\"form-control\", _.value],\n        form: V.form,\n        name: V.name,\n        multiple: $(b),\n        disabled: $(v),\n        capture: w.value,\n        accept: k.value || void 0,\n        required: $(p) || void 0,\n        \"aria-required\": $(p) || void 0,\n        directory: $(i),\n        webkitdirectory: $(i),\n        onChange: C,\n        onDrop: T\n      }), null, 16, ku)\n    ], 64));\n  }\n}), wn = [\"input\", \"select\", \"textarea\"], Vu = wn.map((e) => `${e}:not([disabled])`).join(), Au = [...wn, \"a\", \"button\", \"label\"], Ou = \"label\", Fu = \"invalid-feedback\", Pu = \"valid-feedback\", Eu = \"description\", Iu = \"default\", xu = N({\n  components: { BCol: Pt, BFormInvalidFeedback: Aa, BFormRow: Jt, BFormText: Oa, BFormValidFeedback: Fa },\n  props: {\n    contentCols: { type: [Boolean, String, Number], default: void 0 },\n    contentColsLg: { type: [Boolean, String, Number], default: void 0 },\n    contentColsMd: { type: [Boolean, String, Number], default: void 0 },\n    contentColsSm: { type: [Boolean, String, Number], default: void 0 },\n    contentColsXl: { type: [Boolean, String, Number], default: void 0 },\n    description: { type: [String], default: void 0 },\n    disabled: { type: [Boolean, String], default: !1 },\n    feedbackAriaLive: { type: String, default: \"assertive\" },\n    id: { type: String, default: void 0 },\n    invalidFeedback: { type: String, default: void 0 },\n    label: { type: String, default: void 0 },\n    labelAlign: { type: [Boolean, String, Number], default: void 0 },\n    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },\n    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },\n    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },\n    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },\n    labelClass: { type: [Array, Object, String], default: void 0 },\n    labelCols: { type: [Boolean, String, Number], default: void 0 },\n    labelColsLg: { type: [Boolean, String, Number], default: void 0 },\n    labelColsMd: { type: [Boolean, String, Number], default: void 0 },\n    labelColsSm: { type: [Boolean, String, Number], default: void 0 },\n    labelColsXl: { type: [Boolean, String, Number], default: void 0 },\n    labelFor: { type: String, default: void 0 },\n    labelSize: { type: String, default: void 0 },\n    labelSrOnly: { type: [Boolean, String], default: !1 },\n    state: { type: [Boolean, String], default: null },\n    tooltip: { type: [Boolean, String], default: !1 },\n    validFeedback: { type: String, default: void 0 },\n    validated: { type: [Boolean, String], default: !1 },\n    floating: { type: [Boolean, String], default: !1 }\n  },\n  setup(e, { attrs: t }) {\n    const l = d(() => e.disabled), a = d(() => e.labelSrOnly), o = d(() => e.state), n = d(() => e.tooltip), s = d(() => e.validated), r = d(() => e.floating), i = null, v = [\"xs\", \"sm\", \"md\", \"lg\", \"xl\"], b = (C, T) => v.reduce((c, V) => {\n      const F = vl(V === \"xs\" ? \"\" : V, `${T}Align`), f = C[F] || null;\n      return f && (V === \"xs\" ? c.push(`text-${f}`) : c.push(`text-${V}-${f}`)), c;\n    }, []), h = (C, T) => v.reduce((c, V) => {\n      const F = vl(V === \"xs\" ? \"\" : V, `${T}Cols`);\n      let f = C[F];\n      return f = f === \"\" ? !0 : f || !1, typeof f != \"boolean\" && f !== \"auto\" && (f = Vs(f, 0), f = f > 0 ? f : !1), f && (V === \"xs\" ? c[typeof f == \"boolean\" ? \"col\" : \"cols\"] = f : c[V || (typeof f == \"boolean\" ? \"col\" : \"cols\")] = f), c;\n    }, {}), p = R(), B = (C, T = null) => {\n      if (ja && e.labelFor) {\n        const c = go(`#${is(e.labelFor)}`, p);\n        if (c) {\n          const V = \"aria-describedby\", F = (C || \"\").split(Kt), f = (T || \"\").split(Kt), I = (qa(c, V) || \"\").split(Kt).filter((E) => !f.includes(E)).concat(F).filter((E, z, Z) => Z.indexOf(E) === z).filter((E) => E).join(\" \").trim();\n          I ? $s(c, V, I) : Cs(c, V);\n        }\n      }\n    }, S = u(() => h(e, \"content\")), m = u(() => b(e, \"label\")), A = u(() => h(e, \"label\")), y = u(\n      () => (\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(S.value).length > 0 || Object.keys(A.value).length > 0\n      )\n    ), k = Vt(o), w = u(\n      () => ca(t.ariaInvalid, o.value)\n    );\n    return oe(\n      () => i,\n      (C, T) => {\n        C !== T && B(C, T);\n      }\n    ), He(() => {\n      Ce(() => {\n        B(i);\n      });\n    }), {\n      disabledBoolean: l,\n      labelSrOnlyBoolean: a,\n      stateBoolean: o,\n      tooltipBoolean: n,\n      validatedBoolean: s,\n      floatingBoolean: r,\n      ariaDescribedby: i,\n      computedAriaInvalid: w,\n      contentColProps: S,\n      isHorizontal: y,\n      labelAlignClasses: m,\n      labelColProps: A,\n      onLegendClick: (C) => {\n        if (e.labelFor)\n          return;\n        const { target: T } = C, c = T ? T.tagName : \"\";\n        if (Au.indexOf(c) !== -1)\n          return;\n        const V = ws(Vu, p).filter(Ss);\n        V.length === 1 && hs(V[0]);\n      },\n      stateClass: k\n    };\n  },\n  render() {\n    const e = this.$props, t = this.$slots, l = _e(), a = !e.labelFor;\n    let o = null;\n    const n = Ne(Ou, {}, t) || e.label, s = n ? at(\"_BV_label_\") : null;\n    if (n || this.isHorizontal) {\n      const _ = a ? \"legend\" : \"label\";\n      if (this.labelSrOnlyBoolean)\n        n && (o = ie(\n          _,\n          {\n            class: \"visually-hidden\",\n            id: s,\n            for: e.labelFor || null\n          },\n          n\n        )), this.isHorizontal ? o = ie(Pt, this.labelColProps, { default: () => o }) : o = ie(\"div\", {}, [o]);\n      else {\n        const C = {\n          onClick: a ? this.onLegendClick : null,\n          ...this.isHorizontal ? this.labelColProps : {},\n          tag: this.isHorizontal ? _ : null,\n          id: s,\n          for: e.labelFor || null,\n          tabIndex: a ? \"-1\" : null,\n          class: [\n            this.isHorizontal ? \"col-form-label\" : \"form-label\",\n            {\n              \"bv-no-focus-ring\": a,\n              \"col-form-label\": this.isHorizontal || a,\n              \"pt-0\": !this.isHorizontal && a,\n              \"d-block\": !this.isHorizontal && !a,\n              [`col-form-label-${e.labelSize}`]: !!e.labelSize\n            },\n            this.labelAlignClasses,\n            e.labelClass\n          ]\n        };\n        this.isHorizontal ? o = ie(Pt, C, { default: () => n }) : o = ie(_, C, n);\n      }\n    }\n    let r = null;\n    const i = Ne(Fu, {}, t) || this.invalidFeedback, v = i ? at(\"_BV_feedback_invalid_\") : void 0;\n    i && (r = ie(\n      Aa,\n      {\n        ariaLive: e.feedbackAriaLive,\n        id: v,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      },\n      { default: () => i }\n    ));\n    let b = null;\n    const h = Ne(Pu, {}, t) || this.validFeedback, p = h ? at(\"_BV_feedback_valid_\") : void 0;\n    h && (b = ie(\n      Fa,\n      {\n        ariaLive: e.feedbackAriaLive,\n        id: p,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      },\n      { default: () => h }\n      // validFeedbackContent\n    ));\n    let B = null;\n    const S = Ne(Eu, {}, t) || this.description, m = S ? at(\"_BV_description_\") : void 0;\n    S && (B = ie(\n      Oa,\n      {\n        id: m\n      },\n      { default: () => S }\n    ));\n    const A = this.ariaDescribedby = [\n      m,\n      this.stateBoolean === !1 ? v : null,\n      this.stateBoolean === !0 ? p : null\n    ].filter((_) => _).join(\" \") || null, y = [\n      Ne(Iu, { ariaDescribedby: A, descriptionId: m, id: l, labelId: s }, t) || \"\",\n      r,\n      b,\n      B\n    ];\n    !this.isHorizontal && this.floatingBoolean && y.push(o);\n    let k = ie(\n      \"div\",\n      {\n        ref: \"content\",\n        class: [\n          {\n            \"form-floating\": !this.isHorizontal && this.floatingBoolean\n          }\n        ]\n      },\n      y\n    );\n    this.isHorizontal && (k = ie(Pt, { ref: \"content\", ...this.contentColProps }, { default: () => y }));\n    const w = {\n      class: [\n        this.stateClass,\n        {\n          \"was-validated\": this.validatedBoolean\n        }\n      ],\n      id: _e(() => e.id).value,\n      disabled: a ? this.disabledBoolean : null,\n      role: a ? null : \"group\",\n      \"aria-invalid\": this.computedAriaInvalid,\n      // Only apply `aria-labelledby` if we are a horizontal fieldset\n      // as the legend is no longer a direct child of fieldset\n      \"aria-labelledby\": a && this.isHorizontal ? s : null\n    };\n    return this.isHorizontal && !a ? ie(Jt, w, { default: () => [o, k] }) : ie(\n      a ? \"fieldset\" : \"div\",\n      w,\n      this.isHorizontal && a ? [ie(Jt, null, { default: () => [o, k] })] : this.isHorizontal || !this.floatingBoolean ? [o, k] : [k]\n    );\n  }\n}), Lu = [\"id\", \"name\", \"form\", \"type\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"min\", \"max\", \"step\", \"list\", \"aria-required\", \"aria-invalid\"], Nu = /* @__PURE__ */ N({\n  __name: \"BFormInput\",\n  props: {\n    max: { default: void 0 },\n    min: { default: void 0 },\n    step: { default: void 0 },\n    type: { default: \"text\" },\n    ariaInvalid: { type: [String, Boolean], default: void 0 },\n    autocomplete: { default: void 0 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    form: { default: void 0 },\n    formatter: { type: Function, default: void 0 },\n    id: { default: void 0 },\n    lazy: { type: [String, Boolean], default: !1 },\n    lazyFormatter: { type: [String, Boolean], default: !1 },\n    list: { default: void 0 },\n    modelValue: { default: \"\" },\n    name: { default: void 0 },\n    number: { type: [String, Boolean], default: !1 },\n    placeholder: { default: void 0 },\n    plaintext: { type: [String, Boolean], default: !1 },\n    readonly: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    size: { default: void 0 },\n    state: { type: [String, Boolean, null], default: null },\n    trim: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"update:modelValue\", \"change\", \"blur\", \"input\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: i, onBlur: v, focus: b, blur: h } = tn(a, l), p = d(() => a.disabled), B = d(() => a.required), S = d(() => a.readonly), m = d(() => a.plaintext), A = d(() => a.state), y = Vt(A), k = R(!1), w = u(() => {\n      const _ = a.type === \"range\", C = a.type === \"color\";\n      return [\n        y.value,\n        {\n          \"form-control-highlighted\": k.value,\n          \"form-range\": _,\n          \"form-control\": C || !a.plaintext && !_,\n          \"form-control-color\": C,\n          \"form-control-plaintext\": a.plaintext && !_ && !C,\n          [`form-control-${a.size}`]: !!a.size\n        }\n      ];\n    });\n    return t({\n      focus: b,\n      blur: h\n    }), (_, C) => (g(), P(\"input\", {\n      id: $(n),\n      ref_key: \"input\",\n      ref: o,\n      class: H(w.value),\n      name: _.name || void 0,\n      form: _.form || void 0,\n      type: _.type,\n      disabled: $(p),\n      placeholder: _.placeholder,\n      required: $(B) || void 0,\n      autocomplete: _.autocomplete || void 0,\n      readonly: $(S) || $(m),\n      min: _.min,\n      max: _.max,\n      step: _.step,\n      list: _.type !== \"password\" ? _.list : void 0,\n      \"aria-required\": $(B) || void 0,\n      \"aria-invalid\": $(s),\n      onInput: C[0] || (C[0] = (T) => $(r)(T)),\n      onChange: C[1] || (C[1] = (T) => $(i)(T)),\n      onBlur: C[2] || (C[2] = (T) => $(v)(T))\n    }, null, 42, Lu));\n  }\n}), zu = [\"id\", \"checked\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"value\", \"aria-required\"], Hu = [\"for\"], _n = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BFormRadio\",\n  props: {\n    ariaLabel: { default: void 0 },\n    ariaLabelledby: { default: void 0 },\n    form: { default: void 0 },\n    id: { default: void 0 },\n    name: { default: void 0 },\n    size: { default: void 0 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },\n    plain: { type: [String, Boolean], default: !1 },\n    button: { type: [String, Boolean], default: !1 },\n    buttonGroup: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    buttonVariant: { default: null },\n    inline: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    state: { type: [String, Boolean, null], default: null },\n    value: { type: [String, Boolean, Object, Number], default: !0 }\n  },\n  emits: [\"input\", \"change\", \"update:modelValue\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Fe(), n = Se(a, \"modelValue\", l, { passive: !0 }), s = _e(() => a.id, \"form-check\"), r = d(() => a.autofocus), i = d(() => a.plain), v = d(() => a.button), b = d(() => a.buttonGroup), h = d(() => a.disabled), p = d(() => a.inline), B = d(() => a.required), S = d(() => a.state), m = Oe(ko, null), A = R(null), { focused: y } = Ee(A, {\n      initialValue: r.value\n    }), k = u(() => !Ae(o.default)), w = u({\n      get: () => m !== null ? JSON.stringify(m.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(n.value) === JSON.stringify(a.value),\n      set: (f) => {\n        const I = f || f === \"\" || f === 0 ? a.value : !1;\n        l(\"input\", I), n.value = I, Ce(() => {\n          l(\"change\", I);\n        });\n      }\n    });\n    oe(\n      () => m == null ? void 0 : m.modelValue.value,\n      (f) => {\n        JSON.stringify(f) === JSON.stringify(a.value) !== !0 && (w.value = !1);\n      }\n    ), oe(n, (f) => {\n      m === null || f === !1 || m.set(a.value);\n    });\n    const _ = u(\n      () => !!(a.name ?? (m == null ? void 0 : m.name.value)) && (B.value || (m == null ? void 0 : m.required.value))\n    ), C = u(\n      () => b.value || ((m == null ? void 0 : m.buttons.value) ?? !1)\n    ), T = u(() => ({\n      plain: i.value || ((m == null ? void 0 : m.plain.value) ?? !1),\n      button: v.value || ((m == null ? void 0 : m.buttons.value) ?? !1),\n      inline: p.value || ((m == null ? void 0 : m.inline.value) ?? !1),\n      state: S.value || (m == null ? void 0 : m.state.value),\n      size: a.size !== void 0 ? a.size : (m == null ? void 0 : m.size.value) ?? \"md\",\n      // This is where the true default is made\n      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (m == null ? void 0 : m.buttonVariant.value) ?? \"secondary\"\n      // This is where the true default is made\n    })), c = Yo(T), V = Jo(T), F = Zo(T);\n    return t({\n      focus: () => {\n        y.value = !0;\n      },\n      blur: () => {\n        y.value = !1;\n      }\n    }), (f, I) => (g(), M(Qa, {\n      skip: C.value,\n      class: H($(c))\n    }, {\n      default: j(() => {\n        var E, z, Z;\n        return [\n          rt(K(\"input\", ee({ id: $(s) }, f.$attrs, {\n            ref_key: \"input\",\n            ref: A,\n            \"onUpdate:modelValue\": I[0] || (I[0] = (te) => w.value = te),\n            checked: w.value,\n            class: $(V),\n            type: \"radio\",\n            disabled: $(h) || ((E = $(m)) == null ? void 0 : E.disabled.value),\n            required: _.value || void 0,\n            name: f.name || ((z = $(m)) == null ? void 0 : z.name.value),\n            form: f.form || ((Z = $(m)) == null ? void 0 : Z.form.value),\n            \"aria-label\": f.ariaLabel,\n            \"aria-labelledby\": f.ariaLabelledby,\n            value: f.value,\n            \"aria-required\": _.value || void 0\n          }), null, 16, zu), [\n            [Xn, w.value]\n          ]),\n          k.value || $(i) === !1 ? (g(), P(\"label\", {\n            key: 0,\n            for: $(s),\n            class: H($(F))\n          }, [\n            O(f.$slots, \"default\")\n          ], 10, Hu)) : J(\"\", !0)\n        ];\n      }),\n      _: 3\n    }, 8, [\"skip\", \"class\"]));\n  }\n}), Ru = [\"id\"], Mu = [\"innerHTML\"], Du = [\"textContent\"], ju = /* @__PURE__ */ N({\n  __name: \"BFormRadioGroup\",\n  props: {\n    size: { default: \"md\" },\n    form: { default: void 0 },\n    id: { default: void 0 },\n    name: { default: void 0 },\n    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },\n    ariaInvalid: { type: [String, Boolean], default: void 0 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    buttonVariant: { default: \"secondary\" },\n    buttons: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    disabledField: { default: \"disabled\" },\n    htmlField: { default: \"html\" },\n    options: { default: () => [] },\n    plain: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    stacked: { type: [String, Boolean], default: !1 },\n    state: { type: [String, Boolean, null], default: null },\n    textField: { default: \"text\" },\n    validated: { type: [String, Boolean], default: !1 },\n    valueField: { default: \"value\" }\n  },\n  emits: [\"input\", \"update:modelValue\", \"change\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Se(a, \"modelValue\", l), n = _e(() => a.id, \"radio\"), s = _e(() => a.name, \"checkbox\"), r = d(() => a.autofocus), i = d(() => a.buttons), v = d(() => a.disabled), b = d(() => a.plain), h = d(() => a.required), p = d(() => a.stacked), B = d(() => a.state), S = d(() => a.validated), m = R(null), { focused: A } = Ee(m, {\n      initialValue: r.value\n    });\n    De(ko, {\n      set: (C) => {\n        l(\"input\", C), o.value = C, Ce(() => {\n          l(\"change\", C);\n        });\n      },\n      modelValue: u(() => o.value),\n      buttonVariant: ye(ke(a, \"buttonVariant\")),\n      form: ye(ke(a, \"form\")),\n      name: s,\n      buttons: i,\n      state: B,\n      plain: b,\n      size: ye(ke(a, \"size\")),\n      inline: u(() => !p.value),\n      required: h,\n      disabled: v\n    });\n    const y = u(\n      () => a.options.map(\n        (C, T) => typeof C == \"string\" || typeof C == \"number\" ? {\n          props: {\n            value: C,\n            disabled: v.value\n          },\n          text: C.toString(),\n          html: void 0,\n          self: Symbol(`radioGroupOptionItem${T}`)\n        } : {\n          props: {\n            value: C[a.valueField],\n            disabled: C[a.disabledField],\n            ...C.props ? C.props : {}\n          },\n          text: C[a.textField],\n          html: C[a.htmlField],\n          self: Symbol(`radioGroupOptionItem${T}`)\n        }\n      )\n    ), k = u(() => ({\n      required: h.value,\n      ariaInvalid: a.ariaInvalid,\n      state: B.value,\n      validated: S.value,\n      buttons: i.value,\n      stacked: p.value,\n      size: a.size\n    })), w = Qo(k), _ = en(k);\n    return t({\n      focus: () => {\n        A.value = !0;\n      },\n      blur: () => {\n        A.value = !1;\n      }\n    }), (C, T) => (g(), P(\"div\", ee($(w), {\n      id: $(n),\n      ref_key: \"element\",\n      ref: m,\n      role: \"radiogroup\",\n      class: [$(_), \"bv-no-focus-ring\"],\n      tabindex: \"-1\"\n    }), [\n      O(C.$slots, \"first\"),\n      (g(!0), P(ce, null, he(y.value, (c) => (g(), M(_n, ee({\n        key: c.self\n      }, c.props), {\n        default: j(() => [\n          c.html ? (g(), P(\"span\", {\n            key: 0,\n            innerHTML: c.html\n          }, null, 8, Mu)) : (g(), P(\"span\", {\n            key: 1,\n            textContent: Y(c.text)\n          }, null, 8, Du))\n        ]),\n        _: 2\n      }, 1040))), 128)),\n      O(C.$slots, \"default\")\n    ], 16, Ru));\n  }\n}), qu = [\"value\", \"disabled\"], ol = /* @__PURE__ */ N({\n  __name: \"BFormSelectOption\",\n  props: {\n    value: { default: void 0 },\n    disabled: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.disabled);\n    return (a, o) => (g(), P(\"option\", {\n      value: a.value,\n      disabled: $(l)\n    }, [\n      O(a.$slots, \"default\")\n    ], 8, qu));\n  }\n}), Gu = [\"label\"], $n = /* @__PURE__ */ N({\n  __name: \"BFormSelectOptionGroup\",\n  props: {\n    label: { default: void 0 },\n    disabledField: { default: \"disabled\" },\n    htmlField: { default: \"html\" },\n    options: { default: () => [] },\n    textField: { default: \"text\" },\n    valueField: { default: \"value\" }\n  },\n  setup(e) {\n    const t = e, l = u(\n      () => el(t.options, \"BFormSelectOptionGroup\", t)\n    );\n    return (a, o) => (g(), P(\"optgroup\", { label: a.label }, [\n      O(a.$slots, \"first\"),\n      (g(!0), P(ce, null, he(l.value, (n, s) => (g(), M(ol, ee({\n        key: s,\n        value: n.value,\n        disabled: n.disabled\n      }, a.$attrs, {\n        innerHTML: n.html || n.text\n      }), null, 16, [\"value\", \"disabled\", \"innerHTML\"]))), 128)),\n      O(a.$slots, \"default\")\n    ], 8, Gu));\n  }\n}), Wu = [\"id\", \"name\", \"form\", \"multiple\", \"size\", \"disabled\", \"required\", \"aria-required\", \"aria-invalid\"], Uu = /* @__PURE__ */ N({\n  __name: \"BFormSelect\",\n  props: {\n    ariaInvalid: { type: [String, Boolean], default: void 0 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    disabledField: { default: \"disabled\" },\n    form: { default: void 0 },\n    htmlField: { default: \"html\" },\n    id: { default: void 0 },\n    labelField: { default: \"label\" },\n    multiple: { type: [String, Boolean], default: !1 },\n    name: { default: void 0 },\n    options: { default: () => [] },\n    optionsField: { default: \"options\" },\n    plain: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    selectSize: { default: 0 },\n    size: { default: \"md\" },\n    state: { type: [String, Boolean, null], default: null },\n    textField: { default: \"text\" },\n    valueField: { default: \"value\" },\n    modelValue: { default: \"\" }\n  },\n  emits: [\"input\", \"update:modelValue\", \"change\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Se(a, \"modelValue\", l), n = _e(() => a.id, \"input\"), s = d(() => a.autofocus), r = d(() => a.disabled), i = d(() => a.multiple), v = d(() => a.plain), b = d(() => a.required), h = d(() => a.state), p = Vt(h), B = R(), { focused: S } = Ee(B, {\n      initialValue: s.value\n    }), m = u(() => [\n      p.value,\n      {\n        \"form-control\": v.value,\n        [`form-control-${a.size}`]: a.size !== \"md\" && v.value,\n        \"form-select\": !v.value,\n        [`form-select-${a.size}`]: a.size !== \"md\" && !v.value\n      }\n    ]), A = u(\n      () => a.selectSize || v.value ? a.selectSize : void 0\n    ), y = u(\n      () => ca(a.ariaInvalid, h.value)\n    ), k = u(() => el(a.options, \"BFormSelect\", a)), w = u({\n      get: () => o.value,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      set: (_) => {\n        l(\"input\", _), o.value = _, Ce(() => {\n          l(\"change\", _);\n        });\n      }\n    });\n    return t({\n      focus: () => {\n        S.value = !0;\n      },\n      blur: () => {\n        S.value = !1;\n      }\n    }), (_, C) => rt((g(), P(\"select\", ee({\n      id: $(n),\n      ref_key: \"input\",\n      ref: B\n    }, _.$attrs, {\n      \"onUpdate:modelValue\": C[0] || (C[0] = (T) => w.value = T),\n      class: m.value,\n      name: _.name,\n      form: _.form || void 0,\n      multiple: $(i) || void 0,\n      size: A.value,\n      disabled: $(r),\n      required: $(b) || void 0,\n      \"aria-required\": $(b) || void 0,\n      \"aria-invalid\": y.value\n    }), [\n      O(_.$slots, \"first\"),\n      (g(!0), P(ce, null, he(k.value, (T, c) => (g(), P(ce, { key: c }, [\n        Array.isArray(T.options) ? (g(), M($n, {\n          key: 0,\n          label: T.label,\n          options: T.options\n        }, null, 8, [\"label\", \"options\"])) : (g(), M(ol, {\n          key: 1,\n          value: T.value,\n          disabled: T.disabled,\n          innerHTML: T.html || T.text\n        }, null, 8, [\"value\", \"disabled\", \"innerHTML\"]))\n      ], 64))), 128)),\n      O(_.$slots, \"default\")\n    ], 16, Wu)), [\n      [Kn, w.value]\n    ]);\n  }\n}), Dl = [\n  \"ar\",\n  \"az\",\n  \"ckb\",\n  \"fa\",\n  \"he\",\n  \"ks\",\n  \"lrc\",\n  \"mzn\",\n  \"ps\",\n  \"sd\",\n  \"te\",\n  \"ug\",\n  \"ur\",\n  \"yi\"\n].map((e) => e.toLowerCase()), Xu = (e) => {\n  const t = Zt(e).toLowerCase().replace(as, \"\").split(\"-\"), l = t.slice(0, 2).join(\"-\"), [a] = t;\n  return Dl.includes(l) || Dl.includes(a);\n}, Ku = (e) => ps ? ba(e) ? e : { capture: !!e || !1 } : !!(ba(e) ? e.capture : e), Yu = (e, t, l, a) => {\n  e && e.addEventListener && e.addEventListener(t, l, Ku(a));\n}, Ju = (e, t, l, a) => {\n  e && e.removeEventListener && e.removeEventListener(t, l, a);\n}, jl = (e, t) => {\n  (e ? Yu : Ju)(...t);\n}, Ut = (e, { preventDefault: t = !0, propagation: l = !0, immediatePropagation: a = !1 } = {}) => {\n  t && e.preventDefault(), l && e.stopPropagation(), a && e.stopImmediatePropagation();\n}, Pa = \"ArrowDown\", Cn = \"End\", kn = \"Home\", Tn = \"PageDown\", Vn = \"PageUp\", Ea = \"ArrowUp\", ql = 1, Gl = 100, Wl = 1, Ul = 500, Xl = 100, Kl = 10, Yl = 4, Jl = [Ea, Pa, kn, Cn, Vn, Tn], Zu = N({\n  props: {\n    ariaControls: { type: String, default: void 0 },\n    ariaLabel: { type: String, default: void 0 },\n    labelIncrement: { type: String, default: \"Increment\" },\n    labelDecrement: { type: String, default: \"Decrement\" },\n    modelValue: { type: Number, default: null },\n    // V-model prop\n    name: { type: String, default: \"BFormSpinButton\" },\n    disabled: { type: [Boolean, String], default: !1 },\n    placeholder: { type: String, default: void 0 },\n    locale: { type: String, default: \"locale\" },\n    form: { type: String, default: void 0 },\n    inline: { type: Boolean, default: !1 },\n    size: { type: String, default: void 0 },\n    formatterFn: {\n      type: Function,\n      default: void 0\n    },\n    readonly: { type: Boolean, default: !1 },\n    vertical: { type: Boolean, default: !1 },\n    repeatDelay: {\n      type: [String, Number],\n      default: Ul\n    },\n    repeatInterval: {\n      type: [String, Number],\n      default: Xl\n    },\n    repeatStepMultiplier: {\n      type: [String, Number],\n      default: Yl\n    },\n    repeatThreshold: {\n      type: [String, Number],\n      default: Kl\n    },\n    required: { type: [Boolean, String], default: !1 },\n    step: { type: [String, Number], default: Wl },\n    min: { type: [String, Number], default: ql },\n    max: { type: [String, Number], default: Gl },\n    wrap: { type: Boolean, default: !1 },\n    state: { type: [Boolean, String], default: null }\n  },\n  emits: [\"update:modelValue\", \"change\"],\n  setup(e, { emit: t }) {\n    const l = Se(e, \"modelValue\", t), a = R(!1), o = u(() => 1), n = () => {\n      t(\"change\", r.value);\n    }, s = R(null), r = u({\n      get: () => l.value === null ? s.value : l.value,\n      set: (q) => {\n        l.value === null ? s.value = q : l.value = q;\n      }\n    });\n    let i, v, b = !1;\n    const h = u(() => Et(e.step, Wl)), p = u(() => Et(e.min, ql)), B = u(() => {\n      const q = Et(e.max, Gl), Q = h.value, re = p.value;\n      return Math.floor((q - re) / Q) * Q + re;\n    }), S = u(() => {\n      const q = lt(e.repeatDelay, 0);\n      return q > 0 ? q : Ul;\n    }), m = u(() => {\n      const q = lt(e.repeatInterval, 0);\n      return q > 0 ? q : Xl;\n    }), A = u(\n      () => Math.max(lt(e.repeatThreshold, Kl), 1)\n    ), y = u(\n      () => Math.max(lt(e.repeatStepMultiplier, Yl), 1)\n    ), k = u(() => {\n      const q = h.value;\n      return Math.floor(q) === q ? 0 : (q.toString().split(\".\")[1] || \"\").length;\n    }), w = u(() => Math.pow(10, k.value || 0)), _ = u(() => {\n      const { value: q } = r;\n      return q === null ? \"\" : q.toFixed(k.value);\n    }), C = u(() => {\n      const q = [e.locale];\n      return new Intl.NumberFormat(q).resolvedOptions().locale;\n    }), T = u(\n      () => (\n        //todo\n        Xu(C.value)\n      )\n    ), c = () => {\n      const q = k.value;\n      return new Intl.NumberFormat(C.value, {\n        style: \"decimal\",\n        useGrouping: !1,\n        minimumIntegerDigits: 1,\n        minimumFractionDigits: q,\n        maximumFractionDigits: q,\n        notation: \"standard\"\n      }).format;\n    }, V = u(() => e.formatterFn ?? c()), F = u(() => ({\n      role: \"group\",\n      lang: C.value,\n      tabindex: e.disabled ? null : \"-1\",\n      title: e.ariaLabel\n    })), f = u(() => l.value !== null || s.value !== null), I = u(() => ({\n      dir: T.value,\n      spinId: o.value,\n      tabindex: e.disabled ? null : \"0\",\n      role: \"spinbutton\",\n      \"aria-live\": \"off\",\n      \"aria-label\": e.ariaLabel || null,\n      \"aria-controls\": e.ariaControls || null,\n      \"aria-invalid\": e.state === !1 || !f.value && e.required ? !0 : null,\n      \"aria-required\": e.required ? !0 : null,\n      \"aria-valuemin\": p.value,\n      \"aria-valuemax\": B.value,\n      \"aria-valuenow\": r.value !== null ? r.value : null,\n      \"aria-valuetext\": r.value !== null ? V.value(r.value) : null\n    })), E = (q) => {\n      let { value: Q } = r;\n      if (!e.disabled && Q !== null) {\n        const re = h.value * q, de = p.value, L = B.value, x = w.value, { wrap: D } = e;\n        Q = Math.round((Q - de) / re) * re + de + re, Q = Math.round(Q * x) / x, r.value = Q > L ? D ? de : L : Q < de ? D ? L : de : Q;\n      }\n    }, z = (q = 1) => {\n      r.value === null ? r.value = p.value : E(1 * q);\n    }, Z = (q = 1) => {\n      r.value === null ? r.value = e.wrap ? B.value : p.value : E(-1 * q);\n    }, te = (q) => {\n      const { code: Q, altKey: re, ctrlKey: de, metaKey: L } = q;\n      if (!(e.disabled || e.readonly || re || de || L) && Jl.includes(Q)) {\n        if (Ut(q, { propagation: !1 }), b)\n          return;\n        pe(), [Ea, Pa].includes(Q) ? (b = !0, Q === Ea ? W(q, z) : Q === Pa && W(q, Z)) : Q === Vn ? z(y.value) : Q === Tn ? Z(y.value) : Q === kn ? r.value = p.value : Q === Cn && (r.value = B.value);\n      }\n    }, G = (q) => {\n      const { code: Q, altKey: re, ctrlKey: de, metaKey: L } = q;\n      e.disabled || e.readonly || re || de || L || Jl.includes(Q) && (Ut(q, { propagation: !1 }), pe(), b = !1, n());\n    }, W = (q, Q) => {\n      const { type: re } = q || {};\n      if (!e.disabled && !e.readonly) {\n        if (X(q) && re === \"mousedown\" && q.button)\n          return;\n        pe(), Q(1);\n        const de = A.value, L = y.value, x = S.value, D = m.value;\n        i = setTimeout(() => {\n          let ae = 0;\n          v = setInterval(() => {\n            Q(ae < de ? 1 : L), ae++;\n          }, D);\n        }, x);\n      }\n    };\n    function X(q) {\n      return q.type === \"mouseup\" || q.type === \"mousedown\";\n    }\n    const ve = (q) => {\n      X(q) && q.type === \"mouseup\" && q.button || (Ut(q, { propagation: !1 }), pe(), ge(!1), n());\n    }, ge = (q) => {\n      try {\n        jl(q, [document.body, \"mouseup\", ve, !1]), jl(q, [document.body, \"touchend\", ve, !1]);\n      } catch {\n        return 0;\n      }\n    }, pe = () => {\n      clearTimeout(i), clearInterval(v), i = void 0, v = void 0;\n    }, me = (q, Q, re, de, L, x, D) => {\n      const ae = ie(re, {\n        props: { scale: a.value ? 1.5 : 1.25 },\n        attrs: { \"aria-hidden\": !0 }\n      }), ue = { hasFocus: a.value }, U = (se) => {\n        !e.disabled && !e.readonly && (Ut(se, { propagation: !1 }), ge(!0), W(se, q));\n      };\n      return ie(\n        \"button\",\n        {\n          class: [{ \"py-0\": !e.vertical }, \"btn\", \"btn-sm\", \"border-0\", \"rounded-0\"],\n          tabindex: \"-1\",\n          type: \"button\",\n          disabled: e.disabled || e.readonly || x,\n          \"aria-disabled\": e.disabled || e.readonly || x ? !0 : null,\n          \"aria-controls\": o.value,\n          \"aria-label\": Q || null,\n          \"aria-keyshortcuts\": L || null,\n          onmousedown: U,\n          ontouchstart: U\n          // 'ref': keyRef,\n        },\n        [Ne(D, ue) || ae]\n      );\n    };\n    return () => {\n      const q = me(\n        z,\n        e.labelIncrement,\n        ie(\n          \"svg\",\n          {\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"16\",\n            height: \"16\",\n            fill: \"currentColor\",\n            class: \"bi bi-plus\",\n            viewBox: \"0 0 16 16\"\n          },\n          ie(\"path\", {\n            d: \"M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z\"\n          })\n        ),\n        \"inc\",\n        \"ArrowUp\",\n        !1,\n        \"increment\"\n      ), Q = me(\n        Z,\n        e.labelDecrement,\n        ie(\n          \"svg\",\n          {\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"16\",\n            height: \"16\",\n            fill: \"currentColor\",\n            class: \"bi bi-dash\",\n            viewBox: \"0 0 16 16\"\n          },\n          ie(\"path\", { d: \"M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z\" })\n        ),\n        \"dec\",\n        \"ArrowDown\",\n        !1,\n        \"decrement\"\n      ), re = [];\n      e.name && !e.disabled && re.push(\n        ie(\"input\", {\n          type: \"hidden\",\n          name: e.name,\n          form: e.form || null,\n          // TODO: Should this be set to '' if value is out of range?\n          value: _.value,\n          key: \"hidden\"\n        })\n      );\n      const de = ie(\n        // We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n        \"output\",\n        {\n          class: [\n            { \"d-flex\": e.vertical },\n            { \"align-self-center\": !e.vertical },\n            { \"align-items-center\": e.vertical },\n            { \"border-top\": e.vertical },\n            { \"border-bottom\": e.vertical },\n            { \"border-start\": !e.vertical },\n            { \"border-end\": !e.vertical },\n            \"flex-grow-1\"\n          ],\n          ...I.value,\n          key: \"output\"\n          // ref: 'spinner',\n        },\n        [\n          ie(\n            \"bdi\",\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            //@ts-ignore How can we narrow this type down\n            f.value ? V.value(r.value) : e.placeholder || \"\"\n          )\n        ]\n      );\n      return ie(\n        \"div\",\n        {\n          class: [\n            \"b-form-spinbutton form-control\",\n            { disabled: e.disabled },\n            { readonly: e.readonly },\n            { focus: a },\n            { \"d-inline-flex\": e.inline || e.vertical },\n            { \"d-flex\": !e.inline && !e.vertical },\n            { \"align-items-stretch\": !e.vertical },\n            { \"flex-column\": e.vertical },\n            e.size ? `form-control-${e.size}` : null\n            // this.stateClass //TODO\n          ],\n          ...F.value,\n          onkeydown: te,\n          onkeyup: G\n          // We use capture phase (`!` prefix) since focus and blur do not bubble\n          // 'focus': onFocusBlur, //TODO\n          // 'blur': onFocusBlur, //TODO\n        },\n        e.vertical ? [q, re, de, Q] : [Q, re, de, q]\n      );\n    };\n  }\n}), Qu = [\"id\"], An = /* @__PURE__ */ N({\n  __name: \"BFormTag\",\n  props: {\n    id: { default: void 0 },\n    title: { default: void 0 },\n    disabled: { type: [String, Boolean], default: !1 },\n    noRemove: { type: [String, Boolean], default: !1 },\n    pill: { type: [String, Boolean], default: !1 },\n    removeLabel: { default: \"Remove tag\" },\n    tag: { default: \"span\" },\n    variant: { default: \"secondary\" }\n  },\n  emits: [\"remove\"],\n  setup(e, { emit: t }) {\n    const l = e, a = Fe(), o = _e(() => l.id), n = d(() => l.disabled), s = d(() => l.noRemove), r = d(() => l.pill), i = u(\n      () => {\n        var h;\n        return ((((h = a.default) == null ? void 0 : h.call(a)[0].children) ?? \"\").toString() || l.title) ?? \"\";\n      }\n    ), v = u(() => `${o.value}taglabel__`), b = u(() => ({\n      [`bg-${l.variant}`]: l.variant !== null,\n      \"text-dark\": l.variant !== null && [\"warning\", \"info\", \"light\"].includes(l.variant),\n      \"rounded-pill\": r.value,\n      disabled: n.value\n    }));\n    return (h, p) => (g(), M(le(h.tag), {\n      id: $(o),\n      title: i.value,\n      class: H([\"badge b-form-tag d-inline-flex align-items-center mw-100\", b.value]),\n      \"aria-labelledby\": v.value\n    }, {\n      default: j(() => [\n        K(\"span\", {\n          id: v.value,\n          class: \"b-form-tag-content flex-grow-1 text-truncate\"\n        }, [\n          O(h.$slots, \"default\", {}, () => [\n            ne(Y(i.value), 1)\n          ])\n        ], 8, Qu),\n        !$(n) && !$(s) ? (g(), M(Ot, {\n          key: 0,\n          \"aria-keyshortcuts\": \"Delete\",\n          \"aria-label\": h.removeLabel,\n          class: \"b-form-tag-remove\",\n          white: h.variant !== null && ![\"warning\", \"info\", \"light\"].includes(h.variant),\n          \"aria-describedby\": v.value,\n          \"aria-controls\": h.id,\n          onClick: p[0] || (p[0] = (B) => t(\"remove\", i.value))\n        }, null, 8, [\"aria-label\", \"white\", \"aria-describedby\", \"aria-controls\"])) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"id\", \"title\", \"class\", \"aria-labelledby\"]));\n  }\n}), ed = [\"id\"], td = [\"id\", \"for\", \"aria-live\"], ad = [\"id\", \"aria-live\"], ld = [\"id\"], od = [\"aria-controls\"], nd = {\n  role: \"group\",\n  class: \"d-flex\"\n}, sd = [\"id\", \"disabled\", \"value\", \"type\", \"placeholder\", \"form\", \"required\", \"aria-required\"], rd = [\"disabled\"], id = {\n  \"aria-live\": \"polite\",\n  \"aria-atomic\": \"true\"\n}, ud = {\n  key: 0,\n  class: \"d-block invalid-feedback\"\n}, dd = {\n  key: 1,\n  class: \"form-text text-muted\"\n}, cd = {\n  key: 2,\n  class: \"form-text text-muted\"\n}, fd = [\"name\", \"value\"], vd = /* @__PURE__ */ N({\n  __name: \"BFormTags\",\n  props: {\n    addButtonText: { default: \"Add\" },\n    addButtonVariant: { default: \"outline-secondary\" },\n    addOnChange: { type: [String, Boolean], default: !1 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    duplicateTagText: { default: \"Duplicate tag(s)\" },\n    inputAttrs: { default: void 0 },\n    inputClass: { default: void 0 },\n    inputId: { default: void 0 },\n    inputType: { default: \"text\" },\n    invalidTagText: { default: \"Invalid tag(s)\" },\n    form: { default: void 0 },\n    limit: { default: void 0 },\n    limitTagsText: { default: \"Tag limit reached\" },\n    modelValue: { default: () => [] },\n    name: { default: void 0 },\n    noAddOnEnter: { type: [String, Boolean], default: !1 },\n    noOuterFocus: { type: [String, Boolean], default: !1 },\n    noTagRemove: { type: [String, Boolean], default: !1 },\n    placeholder: { default: \"Add tag...\" },\n    removeOnDelete: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    separator: { default: void 0 },\n    state: { type: [String, Boolean, null], default: null },\n    size: { default: \"md\" },\n    tagClass: { default: void 0 },\n    tagPills: { type: [String, Boolean], default: !1 },\n    tagRemoveLabel: { default: void 0 },\n    tagRemovedLabel: { default: \"Tag removed\" },\n    tagValidator: { type: Function, default: () => !0 },\n    tagVariant: { default: \"secondary\" }\n  },\n  emits: [\"update:modelValue\", \"input\", \"tag-state\", \"focus\", \"focusin\", \"focusout\", \"blur\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Se(a, \"modelValue\", l), n = _e(), s = d(() => a.addOnChange), r = d(() => a.autofocus), i = d(() => a.disabled), v = d(() => a.noAddOnEnter), b = d(() => a.noOuterFocus), h = d(() => a.noTagRemove), p = d(() => a.removeOnDelete), B = d(() => a.required), S = d(() => a.state), m = d(() => a.tagPills), A = Vt(S), y = R(null), { focused: k } = Ee(y, {\n      initialValue: r.value\n    }), w = u(() => a.inputId || `${n.value}input__`), _ = R(o.value), C = R(\"\"), T = R(o.value.length > 0), c = R(\"\"), V = R([]), F = R([]), f = R([]), I = u(() => [\n      A.value,\n      {\n        [`form-control-${a.size}`]: a.size !== \"md\",\n        disabled: i.value,\n        focus: k.value\n      }\n    ]), E = u(() => _.value.includes(C.value)), z = u(\n      () => C.value === \"\" ? !1 : !a.tagValidator(C.value)\n    ), Z = u(() => _.value.length === a.limit), te = u(() => !z.value && !E.value), G = u(() => ({\n      addButtonText: a.addButtonText,\n      addButtonVariant: a.addButtonVariant,\n      addTag: re,\n      disableAddButton: te.value,\n      disabled: i.value,\n      duplicateTagText: a.duplicateTagText,\n      duplicateTags: f.value,\n      form: a.form,\n      inputAttrs: {\n        ...a.inputAttrs,\n        disabled: i.value,\n        form: a.form,\n        id: w,\n        value: C\n      },\n      inputHandlers: {\n        input: ge,\n        keydown: me,\n        change: pe\n      },\n      inputId: w,\n      inputType: a.inputType,\n      invalidTagText: a.invalidTagText,\n      invalidTags: F.value,\n      isDuplicate: E.value,\n      isInvalid: z.value,\n      isLimitReached: Z.value,\n      limitTagsText: a.limitTagsText,\n      limit: a.limit,\n      noTagRemove: h.value,\n      placeholder: a.placeholder,\n      removeTag: de,\n      required: B.value,\n      separator: a.separator,\n      size: a.size,\n      state: S.value,\n      tagClass: a.tagClass,\n      tagPills: m.value,\n      tagRemoveLabel: a.tagRemoveLabel,\n      tagVariant: a.tagVariant,\n      tags: _.value\n    }));\n    oe(o, (L) => {\n      _.value = L;\n    });\n    const W = (L) => {\n      if (i.value) {\n        L.target.blur();\n        return;\n      }\n      l(\"focusin\", L);\n    }, X = (L) => {\n      i.value || b.value || (k.value = !0, l(\"focus\", L));\n    }, ve = (L) => {\n      k.value = !1, l(\"blur\", L);\n    }, ge = (L) => {\n      var D, ae;\n      const x = typeof L == \"string\" ? L : L.target.value;\n      if (T.value = !1, (D = a.separator) != null && D.includes(x.charAt(0)) && x.length > 0) {\n        y.value && (y.value.value = \"\");\n        return;\n      }\n      if (C.value = x, (ae = a.separator) != null && ae.includes(x.charAt(x.length - 1))) {\n        re(x.slice(0, x.length - 1));\n        return;\n      }\n      V.value = a.tagValidator(x) && !E.value ? [x] : [], F.value = a.tagValidator(x) ? [] : [x], f.value = E.value ? [x] : [], l(\"tag-state\", V.value, F.value, f.value);\n    }, pe = (L) => {\n      s.value && (ge(L), E.value || re(C.value));\n    }, me = (L) => {\n      if (L.key === \"Enter\" && !v.value) {\n        re(C.value);\n        return;\n      }\n      (L.key === \"Backspace\" || L.key === \"Delete\") && p.value && C.value === \"\" && T.value && _.value.length > 0 ? de(_.value[_.value.length - 1]) : T.value = !0;\n    }, q = u(() => {\n      if (a.separator)\n        return typeof a.separator == \"string\" ? a.separator : a.separator.join(\"\");\n    }), Q = u(() => {\n      if (q.value)\n        return new RegExp(`[${rs(q.value)}]+`);\n    }), re = (L) => {\n      L = (L ?? C.value).trim();\n      const x = Q.value ? L.split(Q.value).map((ue) => ue.trim()) : [L], D = [];\n      for (const ue of x)\n        if (!(ue === \"\" || E.value || !a.tagValidator(ue))) {\n          if (a.limit && Z.value)\n            break;\n          D.push(ue);\n        }\n      const ae = [...o.value, ...D];\n      C.value = \"\", T.value = !0, o.value = ae, l(\"input\", ae), k.value = !0;\n    }, de = (L) => {\n      const x = _.value.indexOf((L == null ? void 0 : L.toString()) ?? \"\");\n      c.value = _.value.splice(x, 1).toString(), o.value = _.value;\n    };\n    return t({\n      focus: () => {\n        k.value = !0;\n      },\n      blur: () => {\n        k.value = !1;\n      }\n    }), (L, x) => (g(), P(\"div\", {\n      id: $(n),\n      class: H([\"b-form-tags form-control h-auto\", I.value]),\n      role: \"group\",\n      tabindex: \"-1\",\n      onFocusin: W,\n      onFocusout: x[1] || (x[1] = (D) => l(\"focusout\", D))\n    }, [\n      K(\"output\", {\n        id: `${$(n)}selected_tags__`,\n        class: \"visually-hidden\",\n        for: w.value,\n        \"aria-live\": $(k) ? \"polite\" : \"off\",\n        \"aria-atomic\": \"true\",\n        \"aria-relevant\": \"additions text\"\n      }, Y(_.value.join(\", \")), 9, td),\n      K(\"div\", {\n        id: `${$(n)}removed_tags__`,\n        role: \"status\",\n        \"aria-live\": $(k) ? \"assertive\" : \"off\",\n        \"aria-atomic\": \"true\",\n        class: \"visually-hidden\"\n      }, \" (\" + Y(L.tagRemovedLabel) + \") \" + Y(c.value), 9, ad),\n      O(L.$slots, \"default\", Be(Ve(G.value)), () => [\n        K(\"ul\", {\n          id: `${$(n)}tag_list__`,\n          class: \"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n        }, [\n          (g(!0), P(ce, null, he(_.value, (D, ae) => O(L.$slots, \"tag\", Be(ee({ key: ae }, { tag: D, tagClass: L.tagClass, tagVariant: L.tagVariant, tagPills: $(m), removeTag: de })), () => [\n            (g(), M(An, {\n              key: D,\n              class: H(L.tagClass),\n              tag: \"li\",\n              variant: L.tagVariant,\n              pill: L.tagPills,\n              onRemove: de\n            }, {\n              default: j(() => [\n                ne(Y(D), 1)\n              ]),\n              _: 2\n            }, 1032, [\"class\", \"variant\", \"pill\"]))\n          ])), 128)),\n          K(\"li\", {\n            role: \"none\",\n            \"aria-live\": \"off\",\n            class: \"b-from-tags-field flex-grow-1\",\n            \"aria-controls\": `${$(n)}tag_list__`\n          }, [\n            K(\"div\", nd, [\n              K(\"input\", ee({\n                id: w.value,\n                ref_key: \"input\",\n                ref: y,\n                disabled: $(i),\n                value: C.value,\n                type: L.inputType,\n                placeholder: L.placeholder,\n                class: \"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\",\n                style: { outline: \"currentcolor none 0px\", \"min-width\": \"5rem\" }\n              }, L.inputAttrs, {\n                form: L.form,\n                required: $(B) || void 0,\n                \"aria-required\": $(B) || void 0,\n                onInput: ge,\n                onChange: pe,\n                onKeydown: me,\n                onFocus: X,\n                onBlur: ve\n              }), null, 16, sd),\n              te.value ? (g(), P(\"button\", {\n                key: 0,\n                type: \"button\",\n                class: H([\"btn b-form-tags-button py-0\", [\n                  L.inputClass,\n                  {\n                    [`btn-${L.addButtonVariant}`]: L.addButtonVariant !== null,\n                    \"disabled invisible\": C.value.length === 0\n                  }\n                ]]),\n                style: { \"font-size\": \"90%\" },\n                disabled: $(i) || C.value.length === 0 || Z.value,\n                onClick: x[0] || (x[0] = (D) => re(C.value))\n              }, [\n                O(L.$slots, \"add-button-text\", {}, () => [\n                  ne(Y(L.addButtonText), 1)\n                ])\n              ], 10, rd)) : J(\"\", !0)\n            ])\n          ], 8, od)\n        ], 8, ld),\n        K(\"div\", id, [\n          z.value ? (g(), P(\"div\", ud, Y(L.invalidTagText) + \": \" + Y(C.value), 1)) : J(\"\", !0),\n          E.value ? (g(), P(\"small\", dd, Y(L.duplicateTagText) + \": \" + Y(C.value), 1)) : J(\"\", !0),\n          _.value.length === L.limit ? (g(), P(\"small\", cd, \"Tag limit reached\")) : J(\"\", !0)\n        ])\n      ]),\n      L.name ? (g(!0), P(ce, { key: 0 }, he(_.value, (D, ae) => (g(), P(\"input\", {\n        key: ae,\n        type: \"hidden\",\n        name: L.name,\n        value: D\n      }, null, 8, fd))), 128)) : J(\"\", !0)\n    ], 42, ed));\n  }\n}), pd = [\"id\", \"name\", \"form\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"aria-required\", \"aria-invalid\", \"rows\", \"wrap\"], md = /* @__PURE__ */ N({\n  __name: \"BFormTextarea\",\n  props: {\n    noResize: { type: [String, Boolean], default: !1 },\n    rows: { default: 2 },\n    wrap: { default: \"soft\" },\n    ariaInvalid: { type: [String, Boolean], default: void 0 },\n    autocomplete: { default: void 0 },\n    autofocus: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    form: { default: void 0 },\n    formatter: { type: Function, default: void 0 },\n    id: { default: void 0 },\n    lazy: { type: [String, Boolean], default: !1 },\n    lazyFormatter: { type: [String, Boolean], default: !1 },\n    list: { default: void 0 },\n    modelValue: { default: \"\" },\n    name: { default: void 0 },\n    number: { type: [String, Boolean], default: !1 },\n    placeholder: { default: void 0 },\n    plaintext: { type: [String, Boolean], default: !1 },\n    readonly: { type: [String, Boolean], default: !1 },\n    required: { type: [String, Boolean], default: !1 },\n    size: { default: void 0 },\n    state: { type: [String, Boolean, null], default: null },\n    trim: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"update:modelValue\", \"change\", \"blur\", \"input\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: i, onBlur: v, focus: b, blur: h } = tn(a, l), p = d(() => a.disabled), B = d(() => a.required), S = d(() => a.readonly), m = d(() => a.plaintext), A = d(() => a.noResize), y = d(() => a.state), k = Vt(y), w = u(() => [\n      k.value,\n      {\n        \"form-control\": !a.plaintext,\n        \"form-control-plaintext\": a.plaintext,\n        [`form-control-${a.size}`]: !!a.size\n      }\n    ]), _ = u(() => ({\n      resize: A.value ? \"none\" : void 0\n    }));\n    return t({\n      focus: b,\n      blur: h\n    }), (C, T) => (g(), P(\"textarea\", {\n      id: $(n),\n      ref_key: \"input\",\n      ref: o,\n      class: H(w.value),\n      name: C.name || void 0,\n      form: C.form || void 0,\n      disabled: $(p),\n      placeholder: C.placeholder,\n      required: $(B) || void 0,\n      autocomplete: C.autocomplete || void 0,\n      readonly: $(S) || $(m),\n      \"aria-required\": C.required || void 0,\n      \"aria-invalid\": $(s),\n      rows: C.rows,\n      style: ze(_.value),\n      wrap: C.wrap || void 0,\n      onInput: T[0] || (T[0] = (c) => $(r)(c)),\n      onChange: T[1] || (T[1] = (c) => $(i)(c)),\n      onBlur: T[2] || (T[2] = (c) => $(v)(c))\n    }, null, 46, pd));\n  }\n}), gd = {\n  key: 0,\n  class: \"input-group-text\"\n}, yd = [\"innerHTML\"], bd = { key: 1 }, hd = {\n  key: 0,\n  class: \"input-group-text\"\n}, Bd = [\"innerHTML\"], Sd = { key: 1 }, wd = /* @__PURE__ */ N({\n  __name: \"BInputGroup\",\n  props: {\n    append: { default: void 0 },\n    appendHtml: { default: void 0 },\n    id: { default: void 0 },\n    prepend: { default: void 0 },\n    prependHtml: { default: void 0 },\n    size: { default: \"md\" },\n    tag: { default: \"div\" }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`input-group-${t.size}`]: t.size !== \"md\"\n    })), a = u(() => !!t.append || !!t.appendHtml), o = u(() => !!t.prepend || !!t.prependHtml);\n    return (n, s) => (g(), M(le(n.tag), {\n      id: n.id,\n      class: H([\"input-group\", l.value]),\n      role: \"group\"\n    }, {\n      default: j(() => [\n        O(n.$slots, \"prepend\", {}, () => [\n          o.value ? (g(), P(\"span\", gd, [\n            n.prependHtml ? (g(), P(\"span\", {\n              key: 0,\n              innerHTML: n.prependHtml\n            }, null, 8, yd)) : (g(), P(\"span\", bd, Y(n.prepend), 1))\n          ])) : J(\"\", !0)\n        ]),\n        O(n.$slots, \"default\"),\n        O(n.$slots, \"append\", {}, () => [\n          a.value ? (g(), P(\"span\", hd, [\n            n.appendHtml ? (g(), P(\"span\", {\n              key: 0,\n              innerHTML: n.appendHtml\n            }, null, 8, Bd)) : (g(), P(\"span\", Sd, Y(n.append), 1))\n          ])) : J(\"\", !0)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"id\", \"class\"]));\n  }\n}), On = /* @__PURE__ */ N({\n  __name: \"BInputGroupText\",\n  props: {\n    tag: { default: \"div\" },\n    text: { default: void 0 }\n  },\n  setup(e) {\n    return (t, l) => (g(), M(le(t.tag), { class: \"input-group-text\" }, {\n      default: j(() => [\n        O(t.$slots, \"default\", {}, () => [\n          ne(Y(t.text), 1)\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), nl = /* @__PURE__ */ N({\n  __name: \"BInputGroupAddon\",\n  props: {\n    isText: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.isText);\n    return (a, o) => $(l) ? (g(), M(On, { key: 0 }, {\n      default: j(() => [\n        O(a.$slots, \"default\")\n      ]),\n      _: 3\n    })) : O(a.$slots, \"default\", { key: 1 });\n  }\n}), _d = /* @__PURE__ */ N({\n  __name: \"BInputGroupAppend\",\n  props: {\n    isText: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    return (t, l) => (g(), M(nl, { \"is-text\": t.isText }, {\n      default: j(() => [\n        O(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"is-text\"]));\n  }\n}), $d = /* @__PURE__ */ N({\n  __name: \"BInputGroupPrepend\",\n  props: {\n    isText: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    return (t, l) => (g(), M(nl, { \"is-text\": t.isText }, {\n      default: j(() => [\n        O(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"is-text\"]));\n  }\n}), Cd = /* @__PURE__ */ N({\n  __name: \"BListGroup\",\n  props: {\n    flush: { type: [String, Boolean], default: !1 },\n    horizontal: { type: [Boolean, String], default: !1 },\n    numbered: { type: [String, Boolean], default: !1 },\n    tag: { default: \"div\" }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.flush), a = d(() => t.numbered), o = u(() => {\n      const s = l.value ? !1 : t.horizontal;\n      return {\n        \"list-group-flush\": l.value,\n        \"list-group-horizontal\": s === !0,\n        [`list-group-horizontal-${s}`]: typeof s == \"string\",\n        \"list-group-numbered\": a.value\n      };\n    }), n = u(() => a.value === !0 ? \"ol\" : t.tag);\n    return De(wo, {\n      numbered: a\n    }), (s, r) => (g(), M(le(n.value), {\n      class: H([\"list-group\", o.value])\n    }, {\n      default: j(() => [\n        O(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"class\"]));\n  }\n}), kd = /* @__PURE__ */ N({\n  __name: \"BListGroupItem\",\n  props: {\n    action: { type: [String, Boolean], default: !1 },\n    active: { type: [String, Boolean], default: !1 },\n    button: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    href: { default: void 0 },\n    tag: { default: \"div\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = za(), a = Oe(wo, null), o = d(() => t.action), n = d(() => t.active), s = d(() => t.button), r = d(() => t.disabled), i = u(() => !s.value && (!!t.href || !!t.to)), v = u(\n      () => a != null && a.numbered.value ? \"li\" : s.value ? \"button\" : i.value ? Xe : t.tag\n    ), b = u(\n      () => o.value || i.value || s.value || [\"a\", \"router-link\", \"button\", \"b-link\"].includes(t.tag)\n    ), h = u(() => ({\n      [`list-group-item-${t.variant}`]: t.variant !== null,\n      \"list-group-item-action\": b.value,\n      active: n.value,\n      disabled: r.value\n    })), p = u(() => {\n      const B = {};\n      return s.value && ((!l || !l.type) && (B.type = \"button\"), r.value && (B.disabled = !0)), B;\n    });\n    return (B, S) => (g(), M(le(v.value), ee({\n      class: [\"list-group-item\", h.value],\n      \"aria-current\": $(n) ? !0 : void 0,\n      \"aria-disabled\": $(r) ? !0 : void 0,\n      target: i.value ? B.target : void 0,\n      href: $(s) ? void 0 : B.href,\n      to: $(s) ? void 0 : B.to\n    }, p.value), {\n      default: j(() => [\n        O(B.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"class\", \"aria-current\", \"aria-disabled\", \"target\", \"href\", \"to\"]));\n  }\n}), Td = [\"id\", \"aria-labelledby\", \"aria-describedby\"], Vd = [\"id\"], Ad = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BModal\",\n  props: {\n    bodyBgVariant: { default: null },\n    bodyClass: { default: void 0 },\n    bodyTextVariant: { default: null },\n    busy: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: !1 },\n    buttonSize: { default: \"md\" },\n    cancelDisabled: { type: [String, Boolean], default: !1 },\n    cancelTitle: { default: \"Cancel\" },\n    cancelVariant: { default: \"secondary\" },\n    centered: { type: [String, Boolean], default: !1 },\n    contentClass: { default: void 0 },\n    dialogClass: { default: void 0 },\n    footerBgVariant: { default: null },\n    footerBorderVariant: { default: null },\n    footerClass: { default: void 0 },\n    footerTextVariant: { default: null },\n    fullscreen: { type: [Boolean, String], default: !1 },\n    headerBgVariant: { default: null },\n    headerBorderVariant: { default: null },\n    headerClass: { default: void 0 },\n    headerCloseLabel: { default: \"Close\" },\n    headerCloseWhite: { type: [String, Boolean], default: !1 },\n    headerTextVariant: { default: null },\n    hideBackdrop: { type: [String, Boolean], default: !1 },\n    hideFooter: { type: [String, Boolean], default: !1 },\n    hideHeader: { type: [String, Boolean], default: !1 },\n    hideHeaderClose: { type: [String, Boolean], default: !1 },\n    id: { default: void 0 },\n    modalClass: { default: void 0 },\n    modelValue: { type: [String, Boolean], default: !1 },\n    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },\n    noCloseOnEsc: { type: [String, Boolean], default: !1 },\n    noFade: { type: [String, Boolean], default: !1 },\n    autoFocus: { type: [String, Boolean], default: !0 },\n    okDisabled: { type: [String, Boolean], default: !1 },\n    okOnly: { type: [String, Boolean], default: !1 },\n    okTitle: { default: \"Ok\" },\n    okVariant: { default: \"primary\" },\n    scrollable: { type: [String, Boolean], default: !1 },\n    show: { type: [String, Boolean], default: !1 },\n    size: { default: \"md\" },\n    title: { default: void 0 },\n    titleClass: { default: void 0 },\n    titleSrOnly: { type: [String, Boolean], default: !1 },\n    titleTag: { default: \"h5\" },\n    autoFocusButton: { default: void 0 },\n    teleportDisabled: { type: [String, Boolean], default: !1 },\n    teleportTo: { default: \"body\" },\n    bodyScrolling: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"update:modelValue\", \"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"ok\", \"cancel\", \"close\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Fe(), n = _e(() => a.id, \"modal\"), s = Se(a, \"modelValue\", l), r = d(() => a.busy), i = d(() => a.lazy), v = d(() => a.cancelDisabled), b = d(() => a.centered), h = d(() => a.hideBackdrop), p = d(() => a.hideFooter), B = d(() => a.hideHeader), S = d(() => a.hideHeaderClose), m = d(s), A = d(() => a.noCloseOnBackdrop), y = d(() => a.noCloseOnEsc), k = d(() => a.noFade), w = d(() => a.autoFocus), _ = d(() => a.okDisabled), C = d(() => a.okOnly), T = d(() => a.scrollable), c = d(() => a.titleSrOnly), V = d(() => a.teleportDisabled), F = d(() => a.bodyScrolling), f = R(null), I = R(null), E = R(null), z = R(null), Z = R(m.value), te = R(!1);\n    an(m, F);\n    const { focused: G } = Ee(f, {\n      initialValue: m.value && a.autoFocusButton === void 0\n    }), { focused: W } = Ee(I, {\n      initialValue: m.value && a.autoFocusButton === \"ok\"\n    }), { focused: X } = Ee(E, {\n      initialValue: m.value && a.autoFocusButton === \"cancel\"\n    }), { focused: ve } = Ee(z, {\n      initialValue: m.value && a.autoFocusButton === \"close\"\n    }), ge = u(() => [\n      a.modalClass,\n      {\n        fade: !k.value,\n        show: Z.value\n      }\n    ]), pe = u(\n      () => i.value === !1 || i.value === !0 && te.value === !0 || i.value === !0 && m.value === !0\n    ), me = u(() => !Ae(o[\"header-close\"])), q = u(() => [\n      a.dialogClass,\n      {\n        \"modal-fullscreen\": a.fullscreen === !0,\n        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == \"string\",\n        [`modal-${a.size}`]: a.size !== \"md\",\n        \"modal-dialog-centered\": b.value,\n        \"modal-dialog-scrollable\": T.value\n      }\n    ]), Q = u(() => [\n      a.bodyClass,\n      {\n        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== null,\n        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== null\n      }\n    ]), re = u(() => [\n      a.headerClass,\n      {\n        [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== null,\n        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null,\n        [`text-${a.headerTextVariant}`]: a.headerTextVariant !== null\n      }\n    ]), de = u(() => [\n      a.footerClass,\n      {\n        [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== null,\n        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null,\n        [`text-${a.footerTextVariant}`]: a.footerTextVariant !== null\n      }\n    ]), L = u(() => [\n      a.titleClass,\n      {\n        \"visually-hidden\": c.value\n      }\n    ]), x = u(() => v.value || r.value), D = u(() => _.value || r.value), ae = (fe, $e = {}) => new Rt(fe, {\n      cancelable: !1,\n      target: f.value || null,\n      relatedTarget: null,\n      trigger: null,\n      ...$e,\n      componentId: n.value\n    }), ue = (fe = \"\") => {\n      const $e = ae(\"hide\", { cancelable: fe !== \"\", trigger: fe });\n      if (fe === \"ok\" && l(fe, $e), fe === \"cancel\" && l(fe, $e), fe === \"close\" && l(fe, $e), l(\"hide\", $e), $e.defaultPrevented || fe === \"backdrop\" && A.value || fe === \"esc\" && y.value) {\n        l(\"hide-prevented\");\n        return;\n      }\n      s.value = !1;\n    }, U = () => {\n      const fe = ae(\"show\", { cancelable: !0 });\n      if (l(\"show\", fe), fe.defaultPrevented) {\n        s.value = !1, l(\"show-prevented\");\n        return;\n      }\n      s.value = !0;\n    }, se = () => {\n      w.value !== !1 && (a.autoFocusButton === \"ok\" ? W.value = !0 : a.autoFocusButton === \"close\" ? ve.value = !0 : a.autoFocusButton === \"cancel\" ? X.value = !0 : G.value = !0);\n    }, Ie = () => U(), et = () => {\n      Z.value = !0, se(), l(\"shown\", ae(\"shown\")), i.value === !0 && (te.value = !0);\n    }, tt = () => {\n      Z.value = !1;\n    }, ut = () => {\n      l(\"hidden\", ae(\"hidden\")), i.value === !0 && (te.value = !1);\n    };\n    return Xr(Z), we(f, \"bv-toggle\", () => {\n      m.value ? ue() : U();\n    }), t({\n      hide: ue,\n      show: U\n    }), (fe, $e) => (g(), M(Na, {\n      to: fe.teleportTo,\n      disabled: $(V)\n    }, [\n      be(At, {\n        \"no-fade\": !0,\n        \"trans-props\": { enterToClass: \"show\" },\n        onBeforeEnter: Ie,\n        onAfterEnter: et,\n        onLeave: tt,\n        onAfterLeave: ut\n      }, {\n        default: j(() => [\n          rt(K(\"div\", ee({\n            id: $(n),\n            ref_key: \"element\",\n            ref: f,\n            class: [\"modal\", ge.value],\n            role: \"dialog\",\n            \"aria-labelledby\": `${$(n)}-label`,\n            \"aria-describedby\": `${$(n)}-body`,\n            tabindex: \"-1\"\n          }, fe.$attrs, {\n            onKeyup: $e[5] || ($e[5] = It((Ft) => ue(\"esc\"), [\"esc\"]))\n          }), [\n            K(\"div\", {\n              class: H([\"modal-dialog\", q.value])\n            }, [\n              pe.value ? (g(), P(\"div\", {\n                key: 0,\n                class: H([\"modal-content\", fe.contentClass])\n              }, [\n                $(B) ? J(\"\", !0) : (g(), P(\"div\", {\n                  key: 0,\n                  class: H([\"modal-header\", re.value])\n                }, [\n                  O(fe.$slots, \"header\", {}, () => [\n                    (g(), M(le(fe.titleTag), {\n                      id: `${$(n)}-label`,\n                      class: H([\"modal-title\", L.value])\n                    }, {\n                      default: j(() => [\n                        O(fe.$slots, \"title\", {}, () => [\n                          ne(Y(fe.title), 1)\n                        ], !0)\n                      ]),\n                      _: 3\n                    }, 8, [\"id\", \"class\"])),\n                    $(S) ? J(\"\", !0) : (g(), P(ce, { key: 0 }, [\n                      me.value ? (g(), P(\"button\", {\n                        key: 0,\n                        type: \"button\",\n                        onClick: $e[0] || ($e[0] = (Ft) => ue(\"close\"))\n                      }, [\n                        O(fe.$slots, \"header-close\", {}, void 0, !0)\n                      ])) : (g(), M(Ot, {\n                        key: 1,\n                        ref_key: \"closeButton\",\n                        ref: z,\n                        \"aria-label\": fe.headerCloseLabel,\n                        white: fe.headerCloseWhite,\n                        onClick: $e[1] || ($e[1] = (Ft) => ue(\"close\"))\n                      }, null, 8, [\"aria-label\", \"white\"]))\n                    ], 64))\n                  ], !0)\n                ], 2)),\n                K(\"div\", {\n                  id: `${$(n)}-body`,\n                  class: H([\"modal-body\", Q.value])\n                }, [\n                  O(fe.$slots, \"default\", {}, void 0, !0)\n                ], 10, Vd),\n                $(p) ? J(\"\", !0) : (g(), P(\"div\", {\n                  key: 1,\n                  class: H([\"modal-footer\", de.value])\n                }, [\n                  O(fe.$slots, \"footer\", {}, () => [\n                    O(fe.$slots, \"cancel\", {}, () => [\n                      $(C) ? J(\"\", !0) : (g(), M(kt, {\n                        key: 0,\n                        ref_key: \"cancelButton\",\n                        ref: E,\n                        disabled: x.value,\n                        size: fe.buttonSize,\n                        variant: fe.cancelVariant,\n                        onClick: $e[2] || ($e[2] = (Ft) => ue(\"cancel\"))\n                      }, {\n                        default: j(() => [\n                          ne(Y(fe.cancelTitle), 1)\n                        ]),\n                        _: 1\n                      }, 8, [\"disabled\", \"size\", \"variant\"]))\n                    ], !0),\n                    O(fe.$slots, \"ok\", {}, () => [\n                      be(kt, {\n                        ref_key: \"okButton\",\n                        ref: I,\n                        disabled: D.value,\n                        size: fe.buttonSize,\n                        variant: fe.okVariant,\n                        onClick: $e[3] || ($e[3] = (Ft) => ue(\"ok\"))\n                      }, {\n                        default: j(() => [\n                          ne(Y(fe.okTitle), 1)\n                        ]),\n                        _: 1\n                      }, 8, [\"disabled\", \"size\", \"variant\"])\n                    ], !0)\n                  ], !0)\n                ], 2))\n              ], 2)) : J(\"\", !0)\n            ], 2),\n            $(h) ? J(\"\", !0) : O(fe.$slots, \"backdrop\", { key: 0 }, () => [\n              K(\"div\", {\n                class: \"modal-backdrop fade show\",\n                onClick: $e[4] || ($e[4] = (Ft) => ue(\"backdrop\"))\n              })\n            ], !0)\n          ], 16, Td), [\n            [ua, $(m)]\n          ])\n        ]),\n        _: 3\n      })\n    ], 8, [\"to\", \"disabled\"]));\n  }\n});\nconst Od = /* @__PURE__ */ ll(Ad, [[\"__scopeId\", \"data-v-b5795927\"]]), Fd = /* @__PURE__ */ N({\n  __name: \"BNav\",\n  props: {\n    align: { default: void 0 },\n    cardHeader: { type: [String, Boolean], default: !1 },\n    fill: { type: [String, Boolean], default: !1 },\n    justified: { type: [String, Boolean], default: !1 },\n    pills: { type: [String, Boolean], default: !1 },\n    small: { type: [String, Boolean], default: !1 },\n    tabs: { type: [String, Boolean], default: !1 },\n    tag: { default: \"ul\" },\n    vertical: { type: [String, Boolean], default: !1 },\n    underline: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.cardHeader), a = d(() => t.fill), o = d(() => t.justified), n = d(() => t.pills), s = d(() => t.small), r = d(() => t.tabs), i = d(() => t.vertical), v = Dt(() => t.align), b = d(() => t.underline), h = u(() => ({\n      \"nav-tabs\": r.value,\n      \"nav-pills\": n.value && !r.value,\n      \"card-header-tabs\": !i.value && l.value && r.value,\n      \"card-header-pills\": !i.value && l.value && n.value && !r.value,\n      \"flex-column\": i.value,\n      \"nav-fill\": !i.value && a.value,\n      \"nav-justified\": !i.value && o.value,\n      [v.value]: !i.value && t.align !== void 0,\n      small: s.value,\n      \"nav-underline\": b.value\n    }));\n    return (p, B) => (g(), M(le(p.tag), {\n      class: H([\"nav\", h.value])\n    }, {\n      default: j(() => [\n        O(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"class\"]));\n  }\n}), Pd = /* @__PURE__ */ N({\n  __name: \"BNavForm\",\n  props: {\n    role: { default: void 0 },\n    id: { default: void 0 },\n    floating: { type: [String, Boolean], default: !1 },\n    novalidate: { type: [String, Boolean], default: !1 },\n    validated: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"submit\"],\n  setup(e, { emit: t }) {\n    const l = e, a = u(() => ({\n      floating: l.floating,\n      role: l.role,\n      id: l.id,\n      novalidate: l.novalidate,\n      validated: l.validated\n    })), o = (n) => t(\"submit\", n);\n    return (n, s) => (g(), M(Bn, ee(a.value, {\n      class: \"d-flex\",\n      onSubmit: ot(o, [\"prevent\"])\n    }), {\n      default: j(() => [\n        O(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"onSubmit\"]));\n  }\n}), Ed = { class: \"nav-item\" }, Id = /* @__PURE__ */ N({\n  __name: \"BNavItem\",\n  props: {\n    linkClasses: { default: void 0 },\n    linkAttrs: { default: void 0 },\n    active: { type: [String, Boolean], default: void 0 },\n    activeClass: { default: \"router-link-active\" },\n    append: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    href: { default: void 0 },\n    rel: { default: void 0 },\n    replace: { type: [String, Boolean], default: !1 },\n    routerComponentName: { default: \"router-link\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    variant: { default: void 0 },\n    opacity: { default: void 0 },\n    opacityHover: { default: void 0 },\n    underlineVariant: { default: null },\n    underlineOffset: { default: void 0 },\n    underlineOffsetHover: { default: void 0 },\n    underlineOpacity: { default: void 0 },\n    underlineOpacityHover: { default: void 0 },\n    icon: { type: [String, Boolean], default: !1 }\n  },\n  emits: [\"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.disabled), o = u(\n      () => Mt(l, [\n        \"active\",\n        \"activeClass\",\n        \"append\",\n        \"disabled\",\n        \"href\",\n        \"icon\",\n        \"opacity\",\n        \"opacityHover\",\n        \"rel\",\n        \"replace\",\n        \"routerComponentName\",\n        \"target\",\n        \"to\",\n        \"underlineOffset\",\n        \"underlineOffsetHover\",\n        \"underlineOpacity\",\n        \"underlineOpacityHover\",\n        \"underlineVariant\",\n        \"variant\"\n      ])\n    );\n    return (n, s) => (g(), P(\"li\", Ed, [\n      be(Xe, ee({\n        class: [\"nav-link\", n.linkClasses]\n      }, { ...o.value, ...n.linkAttrs }, {\n        \"active-class\": n.activeClass ?? \"active\",\n        tabindex: $(a) ? -1 : void 0,\n        \"aria-disabled\": $(a) ? !0 : void 0,\n        onClick: s[0] || (s[0] = ot((r) => t(\"click\", r), [\"stop\"]))\n      }), {\n        default: j(() => [\n          O(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"class\", \"active-class\", \"tabindex\", \"aria-disabled\"])\n    ]));\n  }\n}), xd = { class: \"nav-item dropdown\" }, Ld = /* @__PURE__ */ N({\n  __name: \"BNavItemDropdown\",\n  props: {\n    id: { default: void 0 },\n    text: { default: void 0 },\n    toggleClass: { default: void 0 },\n    size: { default: \"md\" },\n    offset: { default: void 0 },\n    autoClose: { type: [Boolean, String], default: void 0 },\n    dark: { type: [String, Boolean], default: void 0 },\n    splitVariant: { default: void 0 },\n    noCaret: { type: [String, Boolean], default: void 0 },\n    variant: { default: \"link\" },\n    modelValue: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: void 0 },\n    strategy: { default: void 0 },\n    floatingMiddleware: { default: void 0 },\n    noFlip: { type: [String, Boolean], default: void 0 },\n    noShift: { type: [String, Boolean], default: void 0 },\n    dropup: { type: [String, Boolean], default: void 0 },\n    dropend: { type: [String, Boolean], default: void 0 },\n    dropstart: { type: [String, Boolean], default: void 0 },\n    center: { type: [String, Boolean], default: void 0 },\n    end: { type: [String, Boolean], default: void 0 },\n    menuClass: { default: void 0 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Se(a, \"modelValue\", l, { passive: !0 }), n = d(o), s = u({\n      get: () => n.value,\n      set: (h) => {\n        o.value = h;\n      }\n    }), r = u(() => As(a, [\"modelValue\"]));\n    return t({\n      close: () => {\n        o.value = !1;\n      },\n      open: () => {\n        o.value = !0;\n      },\n      toggle: () => {\n        o.value = !n.value;\n      }\n    }), (h, p) => (g(), P(\"li\", xd, [\n      be(hn, ee({\n        modelValue: s.value,\n        \"onUpdate:modelValue\": p[0] || (p[0] = (B) => s.value = B)\n      }, r.value, { \"is-nav\": \"\" }), {\n        \"button-content\": j(() => [\n          O(h.$slots, \"button-content\")\n        ]),\n        \"toggle-text\": j(() => [\n          O(h.$slots, \"toggle-text\")\n        ]),\n        default: j(() => [\n          O(h.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"modelValue\"])\n    ]));\n  }\n}), Nd = { class: \"navbar-text\" }, zd = /* @__PURE__ */ N({\n  __name: \"BNavText\",\n  props: {\n    text: { default: void 0 }\n  },\n  setup(e) {\n    return (t, l) => (g(), P(\"li\", Nd, [\n      O(t.$slots, \"default\", {}, () => [\n        ne(Y(t.text), 1)\n      ])\n    ]));\n  }\n}), Hd = /* @__PURE__ */ N({\n  __name: \"BNavbar\",\n  props: {\n    fixed: { default: void 0 },\n    print: { type: [String, Boolean], default: !1 },\n    sticky: { default: void 0 },\n    tag: { default: \"nav\" },\n    toggleable: { type: [Boolean, String], default: !1 },\n    dark: { type: [String, Boolean], default: !1 },\n    variant: { default: null },\n    container: { type: [String, Boolean], default: \"fluid\" }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.print), a = d(() => t.dark), o = u(\n      () => t.tag === \"nav\" ? void 0 : \"navigation\"\n    ), n = u(\n      () => typeof t.toggleable == \"string\" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? \"navbar-expand\" : void 0\n    ), s = u(\n      () => t.container === !0 ? \"container\" : \"container-fluid\"\n    ), r = u(() => ({\n      \"d-print\": l.value,\n      [`sticky-${t.sticky}`]: t.sticky !== void 0,\n      \"navbar-dark\": a.value,\n      [`bg-${t.variant}`]: t.variant !== null,\n      [`fixed-${t.fixed}`]: t.fixed !== void 0,\n      [`${n.value}`]: n.value !== void 0\n    }));\n    return De(Wa, {\n      tag: ye(ke(t, \"tag\"))\n    }), (i, v) => (g(), M(le(i.tag), {\n      class: H([\"navbar\", r.value]),\n      role: o.value\n    }, {\n      default: j(() => [\n        i.container !== !1 ? (g(), P(\"div\", {\n          key: 0,\n          class: H(s.value)\n        }, [\n          O(i.$slots, \"default\")\n        ], 2)) : O(i.$slots, \"default\", { key: 1 })\n      ]),\n      _: 3\n    }, 8, [\"class\", \"role\"]));\n  }\n}), Rd = /* @__PURE__ */ N({\n  __name: \"BNavbarBrand\",\n  props: {\n    tag: { default: \"div\" },\n    active: { type: [String, Boolean], default: void 0 },\n    activeClass: { default: \"router-link-active\" },\n    append: { type: [String, Boolean], default: !1 },\n    disabled: { type: [String, Boolean], default: !1 },\n    href: { default: void 0 },\n    rel: { default: void 0 },\n    replace: { type: [String, Boolean], default: !1 },\n    routerComponentName: { default: \"router-link\" },\n    target: { default: \"_self\" },\n    to: { default: void 0 },\n    variant: { default: void 0 },\n    opacity: { default: void 0 },\n    opacityHover: { default: void 0 },\n    underlineVariant: { default: null },\n    underlineOffset: { default: void 0 },\n    underlineOffsetHover: { default: void 0 },\n    underlineOpacity: { default: void 0 },\n    underlineOpacityHover: { default: void 0 },\n    icon: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = u(() => wt(t)), a = u(() => l.value ? Xe : t.tag), o = u(\n      () => l.value ? Mt(t, [\n        \"active\",\n        \"activeClass\",\n        \"append\",\n        \"disabled\",\n        \"href\",\n        \"rel\",\n        \"replace\",\n        \"routerComponentName\",\n        \"target\",\n        \"to\",\n        \"variant\",\n        \"opacity\",\n        \"opacityHover\",\n        \"underlineVariant\",\n        \"underlineOffset\",\n        \"underlineOffsetHover\",\n        \"underlineOpacity\",\n        \"underlineOpacityHover\",\n        \"icon\"\n      ]) : {}\n    );\n    return (n, s) => (g(), M(le(a.value), ee({ class: \"navbar-brand\" }, o.value), {\n      default: j(() => [\n        O(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Md = /* @__PURE__ */ N({\n  __name: \"BNavbarNav\",\n  props: {\n    align: { default: void 0 },\n    fill: { type: [String, Boolean], default: !1 },\n    justified: { type: [String, Boolean], default: !1 },\n    small: { type: [String, Boolean], default: !1 },\n    tag: { default: \"ul\" }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.fill), a = d(() => t.justified), o = d(() => t.small), n = Dt(() => t.align), s = u(() => ({\n      \"nav-fill\": l.value,\n      \"nav-justified\": a.value,\n      [n.value]: t.align !== void 0,\n      small: o.value\n    }));\n    return (r, i) => (g(), P(\"ul\", {\n      class: H([\"navbar-nav\", s.value])\n    }, [\n      O(r.$slots, \"default\")\n    ], 2));\n  }\n}), Zl = (e, t) => e.setAttribute(\"data-bs-theme\", t), Dd = {\n  mounted(e, t) {\n    Zl(e, t.value);\n  },\n  updated(e, t) {\n    Zl(e, t.value);\n  }\n}, sl = (e, t) => {\n  const { modifiers: l, arg: a, value: o } = e, n = Object.keys(l || {}), s = typeof o == \"string\" ? o.split(Kt) : o;\n  if (ks(t.tagName, \"a\")) {\n    const r = qa(t, \"href\") || \"\";\n    ts.test(r) && n.push(r.replace(es, \"\"));\n  }\n  return Array.prototype.concat.apply([], [a, s]).forEach((r) => typeof r == \"string\" && n.push(r)), n.filter((r, i, v) => r && v.indexOf(r) === i);\n}, jd = (e, t) => {\n  sl(e, t).forEach((a) => {\n    const o = document.getElementById(a);\n    o !== null && o.dispatchEvent(new Event(\"bv-toggle\"));\n  }), setTimeout(() => Fn(e, t), 50);\n}, Fn = (e, t) => {\n  const l = sl(e, t);\n  let a = !1;\n  l.forEach((o) => {\n    const n = document.getElementById(o);\n    n != null && n.classList.contains(\"show\") && (a = !0), n != null && n.classList.contains(\"closing\") && (a = !1);\n  }), t.setAttribute(\"aria-expanded\", a ? \"true\" : \"false\");\n}, Ia = {\n  mounted(e, t) {\n    e.__toggle = () => jd(t, e), e.addEventListener(\"click\", e.__toggle), Fn(t, e), e.setAttribute(\"aria-controls\", sl(t, e).join(\" \"));\n  },\n  unmounted(e) {\n    e.removeEventListener(\"click\", e.__toggle), e.removeAttribute(\"aria-controls\"), e.removeAttribute(\"aria-expanded\");\n  }\n}, qd = {\n  mounted(e, t) {\n    if (!zt(t.value))\n      return;\n    const a = na(t.value, e);\n    !a.content && !a.title || (e.$__state = R({\n      ...sa(t, e),\n      ...a\n    }), ln(e, t));\n  },\n  updated(e, t) {\n    if (!zt(t.value))\n      return;\n    const a = na(t.value, e);\n    !a.content && !a.title || e.$__state && (e.$__state.value = {\n      ...sa(t, e),\n      ...a\n    });\n  },\n  beforeUnmount(e) {\n    on(e);\n  }\n}, Gd = {\n  mounted(e, t) {\n    const l = zt(t.value);\n    if (!l)\n      return;\n    const a = na(t.value, e);\n    !a.content && !a.title || (e.$__state = R({\n      ...sa(t, e),\n      title: a.title ?? a.content ?? \"\",\n      tooltip: l\n    }), ln(e, t));\n  },\n  updated(e, t) {\n    const l = zt(t.value);\n    if (!l)\n      return;\n    const a = na(t.value, e);\n    !a.content && !a.title || e.$__state && (e.$__state.value = {\n      ...sa(t, e),\n      title: a.title ?? a.content ?? \"\",\n      tooltip: l\n    });\n  },\n  beforeUnmount(e) {\n    on(e);\n  }\n}, Ql = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  vBColorMode: Dd,\n  vBModal: Ia,\n  vBPopover: qd,\n  vBToggle: Ia,\n  vBTooltip: Gd\n}, Symbol.toStringTag, { value: \"Module\" })), Wd = /* @__PURE__ */ K(\"span\", { class: \"navbar-toggler-icon\" }, null, -1), Ud = /* @__PURE__ */ N({\n  __name: \"BNavbarToggle\",\n  props: {\n    disabled: { type: [String, Boolean], default: !1 },\n    label: { default: \"Toggle navigation\" },\n    target: { default: void 0 }\n  },\n  emits: [\"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.disabled), o = u(() => ({\n      disabled: a.value,\n      \"aria-label\": l.label\n    })), n = u(() => ({\n      disabled: a.value\n    })), s = (r) => {\n      a.value || t(\"click\", r);\n    };\n    return (r, i) => rt((g(), P(\"button\", ee({\n      class: [\"navbar-toggler\", n.value],\n      type: \"button\"\n    }, o.value, { onClick: s }), [\n      O(r.$slots, \"default\", {}, () => [\n        Wd\n      ])\n    ], 16)), [\n      [$(Ia), $(a) ? void 0 : r.target]\n    ]);\n  }\n}), Pn = /* @__PURE__ */ N({\n  __name: \"BOverlay\",\n  props: {\n    bgColor: { default: void 0 },\n    blur: { default: \"2px\" },\n    fixed: { type: [String, Boolean], default: !1 },\n    noCenter: { type: [String, Boolean], default: !1 },\n    noFade: { type: [String, Boolean], default: !1 },\n    noWrap: { type: [String, Boolean], default: !1 },\n    opacity: { default: 0.85 },\n    overlayTag: { default: \"div\" },\n    rounded: { type: [Boolean, String], default: !1 },\n    show: { type: [String, Boolean], default: !1 },\n    spinnerSmall: { type: [String, Boolean], default: !1 },\n    spinnerType: { default: \"border\" },\n    spinnerVariant: { default: void 0 },\n    noSpinner: { type: [String, Boolean], default: !1 },\n    variant: { default: \"light\" },\n    wrapTag: { default: \"div\" },\n    zIndex: { default: 10 }\n  },\n  emits: [\"click\", \"hidden\", \"shown\"],\n  setup(e, { emit: t }) {\n    const l = e, a = { top: 0, left: 0, bottom: 0, right: 0 }, o = d(() => l.fixed), n = d(() => l.noSpinner), s = d(() => l.noCenter), r = d(() => l.noWrap), i = d(() => l.show), v = d(() => l.spinnerSmall), b = u(\n      () => l.rounded === !0 || l.rounded === \"\" ? \"rounded\" : l.rounded === !1 ? \"\" : `rounded-${l.rounded}`\n    ), h = u(\n      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : \"\"\n    ), p = u(() => i.value ? !0 : null), B = u(() => ({\n      type: l.spinnerType,\n      variant: l.spinnerVariant,\n      small: v.value\n    })), S = u(() => ({\n      ...a,\n      zIndex: l.zIndex || 10\n    })), m = u(() => [\n      \"b-overlay\",\n      {\n        \"position-absolute\": !r.value || !o.value,\n        \"position-fixed\": r.value && o.value\n      }\n    ]), A = u(() => [h.value, b.value]), y = u(() => ({\n      ...a,\n      opacity: l.opacity,\n      backgroundColor: l.bgColor || void 0,\n      backdropFilter: l.blur ? `blur(${l.blur})` : void 0\n    })), k = u(\n      () => s.value ? a : {\n        top: \"50%\",\n        left: \"50%\",\n        transform: \"translateX(-50%) translateY(-50%)\"\n      }\n    );\n    return (w, _) => (g(), M(le(w.wrapTag), {\n      class: \"b-overlay-wrap position-relative\",\n      \"aria-busy\": p.value\n    }, {\n      default: j(() => [\n        O(w.$slots, \"default\"),\n        be(At, {\n          \"no-fade\": w.noFade,\n          \"trans-props\": { enterToClass: \"show\" },\n          name: \"fade\",\n          onOnAfterEnter: _[1] || (_[1] = (C) => t(\"shown\")),\n          onOnAfterLeave: _[2] || (_[2] = (C) => t(\"hidden\"))\n        }, {\n          default: j(() => [\n            $(i) ? (g(), M(le(w.overlayTag), {\n              key: 0,\n              class: H(m.value),\n              style: ze(S.value),\n              onClick: _[0] || (_[0] = (C) => t(\"click\", C))\n            }, {\n              default: j(() => [\n                K(\"div\", {\n                  class: H([\"position-absolute\", A.value]),\n                  style: ze(y.value)\n                }, null, 6),\n                K(\"div\", {\n                  class: \"position-absolute\",\n                  style: ze(k.value)\n                }, [\n                  O(w.$slots, \"overlay\", Be(Ve(B.value)), () => [\n                    $(n) ? J(\"\", !0) : (g(), M(pa, Be(ee({ key: 0 }, B.value)), null, 16))\n                  ])\n                ], 4)\n              ]),\n              _: 3\n            }, 8, [\"class\", \"style\"])) : J(\"\", !0)\n          ]),\n          _: 3\n        }, 8, [\"no-fade\"])\n      ]),\n      _: 3\n    }, 8, [\"aria-busy\"]));\n  }\n}), Xd = [\"id\", \"aria-labelledby\"], Kd = [\"id\"], Yd = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BOffcanvas\",\n  props: {\n    dismissLabel: { default: \"Close\" },\n    modelValue: { type: [String, Boolean], default: !1 },\n    bodyScrolling: { type: [String, Boolean], default: !1 },\n    backdrop: { type: [String, Boolean], default: !0 },\n    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },\n    noCloseOnEsc: { type: [String, Boolean], default: !1 },\n    placement: { default: \"start\" },\n    title: { default: void 0 },\n    noHeaderClose: { type: [String, Boolean], default: !1 },\n    noHeader: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: !1 },\n    id: { default: void 0 },\n    noFocus: { type: [String, Boolean], default: !1 },\n    backdropVariant: { default: \"dark\" },\n    headerClass: { default: void 0 },\n    bodyClass: { default: void 0 },\n    footerClass: { default: void 0 },\n    teleportDisabled: { type: [String, Boolean], default: !1 },\n    teleportTo: { default: \"body\" }\n  },\n  emits: [\"update:modelValue\", \"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"esc\", \"close\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Fe(), n = Se(a, \"modelValue\", l, { passive: !0 }), s = d(n), r = d(() => a.bodyScrolling), i = d(() => a.backdrop), v = d(() => a.noHeaderClose), b = d(() => a.noHeader), h = d(() => a.noFocus), p = d(() => a.noCloseOnBackdrop), B = d(() => a.noCloseOnEsc), S = d(() => a.lazy), m = d(() => a.teleportDisabled), A = _e(() => a.id, \"offcanvas\");\n    an(s, r);\n    const y = R(null), { focused: k } = Ee(y, {\n      initialValue: s.value && h.value === !1\n    }), w = R(s.value), _ = R(!1), C = u(\n      () => i.value === !0 && s.value === !0\n    ), T = u(\n      () => S.value === !1 || S.value === !0 && _.value === !0 || S.value === !0 && s.value === !0\n    ), c = u(() => !Ae(o.footer)), V = u(() => [\n      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n      \"offcanvas\",\n      // Remove when above check is fixed\n      `offcanvas-${a.placement}`,\n      {\n        show: s.value && w.value === !0\n      }\n    ]), F = (W, X = {}) => new Rt(W, {\n      cancelable: !1,\n      target: y.value || null,\n      relatedTarget: null,\n      trigger: null,\n      ...X,\n      componentId: A.value\n    }), f = (W = \"\") => {\n      const X = F(\"hide\", { cancelable: W !== \"\", trigger: W });\n      if (W === \"close\" && l(W, X), W === \"esc\" && l(W, X), l(\"hide\", X), X.defaultPrevented || W === \"backdrop\" && p.value || W === \"esc\" && B.value) {\n        l(\"hide-prevented\");\n        return;\n      }\n      n.value = !1;\n    }, I = () => {\n      const W = F(\"show\", { cancelable: !0 });\n      if (l(\"show\", W), W.defaultPrevented) {\n        n.value = !1, l(\"show-prevented\");\n        return;\n      }\n      n.value = !0;\n    }, E = () => {\n      Ce(() => {\n        h.value === !1 && (k.value = !0);\n      });\n    }, z = () => I(), Z = () => {\n      w.value = !0, E(), l(\"shown\", F(\"shown\")), S.value === !0 && (_.value = !0);\n    }, te = () => {\n      w.value = !1;\n    }, G = () => {\n      l(\"hidden\", F(\"hidden\")), S.value === !0 && (_.value = !1);\n    };\n    return we(y, \"bv-toggle\", () => {\n      s.value ? f() : I();\n    }), t({\n      hide: f,\n      show: I\n    }), (W, X) => (g(), M(Na, {\n      to: W.teleportTo,\n      disabled: $(m)\n    }, [\n      be(At, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"showing\",\n          enterFromClass: \"\",\n          leaveToClass: \"hiding show\",\n          leaveFromClass: \"show\"\n        },\n        onBeforeEnter: z,\n        onAfterEnter: Z,\n        onLeave: te,\n        onAfterLeave: G\n      }, {\n        default: j(() => [\n          rt(K(\"div\", ee({\n            id: $(A),\n            ref_key: \"element\",\n            ref: y,\n            \"aria-modal\": \"true\",\n            role: \"dialog\",\n            class: V.value,\n            tabindex: \"-1\",\n            \"aria-labelledby\": `${$(A)}-offcanvas-label`,\n            \"data-bs-backdrop\": \"false\"\n          }, W.$attrs, {\n            onKeyup: X[1] || (X[1] = It((ve) => f(\"esc\"), [\"esc\"]))\n          }), [\n            T.value ? (g(), P(ce, { key: 0 }, [\n              $(b) ? J(\"\", !0) : (g(), P(\"div\", {\n                key: 0,\n                class: H([\"offcanvas-header\", W.headerClass])\n              }, [\n                O(W.$slots, \"header\", Be(Ve({ visible: $(s), placement: W.placement, hide: f })), () => [\n                  K(\"h5\", {\n                    id: `${$(A)}-offcanvas-label`,\n                    class: \"offcanvas-title\"\n                  }, [\n                    O(W.$slots, \"title\", {}, () => [\n                      ne(Y(W.title), 1)\n                    ])\n                  ], 8, Kd),\n                  $(v) ? J(\"\", !0) : (g(), M(Ot, {\n                    key: 0,\n                    class: \"text-reset\",\n                    \"aria-label\": W.dismissLabel,\n                    onClick: X[0] || (X[0] = (ve) => f(\"close\"))\n                  }, null, 8, [\"aria-label\"]))\n                ])\n              ], 2)),\n              K(\"div\", {\n                class: H([\"offcanvas-body\", W.bodyClass])\n              }, [\n                O(W.$slots, \"default\")\n              ], 2),\n              c.value ? (g(), P(\"div\", {\n                key: 1,\n                class: H(W.footerClass)\n              }, [\n                O(W.$slots, \"footer\", Be(Ve({ visible: $(s), placement: W.placement, hide: f })))\n              ], 2)) : J(\"\", !0)\n            ], 64)) : J(\"\", !0)\n          ], 16, Xd), [\n            [ua, $(n)]\n          ])\n        ]),\n        _: 3\n      }),\n      be(Pn, {\n        variant: W.backdropVariant,\n        show: C.value,\n        fixed: !0,\n        \"no-wrap\": \"\",\n        \"no-spinner\": !0,\n        onClick: X[2] || (X[2] = (ve) => f(\"backdrop\"))\n      }, null, 8, [\"variant\", \"show\"])\n    ], 8, [\"to\", \"disabled\"]));\n  }\n}), Jd = 5, En = 20, In = 0, je = 3, Zd = \"ellipsis-text\", Qd = \"first-text\", ec = \"last-text\", tc = \"next-text\", ac = \"page\", lc = \"prev-text\", eo = (e) => Math.max(lt(e) || En, 1), to = (e) => Math.max(lt(e) || In, 0), oc = (e, t) => {\n  const l = lt(e) || 1;\n  return l > t ? t : l < 1 ? 1 : l;\n}, nc = N({\n  name: \"BPagination\",\n  props: {\n    align: { type: String, default: \"start\" },\n    ariaControls: { type: String, default: void 0 },\n    ariaLabel: { type: String, default: \"Pagination\" },\n    disabled: { type: [Boolean, String], default: !1 },\n    ellipsisClass: { type: [Array, String], default: () => [] },\n    ellipsisText: { type: String, default: \"â¦\" },\n    firstClass: { type: [Array, String], default: () => [] },\n    firstNumber: { type: [Boolean, String], default: !1 },\n    firstText: { type: String, default: \"Â«\" },\n    hideEllipsis: { type: [Boolean, String], default: !1 },\n    hideGotoEndButtons: { type: [Boolean, String], default: !1 },\n    labelFirstPage: { type: String, default: \"Go to first page\" },\n    labelLastPage: { type: String, default: \"Go to last page\" },\n    labelNextPage: { type: String, default: \"Go to next page\" },\n    labelPage: { type: String, default: \"Go to page\" },\n    labelPrevPage: { type: String, default: \"Go to previous page\" },\n    lastClass: { type: [Array, String], default: () => [] },\n    lastNumber: { type: [Boolean, String], default: !1 },\n    lastText: { type: String, default: \"Â»\" },\n    limit: { type: Number, default: Jd },\n    modelValue: { type: Number, default: 1 },\n    // V-model prop\n    nextClass: { type: [Array, String], default: () => [] },\n    nextText: { type: String, default: \"âº\" },\n    pageClass: { type: [Array, String], default: () => [] },\n    perPage: { type: Number, default: En },\n    pills: { type: [Boolean, String], default: !1 },\n    prevClass: { type: [Array, String], default: () => [] },\n    prevText: { type: String, default: \"â¹\" },\n    size: { type: String, default: \"md\" },\n    totalRows: { type: Number, default: In }\n  },\n  emits: [\"update:modelValue\", \"page-click\"],\n  setup(e, { emit: t, slots: l }) {\n    const a = Se(e, \"modelValue\", t), o = d(() => e.disabled), n = d(() => e.firstNumber), s = d(() => e.hideEllipsis), r = d(() => e.hideGotoEndButtons), i = d(() => e.lastNumber), v = d(() => e.pills), b = u(\n      () => e.align === \"fill\" ? \"start\" : e.align\n    ), h = Dt(b), p = u(\n      () => Math.ceil(to(e.totalRows) / eo(e.perPage))\n    ), B = u(() => {\n      let T;\n      return p.value - a.value + 2 < e.limit && e.limit > je ? T = p.value - m.value + 1 : T = a.value - Math.floor(m.value / 2), T < 1 ? T = 1 : T > p.value - m.value && (T = p.value - m.value + 1), e.limit <= je && i.value && p.value === T + m.value - 1 && (T = Math.max(T - 1, 1)), T;\n    }), S = u(() => {\n      const T = p.value - a.value;\n      let c = !1;\n      return T + 2 < e.limit && e.limit > je ? e.limit > je && (c = !0) : e.limit > je && (c = !!(!s.value || n.value)), B.value <= 1 && (c = !1), c && n.value && B.value < 4 && (c = !1), c;\n    }), m = u(() => {\n      let T = e.limit;\n      return p.value <= e.limit ? T = p.value : a.value < e.limit - 1 && e.limit > je ? ((!s.value || i.value) && (T = e.limit - (n.value ? 0 : 1)), T = Math.min(T, e.limit)) : p.value - a.value + 2 < e.limit && e.limit > je ? (!s.value || n.value) && (T = e.limit - (i.value ? 0 : 1)) : e.limit > je && (T = e.limit - (s.value ? 0 : 2)), T;\n    }), A = u(() => {\n      const T = p.value - m.value;\n      let c = !1;\n      a.value < e.limit - 1 && e.limit > je ? (!s.value || i.value) && (c = !0) : e.limit > je && (c = !!(!s.value || i.value)), B.value > T && (c = !1);\n      const V = B.value + m.value - 1;\n      return c && i.value && V > p.value - 3 && (c = !1), c;\n    }), y = St({\n      pageSize: eo(e.perPage),\n      totalRows: to(e.totalRows),\n      numberOfPages: p.value\n    }), k = (T, c) => {\n      if (c === a.value)\n        return;\n      const { target: V } = T, F = new Ge(\"page-click\", {\n        cancelable: !0,\n        target: V\n      });\n      t(\"page-click\", F, c), !F.defaultPrevented && (a.value = c);\n    }, w = u(() => e.size ? `pagination-${e.size}` : \"\"), _ = u(() => v.value ? \"b-pagination-pills\" : \"\");\n    oe(a, (T) => {\n      const c = oc(T, p.value);\n      c !== a.value && (a.value = c);\n    }), oe(y, (T, c) => {\n      T != null && (c.pageSize !== T.pageSize && c.totalRows === T.totalRows || c.numberOfPages !== T.numberOfPages && a.value > c.numberOfPages) && (a.value = 1);\n    });\n    const C = u(() => {\n      const T = [];\n      for (let c = 0; c < m.value; c++)\n        T.push({ number: B.value + c, classes: null });\n      return T;\n    });\n    return () => {\n      const T = [], c = C.value.map((G) => G.number), V = (G) => G === a.value, F = a.value < 1, f = e.align === \"fill\", I = (G, W, X, ve, ge, pe) => {\n        const me = o.value || V(pe) || F || G < 1 || G > p.value, q = G < 1 ? 1 : G > p.value ? p.value : G, Q = { disabled: me, page: q, index: q - 1 }, re = Ne(X, Q, l) || ve || \"\";\n        return ie(\n          \"li\",\n          {\n            class: [\n              \"page-item\",\n              {\n                disabled: me,\n                \"flex-fill\": f,\n                \"d-flex\": f && !me\n              },\n              ge\n            ]\n          },\n          // render inner content\n          ie(\n            me ? \"span\" : \"button\",\n            {\n              class: [\"page-link\", { \"flex-grow-1\": !me && f }],\n              \"aria-label\": W,\n              \"aria-controls\": e.ariaControls || null,\n              \"aria-disabled\": me ? !0 : null,\n              role: \"menuitem\",\n              type: me ? null : \"button\",\n              tabindex: me ? null : \"-1\",\n              onClick: (de) => {\n                me || k(de, q);\n              }\n            },\n            re\n          )\n        );\n      }, E = (G) => ie(\n        \"li\",\n        {\n          class: [\n            \"page-item\",\n            \"disabled\",\n            \"bv-d-xs-down-none\",\n            f ? \"flex-fill\" : \"\",\n            e.ellipsisClass\n          ],\n          role: \"separator\",\n          key: `ellipsis-${G ? \"last\" : \"first\"}`\n        },\n        [\n          ie(\n            \"span\",\n            { class: [\"page-link\"] },\n            Ne(Zd, {}, l) || e.ellipsisText || \"...\"\n          )\n        ]\n      ), z = (G, W) => {\n        const X = V(G.number) && !F, ve = o.value ? null : X || F && W === 0 ? \"0\" : \"-1\", ge = {\n          active: X,\n          disabled: o.value,\n          page: G.number,\n          index: G.number - 1,\n          content: G.number\n        }, pe = Ne(ac, ge, l) || G.number, me = ie(\n          o.value ? \"span\" : \"button\",\n          {\n            class: [\"page-link\", { \"flex-grow-1\": !o.value && f }],\n            \"aria-controls\": e.ariaControls || null,\n            \"aria-disabled\": o.value ? !0 : null,\n            \"aria-label\": e.labelPage ? `${e.labelPage} ${G.number}` : null,\n            role: \"menuitemradio\",\n            type: o.value ? null : \"button\",\n            tabindex: ve,\n            onClick: (q) => {\n              o.value || k(q, G.number);\n            }\n          },\n          pe\n        );\n        return ie(\n          \"li\",\n          {\n            class: [\n              \"page-item\",\n              {\n                disabled: o.value,\n                active: X,\n                \"flex-fill\": f,\n                \"d-flex\": f && !o.value\n              },\n              e.pageClass\n            ],\n            role: \"presentation\",\n            key: `page-${G.number}`\n          },\n          me\n        );\n      };\n      if (!r.value && !n.value) {\n        const G = I(\n          1,\n          e.labelFirstPage,\n          Qd,\n          e.firstText,\n          e.firstClass,\n          1\n        );\n        T.push(G);\n      }\n      const Z = I(\n        a.value - 1,\n        e.labelFirstPage,\n        lc,\n        e.prevText,\n        e.prevClass,\n        1\n      );\n      T.push(Z), n.value && c[0] !== 1 && T.push(z({ number: 1 }, 0)), S.value && T.push(E(!1)), C.value.forEach((G, W) => {\n        const X = S.value && n.value && c[0] !== 1 ? 1 : 0;\n        T.push(z(G, W + X));\n      }), A.value && T.push(E(!0)), i.value && c[c.length - 1] !== p.value && T.push(z({ number: p.value }, -1));\n      const te = I(\n        a.value + 1,\n        e.labelNextPage,\n        tc,\n        e.nextText,\n        e.nextClass,\n        p.value\n      );\n      if (T.push(te), !i.value && !r.value) {\n        const G = I(\n          p.value,\n          e.labelLastPage,\n          ec,\n          e.lastText,\n          e.lastClass,\n          p.value\n        );\n        T.push(G);\n      }\n      return ie(\n        \"ul\",\n        {\n          class: [\"pagination\", w.value, h.value, _.value],\n          role: \"menubar\",\n          \"aria-disabled\": o.value,\n          \"aria-label\": e.ariaLabel || null\n        },\n        T\n      );\n    };\n  }\n}), Le = /* @__PURE__ */ N({\n  inheritAttrs: !1,\n  __name: \"BPlaceholder\",\n  props: {\n    tag: { default: \"span\" },\n    wrapperTag: { default: \"span\" },\n    width: { default: void 0 },\n    cols: { default: 12 },\n    variant: { default: null },\n    size: { default: \"md\" },\n    animation: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = u(\n      () => t.width === void 0 ? void 0 : typeof t.width == \"number\" ? t.width.toString() : t.width.replace(\"%\", \"\")\n    ), a = u(\n      () => t.cols === void 0 ? void 0 : typeof t.cols == \"number\" ? t.cols.toString() : t.cols\n    ), o = u(() => ({\n      [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,\n      [`bg-${t.variant}`]: t.variant !== null,\n      [`placeholder-${t.size}`]: t.size !== \"md\"\n    })), n = u(() => ({\n      [`placeholder-${t.animation}`]: t.animation !== void 0\n    })), s = u(() => ({\n      width: l.value === void 0 ? void 0 : `${l.value}%`\n    }));\n    return (r, i) => (g(), M(le(r.wrapperTag), {\n      class: H(n.value)\n    }, {\n      default: j(() => [\n        (g(), M(le(r.tag), ee(r.$attrs, {\n          class: [\"placeholder\", o.value],\n          style: s.value\n        }), null, 16, [\"class\", \"style\"]))\n      ]),\n      _: 1\n    }, 8, [\"class\"]));\n  }\n}), xn = /* @__PURE__ */ N({\n  __name: \"BPlaceholderButton\",\n  props: {\n    tag: { default: \"div\" },\n    width: { default: void 0 },\n    cols: { default: void 0 },\n    variant: { default: \"primary\" },\n    animation: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`btn-${t.variant}`]: t.variant !== null\n    })), a = u(() => ({\n      animation: t.animation,\n      width: t.width,\n      cols: t.cols,\n      tag: t.tag\n    }));\n    return (o, n) => (g(), M(Le, ee({\n      class: [\"btn disabled\", l.value]\n    }, a.value), null, 16, [\"class\"]));\n  }\n}), sc = /* @__PURE__ */ N({\n  __name: \"BPlaceholderCard\",\n  props: {\n    noHeader: { type: [String, Boolean], default: !1 },\n    headerWidth: { default: 100 },\n    headerVariant: { default: void 0 },\n    headerAnimation: { default: void 0 },\n    headerSize: { default: \"md\" },\n    noFooter: { type: [String, Boolean], default: !1 },\n    footerWidth: { default: 100 },\n    footerVariant: { default: void 0 },\n    footerAnimation: { default: void 0 },\n    footerSize: { default: \"md\" },\n    animation: { default: void 0 },\n    size: { default: \"md\" },\n    variant: { default: void 0 },\n    noButton: { type: [String, Boolean], default: !1 },\n    imgBottom: { type: [String, Boolean], default: !1 },\n    imgSrc: { default: void 0 },\n    imgBlankColor: { default: \"#868e96\" },\n    imgHeight: { default: 100 },\n    noImg: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.noButton), a = d(() => t.noHeader), o = d(() => t.noFooter), n = d(() => t.noImg), s = u(() => ({\n      width: t.headerWidth,\n      variant: t.headerVariant,\n      animation: t.headerAnimation,\n      size: t.headerSize\n    })), r = u(() => ({\n      width: t.footerWidth,\n      animation: t.footerAnimation,\n      size: l.value ? t.footerSize : void 0,\n      variant: t.footerVariant\n    })), i = u(() => ({\n      animation: t.animation,\n      size: t.size,\n      variant: t.variant\n    })), v = u(() => ({\n      blank: !t.imgSrc,\n      blankColor: t.imgBlankColor,\n      height: t.imgSrc ? void 0 : t.imgHeight,\n      src: t.imgSrc,\n      top: !t.imgBottom,\n      bottom: t.imgBottom\n    }));\n    return (b, h) => (g(), M(pn, { \"img-bottom\": b.imgBottom }, Ha({\n      default: j(() => [\n        O(b.$slots, \"default\", {}, () => [\n          be(Le, ee({ cols: \"7\" }, i.value), null, 16),\n          be(Le, ee({ cols: \"4\" }, i.value), null, 16),\n          be(Le, ee({ cols: \"4\" }, i.value), null, 16),\n          be(Le, ee({ cols: \"6\" }, i.value), null, 16),\n          be(Le, ee({ cols: \"8\" }, i.value), null, 16)\n        ])\n      ]),\n      _: 2\n    }, [\n      $(n) ? void 0 : {\n        name: \"img\",\n        fn: j(() => [\n          O(b.$slots, \"img\", {}, () => [\n            be(ra, Be(Ve(v.value)), null, 16)\n          ])\n        ]),\n        key: \"0\"\n      },\n      $(a) ? void 0 : {\n        name: \"header\",\n        fn: j(() => [\n          O(b.$slots, \"header\", {}, () => [\n            be(Le, Be(Ve(s.value)), null, 16)\n          ])\n        ]),\n        key: \"1\"\n      },\n      $(o) ? void 0 : {\n        name: \"footer\",\n        fn: j(() => [\n          O(b.$slots, \"footer\", {}, () => [\n            $(l) ? (g(), M(Le, Be(ee({ key: 1 }, r.value)), null, 16)) : (g(), M(xn, Be(ee({ key: 0 }, r.value)), null, 16))\n          ])\n        ]),\n        key: \"2\"\n      }\n    ]), 1032, [\"img-bottom\"]));\n  }\n}), rl = /* @__PURE__ */ N({\n  __name: \"BTableSimple\",\n  props: {\n    bordered: { type: [String, Boolean], default: !1 },\n    borderless: { type: [String, Boolean], default: !1 },\n    borderVariant: { default: null },\n    captionTop: { type: [String, Boolean], default: !1 },\n    dark: { type: [String, Boolean], default: !1 },\n    hover: { type: [String, Boolean], default: !1 },\n    responsive: { type: [Boolean, String], default: !1 },\n    stacked: { type: [Boolean, String], default: !1 },\n    striped: { type: [String, Boolean], default: !1 },\n    small: { type: [String, Boolean], default: !1 },\n    tableClass: { default: void 0 },\n    tableVariant: { default: null },\n    stickyHeader: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.captionTop), a = d(() => t.borderless), o = d(() => t.bordered), n = d(() => t.dark), s = d(() => t.hover), r = d(() => t.small), i = d(() => t.striped), v = d(() => t.stickyHeader), b = u(() => [\n      \"table\",\n      \"b-table\",\n      {\n        \"table-bordered\": o.value,\n        \"table-borderless\": a.value,\n        [`border-${t.borderVariant}`]: t.borderVariant !== null,\n        \"caption-top\": l.value,\n        \"table-dark\": n.value,\n        \"table-hover\": s.value,\n        \"b-table-stacked\": typeof t.stacked == \"boolean\" && t.stacked,\n        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == \"string\",\n        \"table-striped\": i.value,\n        \"table-sm\": r.value,\n        [`table-${t.tableVariant}`]: t.tableVariant !== null\n      },\n      t.tableClass\n    ]), h = u(() => [\n      {\n        \"table-responsive\": t.responsive === !0,\n        [`table-responsive-${t.responsive}`]: typeof t.responsive == \"string\",\n        \"b-table-sticky-header\": v.value\n      }\n    ]);\n    return (p, B) => p.responsive ? (g(), P(\"div\", {\n      key: 1,\n      class: H(h.value)\n    }, [\n      K(\"table\", {\n        class: H(b.value)\n      }, [\n        O(p.$slots, \"default\")\n      ], 2)\n    ], 2)) : (g(), P(\"table\", {\n      key: 0,\n      class: H(b.value)\n    }, [\n      O(p.$slots, \"default\")\n    ], 2));\n  }\n}), rc = /* @__PURE__ */ N({\n  __name: \"BPlaceholderTable\",\n  props: {\n    rows: { default: 3 },\n    columns: { default: 5 },\n    cellWidth: { default: 100 },\n    size: { default: \"md\" },\n    animation: { default: void 0 },\n    variant: { default: void 0 },\n    headerColumns: { default: void 0 },\n    hideHeader: { type: [String, Boolean], default: !1 },\n    headerCellWidth: { default: 100 },\n    headerSize: { default: \"md\" },\n    headerAnimation: { default: void 0 },\n    headerVariant: { default: void 0 },\n    footerColumns: { default: void 0 },\n    showFooter: { type: [String, Boolean], default: !1 },\n    footerCellWidth: { default: 100 },\n    footerSize: { default: \"md\" },\n    footerAnimation: { default: void 0 },\n    footerVariant: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = bt(() => t.columns, { nanToZero: !0, method: \"parseInt\" }), a = bt(() => t.rows, { nanToZero: !0, method: \"parseInt\" }), o = u(() => t.headerColumns ?? NaN), n = u(() => t.footerColumns ?? NaN), s = bt(o, {\n      nanToZero: !0,\n      method: \"parseInt\"\n    }), r = bt(n, {\n      nanToZero: !0,\n      method: \"parseInt\"\n    }), i = u(() => l.value || 5), v = u(() => a.value || 3), b = u(\n      () => t.headerColumns === void 0 ? i.value : s.value\n    ), h = u(\n      () => t.footerColumns === void 0 ? i.value : r.value\n    ), p = u(() => ({\n      size: t.size,\n      variant: t.variant,\n      animation: t.animation,\n      width: t.cellWidth\n    })), B = u(() => ({\n      size: t.headerSize,\n      variant: t.headerVariant,\n      animation: t.headerAnimation,\n      width: t.headerCellWidth\n    })), S = u(() => ({\n      size: t.footerSize,\n      variant: t.footerVariant,\n      animation: t.footerAnimation,\n      width: t.footerCellWidth\n    })), m = d(() => t.hideHeader), A = d(() => t.showFooter);\n    return (y, k) => (g(), M(rl, null, {\n      default: j(() => [\n        $(m) ? J(\"\", !0) : O(y.$slots, \"thead\", { key: 0 }, () => [\n          K(\"thead\", null, [\n            K(\"tr\", null, [\n              (g(!0), P(ce, null, he(b.value, (w, _) => (g(), P(\"th\", { key: _ }, [\n                be(Le, Be(Ve(B.value)), null, 16)\n              ]))), 128))\n            ])\n          ])\n        ]),\n        O(y.$slots, \"default\", {}, () => [\n          K(\"tbody\", null, [\n            (g(!0), P(ce, null, he(v.value, (w, _) => (g(), P(\"tr\", { key: _ }, [\n              (g(!0), P(ce, null, he(i.value, (C, T) => (g(), P(\"td\", { key: T }, [\n                be(Le, Be(Ve(p.value)), null, 16)\n              ]))), 128))\n            ]))), 128))\n          ])\n        ]),\n        $(A) ? O(y.$slots, \"tfoot\", { key: 1 }, () => [\n          K(\"tfoot\", null, [\n            K(\"tr\", null, [\n              (g(!0), P(ce, null, he(h.value, (w, _) => (g(), P(\"th\", { key: _ }, [\n                be(Le, Be(Ve(S.value)), null, 16)\n              ]))), 128))\n            ])\n          ])\n        ]) : J(\"\", !0)\n      ]),\n      _: 3\n    }));\n  }\n}), ic = /* @__PURE__ */ N({\n  __name: \"BPlaceholderWrapper\",\n  props: {\n    loading: { type: [String, Boolean], default: !1 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.loading);\n    return (a, o) => $(l) ? O(a.$slots, \"loading\", { key: 0 }) : O(a.$slots, \"default\", { key: 1 });\n  }\n}), uc = [\"aria-valuenow\", \"aria-valuemax\"], Ln = /* @__PURE__ */ N({\n  __name: \"BProgressBar\",\n  props: {\n    animated: { type: [String, Boolean], default: !1 },\n    label: { default: void 0 },\n    labelHtml: { default: void 0 },\n    max: { default: void 0 },\n    precision: { default: 0 },\n    showProgress: { type: [String, Boolean], default: !1 },\n    showValue: { type: [String, Boolean], default: !1 },\n    striped: { type: [String, Boolean], default: !1 },\n    value: { default: 0 },\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = Oe(So, null), a = d(() => t.animated), o = d(() => t.showProgress), n = d(() => t.showValue), s = d(() => t.striped), r = u(() => ({\n      \"progress-bar-animated\": a.value || (l == null ? void 0 : l.animated.value),\n      \"progress-bar-striped\": s.value || (l == null ? void 0 : l.striped.value) || a.value || (l == null ? void 0 : l.animated.value),\n      [`bg-${t.variant}`]: t.variant !== null\n    })), i = u(\n      () => typeof t.precision == \"number\" ? t.precision : Number.parseFloat(t.precision)\n    ), v = u(\n      () => typeof t.value == \"number\" ? t.value : Number.parseFloat(t.value)\n    ), b = u(\n      () => typeof t.max == \"number\" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)\n    ), h = u(\n      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || l != null && l.showValue.value ? v.value.toFixed(i.value) : o.value || l != null && l.showProgress.value ? (v.value * 100 / (b.value || 100)).toFixed(i.value) : t.label !== void 0 ? t.label : \"\"\n    ), p = u(\n      () => l != null && l.max.value ? `${v.value * 100 / (typeof l.max.value == \"number\" ? l.max.value : Number.parseInt(l.max.value))}%` : t.max ? `${v.value * 100 / (typeof t.max == \"number\" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == \"string\" ? t.value : `${t.value}%`\n    );\n    return (B, S) => (g(), P(\"div\", {\n      class: H([\"progress-bar\", r.value]),\n      role: \"progressbar\",\n      \"aria-valuenow\": B.value,\n      \"aria-valuemin\": \"0\",\n      \"aria-valuemax\": B.max,\n      style: ze({ width: p.value })\n    }, [\n      O(B.$slots, \"default\", {}, () => [\n        ne(Y(h.value), 1)\n      ])\n    ], 14, uc));\n  }\n}), dc = /* @__PURE__ */ N({\n  __name: \"BProgress\",\n  props: {\n    variant: { default: void 0 },\n    max: { default: 100 },\n    height: { default: void 0 },\n    animated: { type: [String, Boolean], default: !1 },\n    precision: { default: 0 },\n    showProgress: { type: [String, Boolean], default: !1 },\n    showValue: { type: [String, Boolean], default: !1 },\n    striped: { type: [String, Boolean], default: !1 },\n    value: { default: 0 }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.animated), a = d(() => t.showProgress), o = d(() => t.showValue), n = d(() => t.striped), s = u(() => ({\n      animated: t.animated,\n      max: t.max,\n      precision: t.precision,\n      showProgress: t.showProgress,\n      showValue: t.showValue,\n      striped: t.striped,\n      value: t.value,\n      variant: t.variant\n    }));\n    return De(So, {\n      animated: l,\n      max: ye(ke(t, \"max\")),\n      showProgress: a,\n      showValue: o,\n      striped: n\n    }), (r, i) => (g(), P(\"div\", {\n      class: \"progress\",\n      style: ze({ height: r.height })\n    }, [\n      O(r.$slots, \"default\", {}, () => [\n        be(Ln, Be(Ve(s.value)), null, 16)\n      ])\n    ], 4));\n  }\n}), ao = da(\"cols\", [\"\"], { type: [String, Number], default: null }), cc = N({\n  name: \"BRow\",\n  slots: Object,\n  props: {\n    tag: { type: String, default: \"div\" },\n    gutterX: { type: String, default: null },\n    gutterY: { type: String, default: null },\n    noGutters: { type: [Boolean, String], default: !1 },\n    alignV: { type: String, default: null },\n    alignH: { type: String, default: null },\n    alignContent: { type: String, default: null },\n    ...ao\n  },\n  setup(e) {\n    const t = d(() => e.noGutters), l = Dt(() => e.alignH), a = u(() => bo(e, ao, \"cols\", \"row-cols\"));\n    return {\n      computedClasses: u(() => [\n        a.value,\n        {\n          [`gx-${e.gutterX}`]: e.gutterX !== null,\n          [`gy-${e.gutterY}`]: e.gutterY !== null,\n          \"g-0\": t.value,\n          [`align-items-${e.alignV}`]: e.alignV !== null,\n          [l.value]: e.alignH !== null,\n          [`align-content-${e.alignContent}`]: e.alignContent !== null\n        }\n      ])\n    };\n  }\n});\nfunction fc(e, t, l, a, o, n) {\n  return g(), M(le(e.tag), {\n    class: H([\"row\", e.computedClasses])\n  }, {\n    default: j(() => [\n      O(e.$slots, \"default\")\n    ]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst vc = /* @__PURE__ */ ll(cc, [[\"render\", fc]]), pc = [\"TD\", \"TH\", \"TR\"], mc = [\n  \"a\",\n  \"a *\",\n  // Include content inside links\n  \"button\",\n  \"button *\",\n  // Include content inside buttons\n  \"input:not(.disabled):not([disabled])\",\n  \"select:not(.disabled):not([disabled])\",\n  \"textarea:not(.disabled):not([disabled])\",\n  '[role=\"link\"]',\n  '[role=\"link\"] *',\n  '[role=\"button\"]',\n  '[role=\"button\"] *',\n  \"[tabindex]:not(.disabled):not([disabled])\"\n].join(\",\"), Xt = (e) => {\n  if (!e || !e.target)\n    return !1;\n  const t = e.target;\n  if (\"disabled\" in t && t.disabled || pc.indexOf(t.tagName) !== -1)\n    return !1;\n  if (fl(\".dropdown-menu\", t))\n    return !0;\n  const l = t.tagName === \"LABEL\" ? t : fl(\"label\", t);\n  if (l) {\n    const a = qa(l, \"for\"), o = a ? _s(a) : go(\"input, select, textarea\", l);\n    if (o && !o.disabled)\n      return !0;\n  }\n  return yo(t, mc);\n}, gc = [\"title\", \"abbr\", \"onClick\"], yc = { class: \"d-inline-flex flex-nowrap align-items-center gap-1\" }, bc = { key: 1 }, hc = [\"onClick\", \"onDblclick\", \"onMouseenter\", \"onMouseleave\"], Bc = {\n  key: 0,\n  class: \"b-table-stacked-label\"\n}, Sc = [\"colspan\"], wc = {\n  key: 0,\n  class: \"b-table-empty-slot\"\n}, _c = [\"colspan\"], $c = { key: 0 }, Cc = [\"title\", \"abbr\", \"onClick\"], kc = { key: 1 }, Tc = { key: 2 }, Vc = { key: 3 }, Nn = /* @__PURE__ */ N({\n  __name: \"BTableLite\",\n  props: {\n    align: { default: void 0 },\n    caption: { default: void 0 },\n    captionTop: { type: [String, Boolean], default: !1 },\n    borderless: { type: [String, Boolean], default: !1 },\n    bordered: { type: [String, Boolean], default: !1 },\n    borderVariant: { default: void 0 },\n    dark: { type: [String, Boolean], default: !1 },\n    fields: { default: () => [] },\n    footClone: { type: [String, Boolean], default: !1 },\n    hover: { type: [String, Boolean], default: !1 },\n    items: { default: () => [] },\n    responsive: { type: [Boolean, String], default: !1 },\n    small: { type: [String, Boolean], default: !1 },\n    striped: { type: [String, Boolean], default: !1 },\n    stacked: { type: [Boolean, String], default: !1 },\n    labelStacked: { type: Boolean, default: !1 },\n    variant: { default: void 0 },\n    stickyHeader: { type: [String, Boolean], default: !1 },\n    showEmpty: { type: [String, Boolean], default: !1 },\n    emptyText: { default: \"There are no records to show\" },\n    emptyFilteredText: { default: \"There are no records matching your request\" },\n    tableClasses: { default: void 0 },\n    fieldColumnClasses: { type: Function, default: void 0 },\n    tbodyTrClass: { type: Function, default: void 0 },\n    virtualFields: { default: 0 }\n  },\n  emits: [\"head-clicked\", \"row-clicked\", \"row-dbl-clicked\", \"row-hovered\", \"row-unhovered\"],\n  setup(e, { emit: t }) {\n    const l = e, a = d(() => l.footClone), o = d(() => l.labelStacked), n = d(() => l.showEmpty), s = u(() => ({\n      [`align-${l.align}`]: l.align !== void 0,\n      ...l.tableClasses\n    })), r = u(() => ({\n      bordered: l.bordered,\n      borderless: l.borderless,\n      borderVariant: l.borderVariant,\n      captionTop: l.captionTop,\n      dark: l.dark,\n      hover: l.hover,\n      responsive: l.responsive,\n      striped: l.striped,\n      stacked: l.stacked,\n      small: l.small,\n      tableClass: s.value,\n      tableVariant: l.variant,\n      stickyHeader: l.stickyHeader\n    })), i = u(() => h(l.fields, l.items)), v = u(() => i.value.length + l.virtualFields), b = (c) => typeof c == \"string\" ? ul(c) : c.label !== void 0 ? c.label : typeof c.key == \"string\" ? ul(c.key) : c.key, h = (c, V) => {\n      const F = [];\n      return !(c != null && c.length) && (V != null && V.length) ? (Object.keys(V[0]).forEach((f) => F.push({ key: f, label: il(f) })), F) : (Array.isArray(c) && c.forEach((f) => {\n        typeof f == \"string\" ? F.push({ key: f, label: il(f) }) : ba(f) && f.key && typeof f.key == \"string\" && F.push({ ...f });\n      }), F);\n    }, p = (c, V, F) => {\n      const f = c[V];\n      return F && typeof F == \"function\" ? F(f, V, c) : f;\n    }, B = (c, V) => p(c, V.key, V.formatter), S = (c, V, F = !1) => {\n      const f = typeof c == \"string\" ? c : c.key;\n      t(\"head-clicked\", f, c, V, F);\n    }, m = (c, V, F) => {\n      t(\"row-clicked\", c, V, F);\n    }, A = (c, V, F) => t(\"row-dbl-clicked\", c, V, F), y = (c, V, F) => t(\"row-hovered\", c, V, F), k = (c, V, F) => t(\"row-unhovered\", c, V, F), w = (c) => {\n      c._showDetails = !c._showDetails;\n    }, _ = (c) => [\n      c.class,\n      c.thClass,\n      {\n        [`table-${c.variant}`]: c.variant !== null,\n        \"b-table-sticky-column\": c.stickyColumn\n      },\n      ...l.fieldColumnClasses ? l.fieldColumnClasses(c) : []\n    ], C = (c, V) => [\n      c.class,\n      c.tdClass,\n      V != null && V._cellVariants && (V != null && V._cellVariants[c.key]) ? `table-${V == null ? void 0 : V._cellVariants[c.key]}` : void 0,\n      {\n        [`table-${c.variant}`]: c.variant !== null,\n        \"b-table-sticky-column\": c.stickyColumn\n      }\n    ], T = (c, V = \"row\") => {\n      const F = [\n        c._rowVariant ? `table-${c._rowVariant}` : null,\n        c._rowVariant ? `table-${c._rowVariant}` : null\n      ];\n      if (l.tbodyTrClass) {\n        const f = l.tbodyTrClass(c, V);\n        f && F.push(...typeof f == \"string\" ? [f] : f);\n      }\n      return F;\n    };\n    return (c, V) => (g(), M(rl, Be(Ve(r.value)), {\n      default: j(() => {\n        var F;\n        return [\n          K(\"thead\", null, [\n            c.$slots[\"thead-top\"] ? O(c.$slots, \"thead-top\", { key: 0 }) : J(\"\", !0),\n            K(\"tr\", null, [\n              O(c.$slots, \"thead-tr-prefix\"),\n              (g(!0), P(ce, null, he(i.value, (f) => (g(), P(\"th\", ee({\n                key: f.key,\n                scope: \"col\",\n                class: _(f),\n                title: f.headerTitle,\n                abbr: f.headerAbbr,\n                style: f.thStyle\n              }, f.thAttr, {\n                onClick: (I) => S(f, I)\n              }), [\n                K(\"div\", yc, [\n                  O(c.$slots, \"field-prefix\", { field: f }),\n                  K(\"div\", null, [\n                    c.$slots[\"head(\" + f.key + \")\"] || c.$slots[\"head()\"] ? O(c.$slots, c.$slots[\"head(\" + f.key + \")\"] ? \"head(\" + f.key + \")\" : \"head()\", {\n                      key: 0,\n                      label: f.label,\n                      column: f.key,\n                      field: f,\n                      isFoot: !1\n                    }) : (g(), P(ce, { key: 1 }, [\n                      ne(Y(b(f)), 1)\n                    ], 64))\n                  ])\n                ])\n              ], 16, gc))), 128))\n            ]),\n            c.$slots[\"thead-sub\"] ? (g(), P(\"tr\", bc, [\n              (g(!0), P(ce, null, he(i.value, (f) => (g(), P(\"td\", {\n                key: f.key,\n                scope: \"col\",\n                class: H([f.class, f.thClass, f.variant ? `table-${f.variant}` : \"\"])\n              }, [\n                c.$slots[\"thead-sub\"] ? O(c.$slots, \"thead-sub\", ee({\n                  key: 0,\n                  items: i.value\n                }, f)) : (g(), P(ce, { key: 1 }, [\n                  ne(Y(f.label), 1)\n                ], 64))\n              ], 2))), 128))\n            ])) : J(\"\", !0)\n          ]),\n          K(\"tbody\", null, [\n            (g(!0), P(ce, null, he(c.items, (f, I) => (g(), P(ce, { key: I }, [\n              K(\"tr\", {\n                class: H(T(f, \"row\")),\n                onClick: (E) => !$(Xt)(E) && m(f, I, E),\n                onDblclick: (E) => !$(Xt)(E) && A(f, I, E),\n                onMouseenter: (E) => !$(Xt)(E) && y(f, I, E),\n                onMouseleave: (E) => !$(Xt)(E) && k(f, I, E)\n              }, [\n                O(c.$slots, \"tbody-tr-prefix\", { item: f }),\n                (g(!0), P(ce, null, he(i.value, (E) => (g(), P(\"td\", ee({\n                  key: E.key\n                }, E.tdAttr, {\n                  class: C(E, f)\n                }), [\n                  c.stacked && $(o) ? (g(), P(\"label\", Bc, Y(b(E)), 1)) : J(\"\", !0),\n                  c.$slots[\"cell(\" + E.key + \")\"] || c.$slots[\"cell()\"] ? O(c.$slots, c.$slots[\"cell(\" + E.key + \")\"] ? \"cell(\" + E.key + \")\" : \"cell()\", {\n                    key: 1,\n                    value: f[E.key],\n                    index: I,\n                    item: f,\n                    field: E,\n                    items: c.items,\n                    toggleDetails: () => w(f),\n                    detailsShowing: f._showDetails\n                  }) : (g(), P(ce, { key: 2 }, [\n                    ne(Y(B(f, E)), 1)\n                  ], 64))\n                ], 16))), 128))\n              ], 42, hc),\n              f._showDetails === !0 && c.$slots[\"row-details\"] ? (g(), P(\"tr\", {\n                key: 0,\n                class: H(T(f, \"row-details\"))\n              }, [\n                K(\"td\", { colspan: v.value }, [\n                  O(c.$slots, \"row-details\", {\n                    item: f,\n                    toggleDetails: () => w(f)\n                  })\n                ], 8, Sc)\n              ], 2)) : J(\"\", !0)\n            ], 64))), 128)),\n            O(c.$slots, \"tbody-prefix\", { fieldsTotal: v.value }),\n            $(n) && c.items.length === 0 ? (g(), P(\"tr\", wc, [\n              K(\"td\", { colspan: v.value }, [\n                O(c.$slots, \"empty\", { items: c.items }, () => [\n                  ne(Y(c.emptyText), 1)\n                ])\n              ], 8, _c)\n            ])) : J(\"\", !0)\n          ]),\n          $(a) ? (g(), P(\"tfoot\", $c, [\n            K(\"tr\", null, [\n              (g(!0), P(ce, null, he(i.value, (f) => (g(), P(\"th\", ee({\n                key: f.key\n              }, f.thAttr, {\n                scope: \"col\",\n                class: [f.class, f.thClass, f.variant ? `table-${f.variant}` : \"\"],\n                title: f.headerTitle,\n                abbr: f.headerAbbr,\n                style: f.thStyle,\n                onClick: (I) => S(f, I, !0)\n              }), Y(f.label), 17, Cc))), 128))\n            ])\n          ])) : c.$slots[\"custom-foot\"] ? (g(), P(\"tfoot\", kc, [\n            O(c.$slots, \"custom-foot\", {\n              fields: i.value,\n              items: c.items,\n              columns: (F = i.value) == null ? void 0 : F.length\n            })\n          ])) : J(\"\", !0),\n          c.$slots[\"table-caption\"] ? (g(), P(\"caption\", Tc, [\n            O(c.$slots, \"table-caption\")\n          ])) : c.caption ? (g(), P(\"caption\", Vc, Y(c.caption), 1)) : J(\"\", !0)\n        ];\n      }),\n      _: 3\n    }, 16));\n  }\n}), Ac = [\"colspan\"], Oc = { class: \"d-flex align-items-center justify-content-center gap-2\" }, Fc = /* @__PURE__ */ K(\"strong\", null, \"Loading...\", -1), Pc = /* @__PURE__ */ N({\n  __name: \"BTable\",\n  props: {\n    align: { default: void 0 },\n    caption: { default: void 0 },\n    captionTop: { type: [String, Boolean], default: !1 },\n    borderless: { type: [String, Boolean], default: !1 },\n    bordered: { type: [String, Boolean], default: !1 },\n    borderVariant: { default: void 0 },\n    dark: { type: [String, Boolean], default: !1 },\n    fields: { default: () => [] },\n    footClone: { type: [String, Boolean], default: !1 },\n    hover: { type: [String, Boolean], default: !1 },\n    items: { default: () => [] },\n    provider: { type: Function, default: void 0 },\n    sortCompare: { type: Function, default: void 0 },\n    noProvider: { default: void 0 },\n    noProviderPaging: { type: [String, Boolean], default: !1 },\n    noProviderSorting: { type: [String, Boolean], default: !1 },\n    noProviderFiltering: { type: [String, Boolean], default: !1 },\n    responsive: { type: [Boolean, String], default: !1 },\n    small: { type: [String, Boolean], default: !1 },\n    striped: { type: [String, Boolean], default: !1 },\n    stacked: { type: [Boolean, String], default: !1 },\n    labelStacked: { type: Boolean, default: !1 },\n    variant: { default: void 0 },\n    sortBy: { default: void 0 },\n    sortDesc: { type: [String, Boolean], default: !1 },\n    sortInternal: { type: [String, Boolean], default: !0 },\n    selectable: { type: [String, Boolean], default: !1 },\n    stickySelect: { type: [String, Boolean], default: !1 },\n    selectHead: { type: [Boolean, String], default: !0 },\n    selectMode: { default: \"single\" },\n    selectionVariant: { default: \"primary\" },\n    stickyHeader: { type: [String, Boolean], default: !1 },\n    busy: { type: [String, Boolean], default: !1 },\n    showEmpty: { type: [String, Boolean], default: !1 },\n    perPage: { default: void 0 },\n    currentPage: { default: 1 },\n    filter: { default: void 0 },\n    filterable: { default: void 0 },\n    emptyText: { default: \"There are no records to show\" },\n    emptyFilteredText: { default: \"There are no records matching your request\" },\n    fieldColumnClasses: { type: Function, default: void 0 },\n    tbodyTrClass: { type: Function, default: void 0 }\n  },\n  emits: [\"head-clicked\", \"row-clicked\", \"row-dbl-clicked\", \"row-hovered\", \"row-unhovered\", \"row-selected\", \"row-unselected\", \"selection\", \"update:busy\", \"update:sortBy\", \"update:sortDesc\", \"sorted\", \"filtered\"],\n  setup(e, { expose: t, emit: l }) {\n    const a = e, o = Se(a, \"sortBy\", l, { passive: !0 }), n = Se(a, \"busy\", l, { passive: !0 }), s = Se(a, \"sortDesc\", l, { passive: !0 }), r = Fe(), i = R(null), v = d(s), b = d(() => a.sortInternal), h = d(n), p = d(() => a.noProviderPaging), B = d(() => a.noProviderSorting), S = d(() => a.noProviderFiltering), m = d(() => a.selectable), A = d(() => a.stickySelect), y = u(() => a.filter !== void 0 && a.filter !== \"\"), k = R(/* @__PURE__ */ new Set([])), w = u(() => k.value.size > 0), _ = u(() => a.fields.filter((D) => typeof D == \"string\" ? !1 : D.sortable).length > 0 || a.sortBy !== void 0), C = u(() => a.provider !== void 0), T = u(() => ({\n      \"b-table-sortable\": _.value,\n      \"b-table-sort-desc\": _.value && v.value === !0,\n      \"b-table-sort-asc\": _.value && v.value === !1,\n      \"b-table-busy\": h.value,\n      \"b-table-selectable\": m.value,\n      [`b-table-select-${a.selectMode}`]: m.value,\n      \"b-table-selecting user-select-none\": m.value && w.value\n    })), c = u(() => _.value && b.value === !0), V = u(\n      () => m.value && (!!a.selectHead || r.selectHead !== void 0)\n    ), {\n      computedItems: F,\n      computedDisplayItems: f,\n      updateInternalItems: I,\n      filteredHandler: E,\n      notifyFilteredItems: z\n    } = Zr(\n      a,\n      {\n        sortInternalBoolean: b,\n        isFilterableTable: y,\n        noProviderPagingBoolean: p,\n        isSortable: _,\n        requireItemsMapping: c,\n        sortDescBoolean: v\n      },\n      C,\n      o\n    );\n    E.value = async (x) => {\n      if (C.value) {\n        await W();\n        return;\n      }\n      l(\"filtered\", x);\n    };\n    const Z = (x, D, ae) => {\n      me(x, D, ae.shiftKey, ae.ctrlKey, ae.metaKey), l(\"row-clicked\", x, D, ae);\n    }, te = (x, D, ae, ue = !1) => {\n      l(\"head-clicked\", x, D, ae, ue), G(D);\n    }, G = (x) => {\n      if (!_.value)\n        return;\n      const D = typeof x == \"string\" ? x : x.key, ae = typeof x == \"string\" ? !1 : x.sortable;\n      if (_.value === !0 && ae === !0) {\n        const ue = !v.value;\n        o.value = D, s.value = ue, l(\"sorted\", D, ue);\n      }\n    }, W = async () => {\n      if (!C.value || !a.provider || h.value)\n        return;\n      n.value = !0;\n      const x = new Proxy(\n        {\n          currentPage: a.currentPage,\n          filter: a.filter,\n          sortBy: a.sortBy,\n          sortDesc: a.sortDesc,\n          perPage: a.perPage\n        },\n        {\n          get: (ae, ue) => ue in ae ? ae[ue] : void 0,\n          set: () => (console.error(\"BTable provider context is a read-only object.\"), !0)\n        }\n      ), D = a.provider(x, I);\n      if (D !== void 0) {\n        if (D instanceof Promise)\n          try {\n            const ae = await D;\n            return Array.isArray(ae) ? await I(ae) : void 0;\n          } finally {\n            h.value && (n.value = !1);\n          }\n        try {\n          return await I(D);\n        } finally {\n          h.value && (n.value = !1);\n        }\n      }\n    }, X = (x) => [\n      {\n        \"b-table-sortable-column\": _.value && x.sortable\n      }\n    ], ve = (x, D) => {\n      const ae = [\n        m.value && x && k.value.has(x) ? `selected table-${a.selectionVariant}` : null\n      ];\n      if (a.tbodyTrClass) {\n        const ue = a.tbodyTrClass(x, D);\n        ue && ae.push(...typeof ue == \"string\" ? [ue] : ue);\n      }\n      return ae;\n    }, ge = () => {\n      const x = [{ \"b-table-static-busy\": a.items.length === 0 }];\n      if (a.tbodyTrClass) {\n        const D = a.tbodyTrClass(null, \"table-busy\");\n        D && x.push(...typeof D == \"string\" ? [D] : D);\n      }\n      return x;\n    }, pe = () => {\n      m.value && l(\"selection\", Array.from(k.value));\n    }, me = (x, D, ae = !1, ue = !1, U = !1) => {\n      if (m.value) {\n        if (ae && a.selectMode === \"range\" && k.value.size > 0) {\n          const se = Array.from(k.value).pop(), Ie = a.items.findIndex((ut) => ut === se), et = Math.min(Ie, D), tt = Math.max(Ie, D);\n          a.items.slice(et, tt + 1).forEach((ut) => {\n            k.value.has(ut) || (k.value.add(ut), l(\"row-selected\", ut));\n          });\n        } else\n          ue || U ? k.value.has(x) ? (k.value.delete(x), l(\"row-unselected\", x)) : a.selectMode === \"range\" || a.selectMode === \"multi\" ? (k.value.add(x), l(\"row-selected\", x)) : (k.value.forEach((se) => l(\"row-unselected\", se)), k.value.clear(), k.value.add(x), l(\"row-selected\", x)) : (k.value.forEach((se) => l(\"row-unselected\", se)), k.value.clear(), k.value.add(x), l(\"row-selected\", x));\n        pe();\n      }\n    }, q = () => {\n      if (!m.value)\n        return;\n      const x = k.value.size > 0 ? Array.from(k.value) : [];\n      k.value = /* @__PURE__ */ new Set([...a.items]), k.value.forEach((D) => {\n        x.includes(D) || l(\"row-selected\", D);\n      }), pe();\n    }, Q = () => {\n      m.value && (k.value.forEach((x) => {\n        l(\"row-unselected\", x);\n      }), k.value = /* @__PURE__ */ new Set([]), pe());\n    }, re = (x) => {\n      if (!m.value)\n        return;\n      const D = a.items[x];\n      !D || k.value.has(D) || (k.value.add(D), l(\"row-selected\", D), pe());\n    }, de = (x) => {\n      if (!m.value)\n        return;\n      const D = a.items[x];\n      !D || !k.value.has(D) || (k.value.delete(D), l(\"row-unselected\", D), pe());\n    }, L = async (x, D, ae) => {\n      if (D === ae)\n        return;\n      const ue = (tt) => a.noProvider && a.noProvider.includes(tt), U = ![\"currentPage\", \"perPage\"].includes(x), se = [\"currentPage\", \"perPage\"].includes(x) && (ue(\"paging\") || p.value === !0), Ie = [\"filter\"].includes(x) && (ue(\"filtering\") || S.value === !0), et = [\"sortBy\", \"sortDesc\"].includes(x) && (ue(\"sorting\") || B.value === !0);\n      se || Ie || et || (await W(), U && z());\n    };\n    return oe(\n      () => a.filter,\n      (x, D) => {\n        x === D || C.value || x || l(\"filtered\", F.value);\n      }\n    ), oe(\n      () => a.filter,\n      (x, D) => L(\"filter\", x, D)\n    ), oe(\n      () => a.currentPage,\n      (x, D) => L(\"currentPage\", x, D)\n    ), oe(\n      () => a.perPage,\n      (x, D) => L(\"perPage\", x, D)\n    ), oe(\n      () => a.sortBy,\n      (x, D) => L(\"sortBy\", x, D)\n    ), oe(\n      () => a.sortDesc,\n      (x, D) => L(\"sortDesc\", x, D)\n    ), He(W), t({\n      selectAllRows: q,\n      clearSelected: Q,\n      selectRow: re,\n      unselectRow: de,\n      refresh: W\n    }), (x, D) => (g(), M(Nn, ee({\n      ref_key: \"liteTable\",\n      ref: i\n    }, a, {\n      busy: $(n),\n      \"onUpdate:busy\": D[0] || (D[0] = (ae) => La(n) ? n.value = ae : null),\n      items: $(f),\n      \"table-classes\": T.value,\n      \"tbody-tr-class\": ve,\n      \"field-column-classes\": X,\n      \"virtual-fields\": $(m) ? 1 : 0\n    }, io(x.$attrs), {\n      onHeadClicked: te,\n      onRowClicked: Z\n    }), Ha({\n      \"field-prefix\": j((ae) => [\n        O(x.$slots, \"sort-icon\", {\n          field: ae.field,\n          sortBy: $(o),\n          selected: ae.field.key === $(o),\n          isDesc: $(v),\n          direction: $(v) ? \"desc\" : \"asc\"\n        }, () => [\n          _.value && ae.field.sortable ? (g(), P(\"span\", {\n            key: 0,\n            class: H([\"b-table-sort-icon\", {\n              sorted: ae.field.key === $(o),\n              [`sorted-${$(v) ? \"desc\" : \"asc\"}`]: ae.field.key === $(o)\n            }])\n          }, null, 2)) : J(\"\", !0)\n        ])\n      ]),\n      \"thead-tr-prefix\": j(() => [\n        V.value ? (g(), P(\"th\", {\n          key: 0,\n          class: H([\"b-table-selection-column\", {\n            \"b-table-sticky-column\": $(A)\n          }])\n        }, [\n          O(x.$slots, \"select-head\", {}, () => [\n            ne(Y(typeof x.selectHead == \"boolean\" ? \"Selected\" : x.selectHead), 1)\n          ])\n        ], 2)) : J(\"\", !0)\n      ]),\n      \"tbody-tr-prefix\": j((ae) => [\n        V.value ? (g(), P(\"td\", {\n          key: 0,\n          class: H([\"b-table-selection-column\", {\n            \"b-table-sticky-column\": $(A)\n          }])\n        }, [\n          O(x.$slots, \"select-cell\", {}, () => [\n            K(\"span\", {\n              class: H([\"b-table-selection-icon\", k.value.has(ae.item) ? `text-${a.selectionVariant} selected` : \"\"])\n            }, \"ð¹\", 2)\n          ])\n        ], 2)) : J(\"\", !0)\n      ]),\n      \"tbody-prefix\": j((ae) => [\n        $(h) ? (g(), P(\"tr\", {\n          key: 0,\n          class: H([\"b-table-busy-slot\", ge()])\n        }, [\n          K(\"td\", {\n            colspan: ae.fieldsTotal\n          }, [\n            O(x.$slots, \"table-busy\", {}, () => [\n              K(\"div\", Oc, [\n                be(pa, { class: \"align-middle\" }),\n                Fc\n              ])\n            ])\n          ], 8, Ac)\n        ], 2)) : J(\"\", !0)\n      ]),\n      _: 2\n    }, [\n      he(x.$slots, (ae, ue) => ({\n        name: ue,\n        fn: j((U) => [\n          O(x.$slots, ue, Be(Ve(U)))\n        ])\n      }))\n    ]), 1040, [\"busy\", \"items\", \"table-classes\", \"virtual-fields\"]));\n  }\n}), Ec = /* @__PURE__ */ N({\n  __name: \"BTbody\",\n  props: {\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`thead-${t.variant}`]: t.variant !== null\n    }));\n    return (a, o) => (g(), P(\"tbody\", {\n      class: H(l.value)\n    }, [\n      O(a.$slots, \"default\")\n    ], 2));\n  }\n}), Ic = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"], xc = { key: 0 }, Lc = /* @__PURE__ */ N({\n  __name: \"BTd\",\n  props: {\n    colspan: { default: void 0 },\n    rowspan: { default: void 0 },\n    stackedHeading: { default: void 0 },\n    stickyColumn: { type: [String, Boolean], default: !1 },\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.stickyColumn), a = u(() => ({\n      [`table-${t.variant}`]: t.variant !== null,\n      \"b-table-sticky-column\": l.value,\n      \"table-b-table-default\": l.value && t.variant === null\n    })), o = u(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n    return (n, s) => (g(), P(\"td\", {\n      scope: o.value,\n      class: H(a.value),\n      colspan: n.colspan,\n      rowspan: n.rowspan,\n      \"data-label\": n.stackedHeading\n    }, [\n      n.stackedHeading ? (g(), P(\"div\", xc, [\n        O(n.$slots, \"default\")\n      ])) : O(n.$slots, \"default\", { key: 1 })\n    ], 10, Ic));\n  }\n}), Nc = /* @__PURE__ */ N({\n  __name: \"BTfoot\",\n  props: {\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`table-${t.variant}`]: t.variant !== null\n    }));\n    return (a, o) => (g(), P(\"tfoot\", {\n      class: H(l.value)\n    }, [\n      O(a.$slots, \"default\")\n    ], 2));\n  }\n}), zc = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"], Hc = { key: 0 }, Rc = /* @__PURE__ */ N({\n  __name: \"BTh\",\n  props: {\n    colspan: { default: void 0 },\n    rowspan: { default: void 0 },\n    stackedHeading: { default: void 0 },\n    stickyColumn: { type: [String, Boolean], default: !1 },\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = d(() => t.stickyColumn), a = u(() => ({\n      [`table-${t.variant}`]: t.variant !== null,\n      \"b-table-sticky-column\": l.value,\n      \"table-b-table-default\": l.value && t.variant === null\n    })), o = u(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n    return (n, s) => (g(), P(\"th\", {\n      scope: o.value,\n      class: H(a.value),\n      colspan: n.colspan,\n      rowspan: n.rowspan,\n      \"data-label\": n.stackedHeading\n    }, [\n      n.stackedHeading !== void 0 ? (g(), P(\"div\", Hc, [\n        O(n.$slots, \"default\")\n      ])) : O(n.$slots, \"default\", { key: 1 })\n    ], 10, zc));\n  }\n}), Mc = /* @__PURE__ */ N({\n  __name: \"BThead\",\n  props: {\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`table-${t.variant}`]: t.variant !== null\n    }));\n    return (a, o) => (g(), P(\"thead\", {\n      class: H(l.value)\n    }, [\n      O(a.$slots, \"default\")\n    ], 2));\n  }\n}), Dc = /* @__PURE__ */ N({\n  __name: \"BTr\",\n  props: {\n    variant: { default: null }\n  },\n  setup(e) {\n    const t = e, l = u(() => ({\n      [`table-${t.variant}`]: t.variant !== null\n    }));\n    return (a, o) => (g(), P(\"tr\", {\n      class: H(l.value)\n    }, [\n      O(a.$slots, \"default\")\n    ], 2));\n  }\n}), jc = /* @__PURE__ */ N({\n  __name: \"BTab\",\n  props: {\n    id: { default: void 0 },\n    title: { default: void 0 },\n    active: { type: [String, Boolean], default: !1 },\n    buttonId: { default: void 0 },\n    disabled: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: void 0 },\n    lazyOnce: { type: [String, Boolean], default: void 0 },\n    noBody: { type: [Boolean, String], default: !1 },\n    tag: { default: \"div\" },\n    titleItemClass: { default: void 0 },\n    titleLinkAttributes: { default: void 0 },\n    titleLinkClass: { default: void 0 }\n  },\n  setup(e) {\n    const t = e, l = Oe(Bo, null), a = d(() => t.active), o = d(() => t.disabled), n = d(\n      u(() => t.lazyOnce !== void 0 ? t.lazyOnce : t.lazy)\n    ), s = R(!1), r = u(() => !!(l != null && l.lazy.value || n.value)), i = u(() => t.lazyOnce !== void 0), v = u(() => a.value && !o.value), b = u(() => {\n      const B = r.value && i.value && s.value;\n      return v.value || !r.value || B;\n    }), h = R(a.value);\n    oe(a, (B) => {\n      setTimeout(() => {\n        h.value = B;\n      }, 0);\n    });\n    const p = u(() => ({\n      active: a.value,\n      show: h.value,\n      \"card-body\": (l == null ? void 0 : l.card.value) && t.noBody === !1\n    }));\n    return oe(b, (B) => {\n      B && !s.value && (s.value = !0);\n    }), (B, S) => (g(), M(le(B.tag), {\n      id: B.id,\n      class: H([\"tab-pane\", p.value]),\n      role: \"tabpanel\",\n      \"aria-labelledby\": \"profile-tab\"\n    }, {\n      default: j(() => [\n        b.value ? O(B.$slots, \"default\", { key: 0 }) : J(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"id\", \"class\"]));\n  }\n}), qc = [\"id\", \"data-bs-target\", \"aria-controls\", \"aria-selected\", \"onClick\"], Gc = /* @__PURE__ */ N({\n  __name: \"BTabs\",\n  props: {\n    activeNavItemClass: { default: void 0 },\n    activeTabClass: { default: void 0 },\n    align: { default: void 0 },\n    contentClass: { default: void 0 },\n    card: { type: [String, Boolean], default: !1 },\n    end: { type: [String, Boolean], default: !1 },\n    fill: { type: [String, Boolean], default: !1 },\n    id: { default: void 0 },\n    justified: { type: [String, Boolean], default: !1 },\n    lazy: { type: [String, Boolean], default: !1 },\n    navClass: { default: void 0 },\n    navWrapperClass: { default: void 0 },\n    noFade: { type: [String, Boolean], default: !1 },\n    noNavStyle: { type: [String, Boolean], default: !1 },\n    pills: { type: [String, Boolean], default: !1 },\n    small: { type: [String, Boolean], default: !1 },\n    tag: { default: \"div\" },\n    vertical: { type: [String, Boolean], default: !1 },\n    modelValue: { default: -1 }\n  },\n  emits: [\"update:modelValue\", \"activate-tab\", \"click\"],\n  setup(e, { emit: t }) {\n    const l = e, a = Se(l, \"modelValue\", t), o = Fe(), n = d(() => l.card), s = d(() => l.end), r = d(() => l.fill), i = d(() => l.justified), v = d(() => l.lazy), b = d(() => l.noFade), h = d(() => l.noNavStyle), p = d(() => l.pills), B = d(() => l.small), S = d(() => l.vertical), m = R(a.value), A = R(\"\"), y = u({\n      get: () => m.value,\n      set: (f) => {\n        m.value = f, w.value.length > 0 && f >= 0 && f < w.value.length ? A.value = w.value[f].buttonId : A.value = \"\", a.value = f;\n      }\n    }), k = R([]);\n    oe(\n      () => {\n        var f;\n        return (f = o.default) == null ? void 0 : f.call(o);\n      },\n      () => {\n        k.value = o.default === void 0 ? [] : Ba(o.default, \"BTab\").map((f, I) => {\n          f.props || (f.props = {});\n          const E = f.props[\"button-id\"] || at(\"tab\"), z = f.props.id || at(), Z = f.props[\"title-item-class\"], te = f.props[\"title-link-attributes\"];\n          return {\n            buttonId: E,\n            contentId: z,\n            disabled: f.props.disabled === \"\" || f.props.disabled === !0,\n            target: `#${z}`,\n            title: f.props.title,\n            titleItemClass: Z,\n            titleLinkAttributes: te,\n            onClick: f.props.onClick,\n            tab: f,\n            tabComponent: () => Ba(o.default, \"BTab\")[I]\n          };\n        });\n      },\n      { immediate: !0 }\n    );\n    const w = u(\n      () => k.value.map((f, I) => {\n        const { tab: E } = f;\n        E.props || (E.props = {});\n        const z = y.value > -1 ? I === y.value : E.props.active === \"\";\n        return {\n          ...f,\n          active: z,\n          navItemClasses: [\n            {\n              active: z,\n              disabled: E.props.disabled === \"\" || E.props.disabled === !0\n            },\n            z && l.activeNavItemClass ? l.activeNavItemClass : null,\n            E.props[\"title-link-class\"]\n          ],\n          tabClasses: [\n            {\n              fade: !b.value\n            },\n            z && l.activeTabClass ? l.activeTabClass : null\n          ]\n        };\n      })\n    ), _ = u(() => !(w != null && w.value && w.value.length > 0)), C = u(() => ({\n      \"d-flex\": S.value,\n      \"align-items-start\": S.value\n    })), T = Dt(() => l.align), c = u(() => ({\n      \"nav-pills\": p.value,\n      \"flex-column me-3\": S.value,\n      [T.value]: l.align !== void 0,\n      \"nav-fill\": r.value,\n      \"card-header-tabs\": n.value,\n      \"nav-justified\": i.value,\n      \"nav-tabs\": !h.value && !p.value,\n      small: B.value\n    })), V = (f) => {\n      let I = !1;\n      if (f !== void 0 && f > -1 && f < w.value.length && !w.value[f].disabled && (y.value < 0 || w.value[f].buttonId !== A.value)) {\n        const E = new Ge(\"activate-tab\", { cancelable: !0 });\n        t(\"activate-tab\", f, y.value, E), E.defaultPrevented || (y.value = f, I = !0);\n      }\n      return !I && a.value !== y.value && (a.value = y.value), I;\n    }, F = (f, I) => {\n      var E;\n      V(I), I >= 0 && !w.value[I].disabled && ((E = w.value[I]) != null && E.onClick) && typeof w.value[I].onClick == \"function\" && w.value[I].onClick(f);\n    };\n    return V(m.value), oe(a, (f, I) => {\n      if (f === I)\n        return;\n      if (f = Math.max(f, -1), I = Math.max(I, -1), w.value.length <= 0) {\n        y.value = -1;\n        return;\n      }\n      const E = f > I;\n      let z = f;\n      const Z = w.value.length - 1;\n      for (; z >= 0 && z <= Z && w.value[z].disabled; )\n        z += E ? 1 : -1;\n      if (z < 0) {\n        V(0);\n        return;\n      }\n      if (z >= w.value.length) {\n        V(w.value.length - 1);\n        return;\n      }\n      V(z);\n    }), oe(w, () => {\n      let f = w.value.map((I) => I.active && !I.disabled).lastIndexOf(!0);\n      f < 0 && (y.value >= w.value.length ? f = w.value.map((I) => !I.disabled).lastIndexOf(!0) : w.value[y.value] && !w.value[y.value].disabled && (f = y.value)), f < 0 && (f = w.value.map((I) => !I.disabled).indexOf(!0)), w.value.forEach((I, E) => {\n        I.active = E === f;\n      }), V(f);\n    }), He(() => {\n      if (y.value < 0 && w.value.length > 0 && !w.value.some((f) => f.active)) {\n        const f = w.value.map((I) => !I.disabled).indexOf(!0);\n        V(f >= 0 ? f : -1);\n      }\n    }), De(Bo, {\n      lazy: v,\n      card: n\n    }), (f, I) => (g(), M(le(f.tag), {\n      id: f.id,\n      class: H([\"tabs\", C.value])\n    }, {\n      default: j(() => [\n        $(s) ? (g(), P(\"div\", {\n          key: 0,\n          class: H([\"tab-content\", f.contentClass])\n        }, [\n          (g(!0), P(ce, null, he(w.value, ({ tabComponent: E, contentId: z, tabClasses: Z, active: te }, G) => (g(), M(le(E()), {\n            id: z,\n            key: G,\n            class: H(Z),\n            active: te\n          }, null, 8, [\"id\", \"class\", \"active\"]))), 128)),\n          _.value ? (g(), P(\"div\", {\n            key: \"bv-empty-tab\",\n            class: H([\"tab-pane active\", { \"card-body\": $(n) }])\n          }, [\n            O(f.$slots, \"empty\")\n          ], 2)) : J(\"\", !0)\n        ], 2)) : J(\"\", !0),\n        K(\"div\", {\n          class: H([f.navWrapperClass, { \"card-header\": $(n), \"ms-auto\": f.vertical && $(s) }])\n        }, [\n          K(\"ul\", {\n            class: H([\"nav\", [c.value, f.navClass]]),\n            role: \"tablist\"\n          }, [\n            O(f.$slots, \"tabs-start\"),\n            (g(!0), P(ce, null, he(w.value, ({ tab: E, buttonId: z, contentId: Z, navItemClasses: te, active: G, target: W }, X) => {\n              var ve, ge, pe;\n              return g(), P(\"li\", {\n                key: X,\n                class: H([\"nav-item\", (ve = E == null ? void 0 : E.props) == null ? void 0 : ve[\"title-item-class\"]]),\n                role: \"presentation\"\n              }, [\n                K(\"button\", ee({\n                  id: z,\n                  class: [\"nav-link\", te],\n                  \"data-bs-toggle\": \"tab\",\n                  \"data-bs-target\": W,\n                  role: \"tab\",\n                  \"aria-controls\": Z,\n                  \"aria-selected\": G\n                }, (ge = E == null ? void 0 : E.props) == null ? void 0 : ge[\"title-link-attributes\"], {\n                  onClick: ot((me) => F(me, X), [\"stop\", \"prevent\"])\n                }), [\n                  E.children && E.children.title ? (g(), M(le(E.children.title), { key: 0 })) : (g(), P(ce, { key: 1 }, [\n                    ne(Y((pe = E == null ? void 0 : E.props) == null ? void 0 : pe.title), 1)\n                  ], 64))\n                ], 16, qc)\n              ], 2);\n            }), 128)),\n            O(f.$slots, \"tabs-end\")\n          ], 2)\n        ], 2),\n        $(s) ? J(\"\", !0) : (g(), P(\"div\", {\n          key: 1,\n          class: H([\"tab-content\", f.contentClass])\n        }, [\n          (g(!0), P(ce, null, he(w.value, ({ tabComponent: E, contentId: z, tabClasses: Z, active: te }, G) => (g(), M(le(E()), {\n            id: z,\n            key: G,\n            class: H(Z),\n            active: te\n          }, null, 8, [\"id\", \"class\", \"active\"]))), 128)),\n          _.value ? (g(), P(\"div\", {\n            key: \"bv-empty-tab\",\n            class: H([\"tab-pane active\", { \"card-body\": $(n) }])\n          }, [\n            O(f.$slots, \"empty\")\n          ], 2)) : J(\"\", !0)\n        ], 2))\n      ]),\n      _: 3\n    }, 8, [\"id\", \"class\"]));\n  }\n}), Wc = /* @__PURE__ */ N({\n  __name: \"BTooltip\",\n  setup(e, { expose: t }) {\n    var a, o, n;\n    const l = R(null);\n    return t({\n      hide: (a = l.value) == null ? void 0 : a.hideFn,\n      show: (o = l.value) == null ? void 0 : o.show,\n      toggle: (n = l.value) == null ? void 0 : n.toggle\n    }), (s, r) => (g(), M(tl, {\n      ref_key: \"popover\",\n      ref: l,\n      tooltip: \"\"\n    }, Ha({ _: 2 }, [\n      he(s.$slots, (i, v) => ({\n        name: v,\n        fn: j((b) => [\n          O(s.$slots, v, Be(Ve(b)))\n        ])\n      }))\n    ]), 1536));\n  }\n}), lo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  BAccordion: ni,\n  BAccordionItem: ui,\n  BAlert: pi,\n  BAvatar: bi,\n  BAvatarGroup: hi,\n  BBadge: Bi,\n  BBreadcrumb: _i,\n  BBreadcrumbItem: sn,\n  BButton: kt,\n  BButtonGroup: $i,\n  BButtonToolbar: ki,\n  BCard: pn,\n  BCardBody: fn,\n  BCardFooter: vn,\n  BCardGroup: Ai,\n  BCardHeader: un,\n  BCardImg: ra,\n  BCardSubtitle: cn,\n  BCardText: Oi,\n  BCardTitle: dn,\n  BCarousel: zi,\n  BCarouselSlide: ji,\n  BCloseButton: Ot,\n  BCol: Pt,\n  BCollapse: nn,\n  BContainer: Yi,\n  BDropdown: hn,\n  BDropdownDivider: eu,\n  BDropdownForm: lu,\n  BDropdownGroup: su,\n  BDropdownHeader: iu,\n  BDropdownItem: uu,\n  BDropdownItemButton: cu,\n  BDropdownText: pu,\n  BForm: Bn,\n  BFormCheckbox: Sn,\n  BFormCheckboxGroup: $u,\n  BFormFile: Tu,\n  BFormFloatingLabel: bu,\n  BFormGroup: xu,\n  BFormInput: Nu,\n  BFormInvalidFeedback: Aa,\n  BFormRadio: _n,\n  BFormRadioGroup: ju,\n  BFormRow: Jt,\n  BFormSelect: Uu,\n  BFormSelectOption: ol,\n  BFormSelectOptionGroup: $n,\n  BFormSpinButton: Zu,\n  BFormTag: An,\n  BFormTags: vd,\n  BFormText: Oa,\n  BFormTextarea: md,\n  BFormValidFeedback: Fa,\n  BImg: al,\n  BInputGroup: wd,\n  BInputGroupAddon: nl,\n  BInputGroupAppend: _d,\n  BInputGroupPrepend: $d,\n  BInputGroupText: On,\n  BLink: Xe,\n  BListGroup: Cd,\n  BListGroupItem: kd,\n  BModal: Od,\n  BNav: Fd,\n  BNavForm: Pd,\n  BNavItem: Id,\n  BNavItemDropdown: Ld,\n  BNavText: zd,\n  BNavbar: Hd,\n  BNavbarBrand: Rd,\n  BNavbarNav: Md,\n  BNavbarToggle: Ud,\n  BOffcanvas: Yd,\n  BOverlay: Pn,\n  BPagination: nc,\n  BPlaceholder: Le,\n  BPlaceholderButton: xn,\n  BPlaceholderCard: sc,\n  BPlaceholderTable: rc,\n  BPlaceholderWrapper: ic,\n  BPopover: tl,\n  BProgress: dc,\n  BProgressBar: Ln,\n  BRow: vc,\n  BSpinner: pa,\n  BTab: jc,\n  BTable: Pc,\n  BTableLite: Nn,\n  BTableSimple: rl,\n  BTabs: Gc,\n  BTbody: Ec,\n  BTd: Lc,\n  BTfoot: Nc,\n  BTh: Rc,\n  BThead: Mc,\n  BToast: bn,\n  BToastContainer: Va,\n  BToastPlugin: yn,\n  BToaster: Va,\n  BTooltip: Wc,\n  BTr: Dc,\n  BTransition: At\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst Kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  useBreadcrumb: Ko,\n  useColorMode: Gr\n}, Symbol.toStringTag, { value: \"Module\" })), Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  BvCarouselEvent: uo,\n  BvEvent: Ge,\n  BvTriggerableEvent: Rt\n}, Symbol.toStringTag, { value: \"Module\" })), Jc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null\n}, Symbol.toStringTag, { value: \"Module\" })), Zc = {\n  install(e, t = { components: !0, directives: !0 }) {\n    const l = typeof t.components == \"boolean\" || typeof t.components > \"u\" ? { all: !0 } : t.components, a = Object.keys(lo);\n    Ll(l, a).forEach((s) => {\n      const r = lo[s];\n      e.component(s, r);\n    });\n    const o = typeof (t == null ? void 0 : t.directives) == \"boolean\" || typeof t.directives > \"u\" ? { all: !0 } : t == null ? void 0 : t.directives, n = Object.keys(Ql);\n    Ll(o, n).forEach((s) => {\n      const r = s.toLowerCase().startsWith(\"v\") ? s.slice(1) : s, i = Ql[s];\n      e.directive(r, i);\n    }), t != null && t.BToast && e.use(yn, t);\n  }\n};\nexport {\n  ni as BAccordion,\n  ui as BAccordionItem,\n  pi as BAlert,\n  bi as BAvatar,\n  hi as BAvatarGroup,\n  Bi as BBadge,\n  _i as BBreadcrumb,\n  sn as BBreadcrumbItem,\n  kt as BButton,\n  $i as BButtonGroup,\n  ki as BButtonToolbar,\n  pn as BCard,\n  fn as BCardBody,\n  vn as BCardFooter,\n  Ai as BCardGroup,\n  un as BCardHeader,\n  ra as BCardImg,\n  cn as BCardSubtitle,\n  Oi as BCardText,\n  dn as BCardTitle,\n  zi as BCarousel,\n  ji as BCarouselSlide,\n  Ot as BCloseButton,\n  Pt as BCol,\n  nn as BCollapse,\n  Yi as BContainer,\n  hn as BDropdown,\n  eu as BDropdownDivider,\n  lu as BDropdownForm,\n  su as BDropdownGroup,\n  iu as BDropdownHeader,\n  uu as BDropdownItem,\n  cu as BDropdownItemButton,\n  pu as BDropdownText,\n  Bn as BForm,\n  Sn as BFormCheckbox,\n  $u as BFormCheckboxGroup,\n  Tu as BFormFile,\n  bu as BFormFloatingLabel,\n  xu as BFormGroup,\n  Nu as BFormInput,\n  Aa as BFormInvalidFeedback,\n  _n as BFormRadio,\n  ju as BFormRadioGroup,\n  Jt as BFormRow,\n  Uu as BFormSelect,\n  ol as BFormSelectOption,\n  $n as BFormSelectOptionGroup,\n  Zu as BFormSpinButton,\n  An as BFormTag,\n  vd as BFormTags,\n  Oa as BFormText,\n  md as BFormTextarea,\n  Fa as BFormValidFeedback,\n  al as BImg,\n  wd as BInputGroup,\n  nl as BInputGroupAddon,\n  _d as BInputGroupAppend,\n  $d as BInputGroupPrepend,\n  On as BInputGroupText,\n  Xe as BLink,\n  Cd as BListGroup,\n  kd as BListGroupItem,\n  Od as BModal,\n  Fd as BNav,\n  Pd as BNavForm,\n  Id as BNavItem,\n  Ld as BNavItemDropdown,\n  zd as BNavText,\n  Hd as BNavbar,\n  Rd as BNavbarBrand,\n  Md as BNavbarNav,\n  Ud as BNavbarToggle,\n  Yd as BOffcanvas,\n  Pn as BOverlay,\n  nc as BPagination,\n  Le as BPlaceholder,\n  xn as BPlaceholderButton,\n  sc as BPlaceholderCard,\n  rc as BPlaceholderTable,\n  ic as BPlaceholderWrapper,\n  tl as BPopover,\n  dc as BProgress,\n  Ln as BProgressBar,\n  vc as BRow,\n  pa as BSpinner,\n  jc as BTab,\n  Pc as BTable,\n  Nn as BTableLite,\n  rl as BTableSimple,\n  Gc as BTabs,\n  Ec as BTbody,\n  Lc as BTd,\n  Nc as BTfoot,\n  Rc as BTh,\n  Mc as BThead,\n  bn as BToast,\n  Va as BToastContainer,\n  yn as BToastPlugin,\n  Va as BToaster,\n  Wc as BTooltip,\n  Dc as BTr,\n  At as BTransition,\n  Zc as BootstrapVueNext,\n  uo as BvCarouselEvent,\n  Ge as BvEvent,\n  Rt as BvTriggerableEvent,\n  lo as Components,\n  Kc as Composables,\n  Ql as Directives,\n  Jc as Types,\n  Yc as Utils,\n  Zc as default,\n  Ko as useBreadcrumb,\n  Gr as useColorMode,\n  gn as useToast,\n  Dd as vBColorMode,\n  Ia as vBModal,\n  qd as vBPopover,\n  Ia as vBToggle,\n  Gd as vBTooltip\n};\n//# sourceMappingURL=bootstrap-vue-next.mjs.map\n",
      "start": 1709123921787,
      "end": 1709123925038,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1709123925038,
      "end": 1709123925038,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1709123925038,
      "end": 1709123925038,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1709123925038,
      "end": 1709123925038,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1709123925038,
      "end": 1709123925038,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1709123925038,
      "end": 1709123925038,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1709123925038,
      "end": 1709123925038,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1709123925038,
      "end": 1709123925038,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1709123925039,
      "end": 1709123925039,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1709123925039,
      "end": 1709123925039,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709123925039,
      "end": 1709123925042,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1709123925042,
      "end": 1709123925042,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1709123925042,
      "end": 1709123925042,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1709123925042,
      "end": 1709123925043,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709123925043,
      "end": 1709123925045,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1709123925045,
      "end": 1709123925045,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1709123925045,
      "end": 1709123925046,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1709123925047,
      "end": 1709123925047,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1709123925047,
      "end": 1709123925047,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1709123925047,
      "end": 1709123925047,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1709123925047,
      "end": 1709123925047,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1709123925047,
      "end": 1709123925048,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1709123925048,
      "end": 1709123925048,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1709123925048,
      "end": 1709123925048,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1709123925048,
      "end": 1709123925049,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1709123925049,
      "end": 1709123925049,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1709123925049,
      "end": 1709123925050,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1709123925050,
      "end": 1709123925050,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1709123925050,
      "end": 1709123925050,
      "order": "post"
    },
    {
      "name": "quasar:directive",
      "start": 1709123925050,
      "end": 1709123925050,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1709123925050,
      "end": 1709123925050,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1709123925050,
      "end": 1709123925050,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1709123925050,
      "end": 1709123925052,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1709123925052,
      "end": 1709123925102,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1709123925102,
      "end": 1709123925102,
      "order": "normal"
    }
  ]
}
